---------------------------------HTML------------------------------------

FORM:

	form - создает форму для отправки данных на сервер, где эти данные будут обработаны с помощью языко программирования для Backend разработки. 
	Тег служит контейнером для тегов input, textarea, select, button, fieldset. Указанные теги не обязательно следует размещать в теге form, но, если этого не сделать, не произойдет отправки формы на сервер.
	Отправка формы на сервер осуществляется по нажатию на кнопку, создаваемую тегом input с атрибутом type в значении submit, или на кнопку button.
	
	<form action = "" method = "" target = "" enctype = ""></form> - все атрибуты тега form.
		action - Куда отправляем форму, на какую страницу сайта (своего или чужого). Если оставить пустым - форма отправится на текущую страницу. Необязательный атрибут. В атрибуте можно указывать ссылку на определенное место страницы (через #, как в теге a). В этом случае после отправки формы браузер откроет страницу, заданную в атрибуте action, на указанном месте.
		method - Метод отправки формы, может быть POST или GET. Верстальщику это знать не обязательно.
		target - указывает ссылке в какой вкладке ей открываться: в новой, в текущей или во фрейме.
			target = "_blank" - страница откроется в новой вкладке;
			target = "_self" - по умолчанию. страница откроется в текущей вкладке браузера;
			target = "_parent" - страница откроется во фрейм-родителе;
			target = "_top" - отменяет все фреймы и загружает страницу в полном окне браузера.
		enctype - Определяет способ кодирования данных формы.

INPUT:

	input - создает различные элементы HTML формы: обычное поле ввода, поле для ввода пароля, флажок, радиокнопку, чекбокс, кнопку.

	Атрибуты тега input: 
		type - 	Задает тип поля ввода.
			type = "text" - создает обычное текстовое поле ввода.
			type = "password" - поле ввода для пароля. Символы введенные в это поле будут зашифрованы.
			type = "checkbox" - создает флажок чекбокс.
			type = "radio" - создает радио переключатель.
			type = "hideen" - создает скрытый инпут, который не будет виден на экране, но будет отправдять содержащий в атрибуте value данные на сервер.
			type = "button" - создает кнопку. Нажатие на эту кнопку не будет отправлять форму на сервер. Она может быть использована внутри ссылки через JavaScript.
			type = "submit" - создает кнопку которая будет отправлять данные на сервер. Текст кнопки можно менять с помощью value.
			type = "reset" - создает кнопку, которая очищает заполненную форму.
			type = "file" - создает кнопку выбора файла. Дизайн этой кнопки запрещено менять через CSS(однако есть хитрые способы).
			type = "email" - создает поля для ввода эл.почты
			type = "number" - создает поле для ввода номера
			type = "url" - создает поле для ввода ссылки
			type = "tel" - создает поле для ввода телефона
			type = "color" - создает поле для добавления цвета
			type = "date" - создает поле для добавления даты (дд.мм.гг)
			type = "month" - создает поле для добавления месяца и года (мм.гг)
			type = "week" - добавляет поле для ввода недели,числа, года.
			type = "datetime-local" - создает поле для ввода даты и времени (дд.мм.гг --:--)
			type = "range" - создает поле в котором регулируется шкала.
		value - значение по умолчанию в поле ввода. В случае с кнопкой задаст ее текст.
		placeholder - подсказка в поле ввода.
		name - Имя поля ввода. Нужно для того, чтобы достать данные поля ввода в другой язык программирования.
		disabled - блокирует элемент формы.

LABEL: 
	label - задает метку для поля ввода типа input, textarea, select, и так далее. 
	Метка привязывается к определенному полю ввода с помощью атрибута for. В нем следует указывать значение атрибута id поля вводда, к которому привязана метка.

AUDIO:

	Тег <audio> добавляет, возпроизводит и управляет настройками аудиозаписи на веб српанице. Путь к файлу задается через атрибут src или вложенный элемент <source>. Внутри контейнера <audio> можно написать текст, который будет выводиться в браузерах, не работающих с этим тегом.

	СИНТАКСИС:
		<audio src="<адрес>"></audio>

		<audio>
 			<source src="<адрес>">
		</audio>

	АТРИБУТЫ:

		autoplay - Звук начинает играть сразу после загрузки страницы.

		controls - Добавляет панель управления у аудиофайлу.

		loop - Повторяет возпроизведение звука с начала после его завершения.

		muted - Отключает звук при воспроизведении музыки.

		preload - Используется для предварительной загрузки аудиофайла или его данных вместе с загрузкой веб страницы.

		src - Указывает путь к воспроизводимому файлу.

VIDEO:

	Тег <video> добавляет и воспроизводит и управляет настройками видеоролика на веб-странице. Путь к файлу задается через атрибут src или вложенный элемент <sourсe>.

	СИНТАКСИС:

		<video>
 			<source src="<адрес>">
		</video>

	АТРИБУТЫ:

		autoplay - Видео начинает воспроизводить автоматически после загрузки страницы.

		controls - Добавляет панель управления к видеоролику.

		height - Задает высоту области для воспроизвдения видеоролика.

		width - Задет ширину области для воспроизведения видеоролика.

		loop - Повторяет воспроизведение видео с начала после его завершения.

		poster - Указывает адрес картинки, которая будет отображаться, пока видео не доступно или не воспроизводится.

		preload - Используется для загрузки видео вместе с загрузкой веб-страницы.

		src - Указывает путь к воспроизводимому видеоролику.
----------------------------------CSS-----------------------------------


ЕДИНИЦЫ ИЗМЕРЕНИЯ:

	УГЛЫ:
		deg - В градусах. Полный круг равен 360deg;
		grad - В градах.Полный круг равен 400grad;
		rad - В радианах. Полный круг равен 2π или примерно 6.2832rad;
		turn - В поворотах. Один круг равен одному повороту и пишется как 1turn.

	РАЗМЕРЫ:

ПРОДВИНУТЫЕ СВОЙСТВА CSS
	
	
	letter-spacing - устанавливает интервал между буквами. Значением свойства служат любые единицы измерения. 

		letter-spacing: значение; 

	word-spacing - устанавливает интервал между словами. Значением свойства служат любые единицы измерения. 
	Если для текста задано выравнивание через text-align: justify, то интервал между словами будет установлен автоматичестки, но не меньше значения, указанного через word-spacing.

		word-spacing: значение;

	tab-size - устанавливает размер отступа, созданного клавишей Tab.

		tab-size: целое положительное число (0, 1, 2...);

	font-wariant - позволяет сделать маленькие (строчные) буквы ЗАГЛАВНЫМИ, но маленького размера.

		font-variant: small-caps | normal.
			small-caps - делает маленькие буквы заглавными маленького размера;
			normal - отменяет действие small-caps. 

	text-transform - устанавливает регистр символов текста: верхний регистр (заглавные буквы), нижний регистр (строчные буквы), может делать заглавной первую букву каждого слова.

		text-trasform: capitalize | lowercase | uppercase | none;
			capitalize - делает первую букву каждого слова заглавной;
			lowercase - делает все буквы маленькими;
			uppercase - делает все буквы заглавными;
			none - не меняет регистр слов.

	empty-cells - указывает браузеру как отображать фон и границу пустых ячеек таблицы.

		empty-cells: show | hide; 
			show - показывать;
			hide - скрыть.

	border-spacing - задает отступ между ячейками таблицы (td, th). Значения свойства служат любые единицы измерения.

		border-spacing: 1 или 2 значения.
			1 значение - Одно значение задает одинаковые отступы между ячейками по вертикали и по горизонтали.
			2 значение - Первое значение задает отступ по бокам, а второе значение - отступ свехну и снизу.

	border-collapse - заставляет двойные границы между ячейками таблицы (td, th) схлопнуть и выглядеть как одна. 

		border-collapse: collapse | separate;
			collapse - двойные границы будут выглядеть как одна. Есть побочные эффекты, не будут работать border-spacing и cellspacing.
			separate - каждая ячейка таблицы будет иметь свою границу.


	
	table-layout - позволяет указать браузеру то, что ячейки таблицы всегда должны быть заданной ширины.

		table-layout: fixed | auto | inehit;
			fixed - браузер не будет менять размер ячеек;
			auto - значение по умолчанию, браузер не будет менять размеры ячеек;
			inherit - наследует значение родителя.


	text-align-last - устанавливает выравнивание последней строки текста.

		text-align-last: center | left | right | justify | auto | start | end;
			center - выравнивание по центру;
			left - выравнивание по левому краю;
			right - выравнивание по правому краю;
			justify - одновременно и по правому краю, и по левому;
			auto - не изменяет выравнивание элемента;
			start - равно значению left, если текст идет слева направо, и справа если текст идет справа налево;
			end - Равно right, если текст идет слева направо и left, когда текст идет справа налево.
			inherit - наследует значение родителя.

	overflow - указывает браузеру, как поступать с содержимым, которое вылазит за границы блока. 

		overflow: hidden | scroll | auto | visible;
			hidden - скрытвает содержимое, которое вылезло за рамки блока;
			scroll - добавляет полосы прокрутки, причем всегда, даже если ничего не вылазит (в этом случае они будут неактивны);				auto - добавляет полосы прокрутки при необходимости: если содержимое не помещается они появятся, если все помещается, их не будет.;
			visible - значение по умолчанию. Не скрывает то содержимое, которое вылезло за рамки границы.

	overflow-wrap - позволяет перенсти буквы длинного слова на новую строку, если это слово не влазит в ширину контейнера.

		overflow-wrap: break-word | normal;
			break-word - заставляет длинные слова переносится на новую строку, елси это слово не помещается в контейнер. При этом слово начнется с новой строки;
			normal - значение по умолчанию. стандартное поведение: если длинное слово не влазит по ширине в контейнер - оно вылезает за его границу.

	hyphens - включает переносы слов с помощью знака "-"(тире). для поддержки русского языка необходимо укзаать атрибут lang = "ru".

		hyphens: auto | manual | none;
			auto - расставляет знаки переноса там, где это необходимо;
			manual - значение по умолчанию. добавляет переносы только в тех местах, где добавлен тег wbr или спецсимвол &shy;
			none - отменяет расстановку переносов.

	text-overflow - помещает троекточие в конец обрезанного текста в знак того, что текст не помещался в блок и был обрезан.

		text-overflow: ellipsis | clip;
			ellipsis - добавляет троеточие в конец обрезанного текста;
			clip - не добавляет троеточие в конец обрезанного текста.

	white-space - устанавливает как переносить текст на новую строку, а также как отображать пробелы между словами и переносы строк.

		white-space: nowrap | pre | pre-line | pre-wrap | normal;
			nowrap - запрещает тексту переноситься на другую строку, даже если он не помещается в ширину блока (в этом случае текст просто вылезет за его границы). Однако можно разделить текст при помощи тега br;
			pre - текст показывается так, как был набран в блокноте при верстке сайта: со всеми пробелами и enter-ами. При этом браузер не будет переносить текст на новую строку, если он не помещается в контейнер - текст просто вылезет за его границы.
			pre-line - Браузер учитывает только Enter-ы в HTML коде и игнорирует все остальное (несколько пробелов будут выглядеть как один, браузер сам расставляет разрывы строк).
			pre-wrap - то же самое что и pre, отличие в том что, если текст слишком длинный и не влазит в блок - браузер перенес его на другую сторону;
			normal - стандартное поведение: браузер сам расставляет разрывы строки так, чтобы слова поместились в блок. Несколько пробелов в коде будут выглядеть как один на экране.

		word-break - позволяет перенести буквы длинного слова на новую строку, если слово не влазит в ширину контейнера.

			word-break: break-all | keep-all | normal;
				break-all - заставляет длинные слова переносится на новую строку, если это слово не помещается в контейнер;
				keep-all - для переноса иероглифов;
				normal - значение по умолчанию. стандратное поведение: если текст не влазит, текст выйдет за ширину контейнера.

		user-select - управляет поведением выделения текста и других элементов на странице.

			user-select: none | contain | all | auto | text;
				none - текст не выделяется;
				contain - выделение, начатое внутри элемента, не выйдет за пределы этого элемента;
				all - если двойной клик произошел во вложенном элементе, будет выбрано все содержимое родителя с этим значением;
				auto - вычисляемое значение, автоматически определяется следующим образом: для псевдоэлементов after и before значение равно none, для редактируемого элемента значение равно contain, если у родителя элемента значение all или none - такое же будет и у самого элемента, иначе значение будет text;
				text - значение по умолчанию. пользователь может выдалить текст в элементе.
		

	opacity - задает прозрачность элементу.

		opacity: значение от 0 до 1.
			0 - полностью прозрачный элемент;
			1 - полностью непрозрачный элемент.

	text-shadow - задает тень тексту. Имеет 4 значения.

		text-shadow: сдвиг_по_х, сдвиг_по_y, размытие, цвет.

	box-shadow - задает тень блоку. В качестве значения принимает 6 параметров.

		box-shadow: inset сдвиг_по_х сдвиг_по_y размытие размер тени цвет;
		 inset - Если он задан то тень будет внутри контейнера, елси не задан - то снаружи;
		 сдвиг по x - Задает смещение тени по оси X. Положительное значение смещает вправо, отрицтельное - влево.
		 сдвиг по y - Задает смещение тени по оси Y. Положительное значение смещает вниз, отрицательное - вверх.
		 размытие - задает размытие тени, чем больше значение - тем более размытой будет тень.
		 размер тени - задает размер тени, положительное значение растягивает тень, отрицательное, наоборот ее сжимает.
		 цвет - задает цвет в любых единицах измерения.

	cursor - устанавливает внешний вид курсора при наведении на элемент.

		cursor: значение;
			ЗНАЧЕНИЯ:
				default - стандартный вид в виде указателя - стрелки;
				pointer - используется, чтобы показать что элемент является активным и на него можно нажимать (по умолчанию для ссылок)
				help - используется, чтобы показать, что с элементом связана какая то помощь или вопрос;
				not-allowed - используется чтобы показать недопустимые операции;

			ТЕКСТ:
				text - стандартный текстовый курсор в виде вертикальной палочки;
				vertical-text - текстовый курсор для вертикального текста; 

			ОЖИДАНИЕ:
				progress - используется, чтобы показать, что происходит какая-то операция и пользователю нужно подождать;
				wait - используется, чтобы показать, что пользователю нужно подождать;

			КУРСОР ПРИ ИЗМЕНЕНИЯХ РАЗМЕРОВ:
				n-rezise - вверх;
				ne-rezise - вправо вверх;
				e-rezise - вправо;
				se-rezise - вправо вниз;
				s-rezise - вниз;
				sw-rezise - влево вниз;
				w-rezise - влево;
				nw-rezise - влево вверх;
				nesw-rezise - вправо вверх и влево вниз;
				nwse-rezise -вправо вверх и влево вниз;

			ИЗМЕНЕНИЕ РАЗМЕРОВ ДВУХ ЭЛЕМЕНТОВ:
				col-rezise - изменение по горизонтали;
				row-rezise - изменение по вертикали;

			ИЗМЕНЕНИЕ МАСШТАБА:
				zoom-in - увеличение масштаба;
				zoom-out - уменьшение масштаба;

			ДВИЖЕНИЕ:
				move - используется, чтобы показать, что элемент можно перемещать, или в момент перемещения;
				alt-scroll - используется, чтобы показать, что елемент прокручивается мышкой во всех направлениях;

			РАЗНОЕ:	
				crosshair - внещний вид в виде прицела;
				cell - внещний вид в виде прицела.

	text-decoration-line - расположение линии у текста.

		text-decoration-line: underline | line-through | overline | none;
			underline - делает подчеркнутрый текст;
			line-through - делает перечеркнутый текст;
			overline - делает линию над текстом;
			none - убирает линию.

	text-decoration-style - меняет тип линии текста.

		text-decoration-style: solid | double | botted | dashed | wavy;
			solid - обычная линия;
			double - двойная линия;
			botted - линия в виде точек;
			dashed - пунктирная линия (тире)
			wavy - волнистая линия.

	text-decoration-color - задает цвет линии.

		text-decoration-color: любой цвет css формата.

	box-sizing - позволяет блоку не меняться в размере если указаны свойства как padding, border и т.д.

		box-sizing: content-box | border-box;
			content-box - и padding и border расширяют блок;
			border-box - ни padding ни border не расширяют блок;

	rezise: значение; - запрещает или разрешает изменение размеров textarea или других элементов.

		rezise: both | horizontal | vertical | none; 
		 both - можно растягивать элемент по высоте;
		 horizontal - можно растягивать элемент только по ширине;
		 vertical - можно растягивать элемент только по высоте;
		 none - нельзя растягивать элемент.

	flex-grow: значение; - определяет как много пространства во флекс контейнере должно быть назначено текущему элементу. 

		flex-grow: 1 | 2 | 3; 

	flex-shrink: значение; - определяет фактор сжатия flex-элемента. Flex-элементы будут заполнять контейнер в зависимости от значения flex-shrink, когда стандартная ширина контейнера flex-элемента шире, чем flex-контейнер.

		flex-shrink: 0 | 1 | 2;

	flex-basis: значение в единицах размера; - задает базовый размер flex-элемента по базовой оси.

		flex-basis: auto | 0 | 200px;

	flex: значения; - сокращенное написание трех свойств, указанных выше.

		flex: flex-grow flex-shrink flex-basis.
		flex: 1 auto 200px;

ГРАДИЕНТЫ:

	background: linear-gradient() - задает линейный градиент.

		linear-gradient( [угол или направление], цвет1 размер1, цвет2 размер2...).
			угол - угол в любых единицах для углов. может быть положительным или отрицательным. параметр необязательный. одновременно может быть задан или угол или направление, либо вообще ничего;
			направление - Перед направлением ставится слово to. задает направление градиента ключевыми словами to top, to left, to bottom, to right, или их комбинаций to top left, to top right.
			размер - задает протяженность определенного цвета градиента.

	background: radial-gradient() - задает радиальный элемент.

		radial-gradient([форма тип позиция], цвет1 размер1, цвет2 рфзмер2)
			форма - Принимаемые значения: ellipse эллиптический градиент (по умолчанию), circle круговой градиент;
			тип - задает растяжение градиента. Принимает значения closes-side, closest-corner, farthest-side, farthest-corner;
				closes-side - форма градиента совпадает с ближайшей к нему стороной блока;
				closest-corner - форма градиента вычисляется на основании информации о расстоянии до ближайшего угла блока;
				farthest-side - градиент распространяется до дальней стороны блока
				farthest-corner - форма градиента вычисляется на основании информации о расстоянии до дальнего угла блока.
			позиция - после ключевого слова at указывается позиция в любых единицаз измерения или с помощью ключевых слов top, bottom, left, right, center, в различных комбинациях.
			цвет1 - начальный цвет градиента в любых единицах для цвета;
			цвет2 - конечный цвет градиента в любый измерениях цвета;
			размер - задает протяженность определенного цвета градиента в любых единицах для размера.	

	background: repeating-linear-gradient(); - задает повторяющийся линейный градиент.

		repeating-linear-gradient([угол или направление], цвет1 размер1, цвет2 размер2...)
			направление - задает определенное направление градиента в любых единицах для углов либо ключенвыми словами со словом to (to top, top left, to bottom, to right, to top left,);
			угол - угол в любых единицах для углов (deg, grad, rad, turn);
			цвет - Начальный цвет градиента в любых единицах для цвета.
			размер - 	Задает протяженность определенного цвета градиента в любых единицах для размера.

DISPLAY:

	display: значение; - задает способ отображения жлемента браузером
		block - блочный элемент;
		inline - строчный элемент;
		inline-block - строчно-блочный элемент;
		run-in - устанавливает элемент как блочный или встроенный в зависимости от контекста;
		list-item - элемент станет пунктом списка и перед ним появится маркер списка;
		flex - устанавливает элемент как блочный, а потом его потомки станут flex-элементами;
		inline-flex - устанавливает элемент как строчно-блочный, а его потомки станут flex элементами.
		grid - создает элемент-сетку
		none - элемент пообще пропадает и все остальные жлементы ведут себя так, как будто его и нет;
		table - Элемент будет вести себя как таблица.
		inline-grid, grid - двумерная система сеток CSS. Пересикающийся набор горизонтальных и вертикальных линий, образующих колонки и строки.

GRID:

	GRID-СЕТКА:

		grid-template-columns: количество и их значение для столбцов. 
		grid-teplate-columns: 200px 200px 200px; - означает что будет 3 колонки размером 200px.
		grid-template-rows: 50% 50%; - означает что размер всех строк будет равен всему размеру высоты родительского блока.
		grid-auto-rows: 200px; - задает значение размера строки неявному grid-элементу.
		grid-auto-rows: 200px; - задает значение размеру столбца неявному grid-элементу.
		grid-auto-flow: row | column | dense - автоматическое размещение неявных grid-элементов..
			row - каждый невместившийся в родительский блок элемент будет помещать на новую строку.
			column - каждый невместившийся в родительский блок элемент будет создавать новый столбец.
			dense - grid элементы будут стараться заполнить все пространство родительского блока
		grid-template-areas: "a a a"
													"b b b"
													"c c c"; - создает грид-области путем иенования грид ячеек в грид-раскладке.
			grid-area: имя грид-ячейки из свойства grid-template-areas.

		grid-template: значения; - сокращенное написание выше указанных свойств.

			grid-template: grid-template-rows / grid-template-columns;

			grid-template: [start] "header" "header" 100px [row2]
							[row2] "side content" 1f [row-end] / 150px 1fr;

	GRID-ЭЛЕМЕНТЫ:

		grid-row-start: 1; - определяет начальную позицию элемента грид в строке.
		grid-row-end: 2; - определяет конечную позицию элемента грид в строке.
		grid-column-start: 1; - определяет начальную позицию элемента грид в столбце.
		grid-column-end: 2; - определяет конечную позицию элемента грид в столбце.

		grid-row: grid-row-start / grid-row-end. - сокращенное написание.
		grid-column: grid-column-start / grid-column-end. - сокращенное написание.

		order: число ячейки в сетке; - меняет порядок вывода элементов grid-сетки. Свойство следует задавать каждому элементу сетки.

		justify-items: stretch | start | center | end; - управляет горизонтальным выравниванием элементов сетки.
		aligт-self: stretch | start | center | end; - управляет вертикальным выравниванием элементов сетки.

		row-gap: 100px; - создает отступ между ячейками по вертикали.
		column-gap: 100px; - создает отступ между ячейками по горизонтали.
		gap: 20px; - создает отступы между всеми ячейками.

		fr - единица измерения для grid-элементов. Означает заполнение всего пространства grid-элемента.
			grid-teplate-columns: 1fr 1fr 1fr; - равно значению ниже.
			grid-teplate-columns: 33.333% 33.333% 33.333%;

КОЛОННЫ:
	
	column-count: число | auto; - задает рекомендуемое количество колоного в многоколоночном тексте;
		число - задает указанное количество колонок. Точнее, рекомендует браузеру использовать это количество колонок, так как их реальное количество может отличаться от заданного, в зависимости от ширины колонки и размера промежутка между ними.
		auto - значение по умолчанию. Браузер сам подбирает оптимальное количество колонок.

	column-width: значение в единицах для размера; - задает ширину колонок в многоколоночном тексте.

	column-gap: значение в единицах измерения; - задает расстояние между колонками в многоколоночном тексте.

	column-rule: значение; - задает границу между колонками. Совпадает по значениям с border.
		column-rule: 1px solid black;

	column-span: 1 | all; - задает количество столбцов, на которые должен растягиваться элемент в многоколоночном тексте.
		1 - элемент охватывает 1 колонку;
		all - элемент охватывает все колонки.
	
	colums - задает одновременно ширину и количество колонок. Значение по умолчанию auto auto.

BACKGROUND:

	background-clip - задает как фоновая заливка или фоновая картинка будет размещаться относительно элемента: часть фона будет залазить под границу, фон не будет залазить под границу или фон будет размещаться только над содержимым элемента (то есть padding отодвинет фон).
		
		background-clip: padding-box | border-box | content-box;
			padding-box - фон залезет под границу;
			border-box - фон не будет залезать под границу;
			content-box - фон будет только над содержиым

ПСЕВДОЖЛЕМЕНТЫ И ПСЕВДОКЛАССЫ:

	a:link - задает стиль ссылки, которая еще не была нажата.

	a:visited - задает стиль ссылки, которая уже была посещена пользователем.

	a:hover - задает стиль ссылки, когда на нее наводится курсор.

	a:active - задает стиль ссылки при нажатии на нее.

	input:focus - задает стиль текстовому полю, когда мы задаем фокус ввода на этом элементе

	input:checked+label - задает стиль лейблу, когда нужный наш пункт выбран. Использзуется для чекбоксов и радиокнопок.

	input:enabled - задает стиль для текстовому полю ввода, которая может быть активна.

	input:disabled - задает стиль для текстовому полю ввода, которая не может быть активна.

	input:required - задает стиль для текстовому полю с атрибутом required(строка, которая не может быть пустой).

	input:optional - задает стиль текстовому полю, которую не обязательно заполнять.

	input:valid - задает стиль текстовому полю, которое заполнено правильно.

	input:invalid - задает стиль текстовому полю, которое заполнено неправильно.

	input:-moz-placeholder
	input::-moz-placeholder
	input::-webkit-input-placeholder
	input-ms-placeholder
	input::placeholder - задает стиль текста в подсказке в поле ввода текста.

	p::first-line - задает стиль первой строки текста.

	p::first-letter - задает стиль первой букве каждого абзаца.

	p::-moz-selection; 
	p::-weblit-selection;
	p::selection - добавляет стиль при выделенном тексте.

	p:not() - позволяет сделать отрицание. Обращается к селекторам, которые не указаны в скобках.

	li::before - вставляет контент перед содержимым. ВСЕГДА указывается свойство content:''; которое можно оставлять пустым.	

	li::after - вставляет контент после содержимого. ВСЕГДА указывается свойство content:''; которое можно оставлять пустым.

	li:empty - задает свойство элементам списка, в которых ничего не содержит.

	li:first-child - позволяет обратиться к первому элементу списка.

	li:last-child -позволяе т обратиться к последнему элементу списка.

	li:nth-child(1, 2n, 2n+1, odd, even) - позволяет обратиться к определенному элементу списка.
		1 - обычное число, идущее по порядку.
		2n - обоащается к каждому второму число, если поменять цифру, будет обращаться к указанному элементу.
		odd - обращение ко всем четным числам.
		even - обращение ко всем нечетным числу.

	 li:nth-last-child(1) - позволяет обратиться к элементу списка начиная с конца.

	 li:only-child - обращается к элементу, который является единственным потомком своего родителя. если добавить второй элемент, свойство не будет работать.

	li:first-of-type - позволяет обратиться к первому элементу из своего типа.

	li:last-of-type - позволяет обратиться к последнему элементу из своего типа.

	li:nth-if-type(1, 2n, 2n+1, odd, even) - позволяет обратиться к определенному элементу из твоего типа.
		1 - обычное число, идущее по порядку.
		2n - обоащается к каждому второму число, если поменять цифру, будет обращаться к указанному элементу.
		odd - обращение ко всем четным числам.
		even - обращение ко всем нечетным числу.

	li:nth-last-of-type() - позволяет обратиться к элементу своего типа, начиная с конца. 

	li:only-of-type -  обращается ко всем элементам одного типа, если они единственные в своем блоке.

	div:target - позволяет задавать стиль элeмента, который указан в ссылке через хештег(#). 

АНИМАЦИИ:

	TRANSITION:

		transition-duration: значение в секундах; - (плавность) определяет количество времени в течении которого будет происходить переход.
			
			transition-duration: 1s;

		transition-property: значение; - содержит в значении css свойство к которому применяется. По умолчанию значение all.

			transition-property: background;

		transition-delay: значение в секундах; - задает задержку перед выполнением перехода.

			transition-delay: 0.5s;
		
		transition-timing-function: значение; - задает стиль анимации перехода.

			transition-timing-function: ease (по умолчанию) | ease-in | ease-out | ease-in-out | linear | steps(int, start, end) | cubic-bezier(x1 y1, x2 y2); 
				ease - переход начинается медленно, разгоняется быстро и замедляется в конце.
				ease-in - переход начинается медленно, а затем плавно ускоряется в конце.
				ease-out - переход начинается быстро, и плавно замедляется в конце.
				ease-in-out - переход медленно начинается и медленно заканчивается.
				linear - переход происходит равномерно на протяжении всего времени.
				steps(int, start, end) - Временная функция позволяет разбить анимацию на чёткое количество шагов указанных в int. Start – означает, что при начале анимации нужно сразу применить первое изменение. End - означало бы, что изменения нужно применять не в начале, а в конце каждого шага
				cubic-bezier(x1 y1, x2 y2) - позволяет вручную установить значения (положительные и отрицательные) для кривой ускорения и создать свою собственную анимацию.

		transition: transition-property transition-duration transition-timing-function transition-delay; - сокращенное написание всех свойств transition.

			transition: all 0.5s ease 0s;

	TRANSFORM:
		
		transform: значение; - трансформирует элемент, в частности позволяет его масштабировать, вращать, сдвигать, наклонять, а также комбинировать виды транформаций.

			transform-origin: <x> <y> <z>; - устанавливает координты точки, относительно которой будет происходить трансформация элемента.
				x <длина(px,em,rem)> | <проценты> | left | center | right - Координата по оси X. 
				y <длина(px,em,rem)> | <проценты> | top | center | bottom - Координата по оси Y.
				z - Координата по оси Z. Может задаваться только в любых корректных единицах для измерения длины.  

			transform: rotate(<угол>) - поворот элемента на зданный угол относительно точки трансформации задаваемой свойством transform-origin.

			transform: scale(sx, sy); - Масштаб элемента по горизонтали и вертикали.

			transform: scaleX(sx); - Масштабирует элемент по горизонтали.

			transform: scaleY(sy); - мсаштабирует элемент по вертикали.

			transform: skewX(<угол>); - наклоняет элемент на заданный угол по вертикали.

			transform: skewY(<угол>); - наклоняет элемент на заданный угол по горизонтали.

			transform: translate(tx, ty); - cдвигает элемент на заданное значение по горизонтали и вертикали.

			transform: matrix(a, b, c, d, tx, ty); - сокращенное написание всех элементов transform. 
				a - соответствует написанию свойства scaleX.
				b - соответствует написанию свойства skewX.
				c - соответствует написанию свойства skewY.
				d - соответствует написанию свойства scaleY.
				tx - соответствует написанию свойства translateX.
				ty - соответствует написанию свойства translateY.

	ANIMATION:

		
		В использовнии анимаций всегда указывается свойство @keyframes.
		Оно обязательно, без него ничего не будет работать.

		@keyframes "Имя анимации"{
			0%{
				left: 0%;
			}
			50%{
				left: 250px
			}
			100%{
				 left: 500px;
			}
		} - Обычная запись свойства @keyframes, в которой мы указываем путь анимации от 0% до 100%

		animation-name: "Имя анимации"; - свойство, в котором мы задаем имя анимации для использования с @keyframes.

			animation-name: cirсle;
			@keyframes circle{
				0%{

				}
				100%{

				}
			}

		animation-duration: "Время в секундах"; - время за которое анимация должна произвестись от начала до конца. Указывать можно несколько значений.

			animation-duration: 1s, 500ms, 0.5s;


		animation-timing-function: значение; - задает стиль анимации.

			animation-timing-function: ease (по умолчанию) | ease-in | ease-out | ease-in-out | linear | steps(int, start, end) | cubic-bezier(x1 y1, x2 y2); 
				ease - переход начинается медленно, разгоняется быстро и замедляется в конце.
				ease-in - переход начинается медленно, а затем плавно ускоряется в конце.
				ease-out - переход начинается быстро, и плавно замедляется в конце.
				ease-in-out - переход медленно начинается и медленно заканчивается.
				linear - переход происходит равномерно на протяжении всего времени.
				steps(int, start, end) - Временная функция позволяет разбить анимацию на чёткое количество шагов указанных в int. Start – означает, что при начале анимации нужно сразу применить первое изменение. End - означало бы, что изменения нужно применять не в начале, а в конце каждого шага
				cubic-bezier(x1 y1, x2 y2) - позволяет вручную установить значения (положительные и отрицательные) для кривой ускорения и создать свою собственную анимацию.

		animation-iteration-count: значение; - отвечает за количество повторов ключевых кадров. По умолчанию значение 1.

			animation-iteration-count: число | infinite;
				Число - анимация будет повторяться указанное количество раз.
				infinite - анимация будет повторяться бесконечно.

		animation-direction: значение; - определяет направление и тип проигрывания ключевых кадров.

			animation-direction: normal (По умолчанию) | reverse | elternate | alternate-reverse;
				normal - ключевые кадры будут проигрываться так, как они написаны.
				reverse - ключевые кадры будут проигрываться в обратном порядке.
				alternate - ключевые кадры будут проигрываться в обратном порядке, как только будут достигать конца.
				alternate-reverse - ключевые кадры начинают проигрываться в обратном порядке, и возвращаться на свое место.

		animation-play-state: Значение; - позволяет запускать либо приостанавливать анимацию по определенному событию.

			animation-play-state: running | pause;


		animation-delay: "Значение в секундах" указывает задержку в секундах, через сколько начать проигрывать анимацию. Если указывать отрицательную задержку анимации, тогда она будет проигрываться с определенного отрезка. 

			animation-delay: 1s;

		animation-fill-mode: значение; - определяет какие значения анимируемых css свойств применятся к объекту после завершения анимации.
			
			animation-fill-mode: none (По умолчанию) | forwards | backwards | both;
				none - никаих значений присваиваться не будет, объект вернется в исходное положение.
				forwards - применяет все значения css cвойств после завершения анимации. Не работает при бесконечном проигрывании.

		КРАТКАЯ ЗАПИСЬ: 

			animation: animation-name -> animation-duration -> animation-timing-function -> animation-iteration-count -> animation-direction -> animation-delay -> animation-fill-mode;

				animation: circle 2s linear infinite alterate 0s none;



---------------------------------JavaScript------------------------------------


	СТРОГИЙ РЕЖИМ:
		В современном JavaScript при написании кода первой строчкой нужно включать так называемый **строгий режим**. Этот режим заставляет браузер использовать все современные возможности 
		языка.  
		Для включения сторого режима первой строчкой скрипта необходимо поставить команду "use strict".

	КОММЕНТАРИИ: 
		Подобно языкам HTML и CSS в языке JavaScript можно оставлять комментарии. Они бывают однострочными и многострочными. 

		Вот пример однострочного комментария:
			alert('Привет, мир!'); // комментарий

		Вот пример многострочного комментария:
			/*
			комментарий
			*/
			alert('Привет, мир!');			
	
	ПЕРЕМЕННЫЕ:

		Основным понятием любого языка программирования является **переменная**. Переменная представляет собой контейнер, в котором мы можем хранить какие-либо данные, например строки или числа.

		Каждая переменная должна иметь имя, которое может состоять из латинских букв, чисел символов $ и знаков подчеркивания. При этом первый символ имени переменной не можеть быть цифрой. 
		Примеры названия переменных:
			str, my_str, myStr, a1, $, $a, $$a.

		Подход программирования через константы в JavaScript:

			В последнее время в JavaScript возник новый подход к объявлению переменных. Суть подхота в том, что вместо 
			let мы везде используем const, кроме тех случаев, когда мы точно знаем, что значение будет переменным. 

			Пример:
				const a = 1;
				const b = 2;
				const c = a + b;

				console.log(c);

			Этот подход очень популярный и вы можете встретить его в различных сторонних источниках. 

			Однако автор этого учебника. Дело в том, что константы были придуманы для хранения значений типа числа Пи. То есть для таких значений, которые предопределены в вашей программе. 
			Объявление же всех переменных константами противоречит этой идее. 

			Кроме того, не очень логично поведение массивов и объектов - мы объявляем их константами, при этом спокойно можем изменять их свойства. Что это за константы, 
			если их можно изменять?

			Часто объявление объектов константами используется для того, чтобы мы не смогли сменить тип данных - вместо объекта записать примитив. Но если 
			нам нужен контроль типов, которого нет по умолчанию в JavaScript, то лучше воспользоваться его диалектом TypeScript.

			В общем вы можете пользоваться этим подходом, раз такая мода, но автор учебника против и дальше в учебнике переменные по-прежднему будут объявляться через 
			let, как это было задумано авторами языка.  
		

		Использование переменных:

			Для того, чтобы использовать переменную, ее сначала необходимо объявить: написать перед ее именем ключевое слово **let**.
				let a;   

			После объявления переменной в нее можно записать (говорят присвоить ей) какое-либо значение, например, какое либо число или строку.
			
			Запись данных в переменную осуществляется с помощью операции присваивания **=**. Давайте, например, запишем переменную **a** в число 3:
				let a = 3;
			
			Выведем содержимое этой переменной на экран с помощью функции alert():
				let a = 3; // объявляем переменную и задаем ей значение
				alert(a);  // выведет 3
			
			Не обязательно записывать значение в переменную сразу после объявления. Можно сначала объявить переменную, а после присовить ей значение:
				let a;    // объявим переменную
				a = 3;    // присвоим ей значение
				alert(a); // выведем значение переменной на экран

			let, перед именем переменной пишется только один раз - при объявлении этой переменной. Затем, чтобы использовать переменную, нужно просто писать имя этой переменной.

		Объявление нескольких переменных:

			Объявим несколько переменных:
				let a = 1;
				let b = 2;
				let c = 3;

			Приведенный выше код можно упростить, написав let один раз и после него перечислить нужные переменные с их значениями:
				let a = 1, b = 2, c = 3;

			Можно вначале объявить все переменные, а затем присваивать им значения:
				let a, b, c; // объявляем все 3 переменные

				// Присваиваем переменным значения:
				a = 1;
				b = 2;
				c = 3;
		
		Изменение значения переменных:""

			Пусть у нас есть переменная, которой мы присвоили какое-то значение. Мы затем можем выполнить операцию присваивания еще раз и присвоить переменной другое значение:
				let a;    // объявляем переменную
				
				a = 1;    // записываем в нее значение 1
				alert(a); // выведет 1

				a = 2;    // записываем теперь значение 2, затирая значение 1
				alert(a); // выведет 2
			
			То есть значение переменной не является чем-то жестко привязанным к ней. Мы можем свободно записывать какие-то данные в переменную, прочитывать их, потом еще что-то записывать - и так далее.

		Несколько let для одной переменной:

			Одну и ту же переменную нельзя объявить несколько раз черех let. К примеру, следующий код приведет к ошибке:
				let a = 1;
				alert(a);

				let a = 2;
				alert(a);

			Здесь два варианта решения проблемы. Можно просто ввести две разные переменные:
				let a = 1;
				alert(a);

				let b = 2;
				alert(b); 

			А можно вначале объявить переменную, а затем делать операции с нею:
				let a;

				a = 1;
				alert(a);

				a = 2;
				alert(a);

		Константы в JavaScript:

			Кроме переменных в JavaScript можно создавать еще и **константы**. В них можно записывать данные только один раз, а затем их значения нельзя изменять. Константы объявляются с помощь оператора const.

			Обычно константы  используются для значений, которые не должны быть случайно изменены в коде. Для примера сделаем константу, в которой будет хранится значение числа пи:
				const pi = 3.14;
			
			Обычно константы записываются больими буквами, чтобы их можно было отличить от обычных переменных:
				const PI = 3.14;

			Попробуем изменить значение нашей константы:
				const PI = 3.14;
				PI = 3; // выдаст ошибку

		Область видимости переменных в if-esle в JavaScript:

			Пусть для простоты у нас есть всегда выполняющееся условие:
				if (true) {
	
				}
				
			Давайте расссмотрим следующий код:
				if (true) {
					let res = '!';
				}

				console.log(res);

			Как мы видим, в переменную res должно записаться значение '!'. Однако, если запустить этот код, то в консоль выведется ошибка!

			Дело в том, что переменные, объявленные внутри фигурных скобок, видны только внутри этих скобок, и не видны снаружи. По-научному
			здесь идет речь об области видимости переменных.

			Можно говорить о том, что областью видимости переменных, объявленных внутри фигурных скобок, являются только эти фигурные скобки.
			Однако, если переменная объявлена снаружи фигруных скобок, то видна и внутри, и снаружи:
				let res; // переменная объявлена снаружи

				if (true) {
					res = '!';
				}

				console.log(res); // выведет '!'

			В следующем примере в переменную res в зависимости от условия записывается либо значение 1, либо значение 2:
				let num = 5;

				if (num >= 0) {
					let res = 1;
				} else {
					let res = 2;
				}

				console.log(res);

			Однако, если запустить этот код, то в консоль выведется ошибка. Как мы теперь уже поняли, все дело в видимости переменных.
			Для решения проблемы объявим переменную снаружи условия:
				let test = true;
				let res; // объявим переменную снаружи условия

				if (test) {
					res = 1;
				} else {
					res = 2;
				}

				console.log(res); // выведет 1 

		Нюансы области видимости переменных в конструкциях if-else в JavaScript:

			Область видимости переменных обладает некоторым нюансом. Рассмотрим его на примере. Объявим снаружи нашего условия переменную res
			с одним значением, а внутри условия поменяем это значение на другое:
				let res = 1;

				if (true) {
					res = 2;
				}

				console.log(res); // выведет 2  

			Как мы видим, переменная res поменялась внутри условия. Все, однако, поменяется, если внутри условия также объявить переменную res через let:
				let res = 1;

				if (true) {
					let res = 2; // объявим переменную через let
				}

				console.log(res); // выведет 1, а не 2!

			Здесь дело в том, что объявление переменной через let внутри условия создало локальную переменную res. 

			То есть внутри условия существует одна переменная res, а внутри - другая. Убедиться в этом можно, выведя значения переменной в консоль
			внутри условия:
				let res = 1;

				if (true) {
					let res = 2;
					console.log(res); // выведет 2
				}

				console.log(res); // выведет 1

		Область видимости в циклах JavaScript:

			Давайте посмотрим, какой областью видимости обладают переменные при работы с циклами. Объявим 
			какую-нибудь переменную внутри цикла:
				for (let i = 1; i <= 9; i++) {
					let num = 3;
					console.log(num); // выведет 3
				}

			Если же попытаться вывести эту переменную снаружи цикла, то мы получим ошибку:
				for (let i = 1; i <= 9; i++) {
					let num = 3;
				}

				console.log(num); // выдаст ошибку

			При необходимости можно объявить переменную снаружи цикла - тогда она будет доступна как внутри цикла,
			так и снаружи:
				let num; // объявим переменную снаружи цикла

				for (let i = 1; i <= 9; i++) {
					num = 3; // установим ей значение
				}

				console.log(num); // выведет 3

		Вложенные циклы и область видимости в них:
			
			Если у нас есть цикл в цикле, то переменные, объявленные во внешнем цикле, будут доступны во внутреннем. В следующем примере 
			переменная num доступна во внутреннем цикле:
				for (let i = 0; i <= 9; i++) {
					let num = 3;
					
					for (let j = 0; j <= 9; j++) {
						console.log(num); // выведет 3
					}
				}

			А вот снаружи внешнего цикла переменная num недоступна:
				for (let i = 0; i <= 9; i++) {
					let num = 3;
					
					for (let j = 0; j <= 9; j++) {
						
					}
				}

				console.log(num); // выдаст ошибку

			Переменные объявленные во внутреннем цикле, недоступны снаружи:
				for (let i = 0; i <= 9; i++) {
					for (let j = 0; j <= 9; j++) {
						let num = 3;
					}
					
					console.log(num); // выдаст ошибку
				}

				console.log(num); // выдаст ошибку
					
	ОПЕРАЦИИ:

		Математические операции с числами в JavaScript:

			Cложение:
				let a = 1 + 2;
				alert(a); // выведет 3

			Вычитание:
				let b = 3 - 2;
				alert(b); // выведет 1

			Умножение:
				let c = 3 * 2;
				alert(c); // выведет 6

			Деление:
				let d = 4 / 2;
				alert(d); // выведет 2
		
		Математические операции с переменными в JavaScript:

			Математические операции можно производить не только над числами, но и над переменными. Сложим, к примеру, значения двух переменных:
				let a = 1;
				let b = 2;
				alert(a + b); // выведет 3

			Не обязательно сразу выводить результат операции, можно вначале записать его в какую нибудь переменную, а уже затем вывести значение этой переменной:
				let a = 1;
				let b = 2;
				let c = a + b; // запишем сумму в переменную c
				alert(c);      // выведет 3

		Приоритет математических операций в JavaScript:

			Математические операции JavaScript имеют такой же приоритет, как в обычной математике. То есть в начале выполняется умножение и деление, а потом уже сложение и вычитание. 

			В следующем примере вначале 2 умножится на 2 и затем к результату прибавится 3:
				let a = 2 * 2 + 3;
				alert(a); // выведет 7 (результат 4 + 3)

		Равный приоритет математических операций в JavaScript:

			Умножение и деление имеют равный приоритет и выполняются по очереди слева направо. Рассмотрим на примере, что имеется ввиду. 
			В следующем коде вначале выполнится деление, а потом умножение:
				let a = 8 / 2 * 4;
				alert(a); // выведет 16 (результат 4 * 4) 

			Если же переставить знаки местами, то вначале выполнится умножение, а потом деление:
				let a = 8 * 2 / 4;
				alert(a); // выведет 4 (результат 16 / 4)

			В следующем примере каждая новая операция деления будет применяться к предыдущей:
				let a = 16 / 2 / 2 / 2;
				alert(a); // выведет 2

		Группирующие скобки в JavaScript:

			При желании мы можем указывать приоритет операций с помощью круглых скобок. Давайте, например, переделаем наш код так, чтобы вначале выполнилось сложение,
			а потом уже умножение:
				let a = 2 * (2 + 3);
				alert(a); // выведет 10 (результат 2 * 5)

			Примечание: скобок может быть любое количество, в том числе и вложенных друг в друга:
				let a = 2 * (2 + 4 * (3 + 1));
				alert(a);

			В скобки можно заключить операции, обладающие приоритетом - это не будет ошибкой. Например, заключим в скобки произведение чисел:
				let a = (2 * 2) + 3;
				alert(a); // выведет 7 (результат 4 + 3)

			В данном случае скобки получаются лишними (у умножение ведь и так приоритет), но код является допустимым.

			Иногда такую группировку используют в тех местах, где приоритет операций не очевиден. Для примера рассмотрим следующий код:
				let a = 8 / 2 * 4;
				alert(a);

			Как мы уже знаем, в нем вначале выполнится деление, а потом умножение, Но с первого взгляда это может быть не слишком очевидно.

			Можно использовать группирующие скобки, чтобы явно показать приоритет:
				let a = (8 / 2) * 4;
				alert(a);

		Дроби в JavaScript:

			В JavaScript можно работать с десятичными дробями. При этом целая и дробная части отделяются друг от друга точкой.
			Пример:
				let a = 0.5;
				alert(a); // выведет 0.5

			Еще пример:
				let a = 0.5 + 0.5;
				alert(a); // выведет 1

		Отрицательные числа в JavaScript:

			Числа могут быть отрицательными. Для этого перед числом необходимо поставить знак минус:
				let a = -1;
				alert(a); // выведет -1

			Знак минус можно писать как к числам, так и к переменным:
				let a = 1;
				let b = -a; // записали в b содержимое a с обратным знаком
				alert(b);   // выведет -1

			Или вот так:
				let a = 1;
				alert(-a); // выведет -1

		Плюс перед числами в JavaScript:

			Подобно тому, как перед отрицательными числами ставится згак "минус", перед положительными числами можно поставить знак "плюс".

			Фактически этот плюс ничего не делает, но вполне является допустимым, пример:
				let a = +1;
				alert(a); // выведет 1

		Остаток от деления в JavaScript:

			Существует специальный оператор "%", с помощью которого можно найти остаток от деления одного числа на другое:
				alert(10 % 3); // выведет 1

			Если одно число делится нацело на второе - остаток будет равен нулю:
				alert(10 % 2); // выведет 0

			Оператор "%" конечно же, можно применять не только к числам, но и к переменным:
				let a = 10;
				let b = 3;
				alert(a % b); // выведет 1

		Возведение в степень в JavaScript:

			Для возведения в степень также существует специальный оператор **. Возведем число 10 в третью степень:
				alert(10 ** 3); // выведет 1000
			
			Возведем в степерь значение переменной:
				let a = 10;
				alert(a ** 3); // выведет 1000

			Может быть такое, что и число и степень будут содержаться в переменных:
				let a = 10;
				let b = 3;
				alert(a ** b); // выведет 1000

		Приоритет возведения в степень:

			Операция возведения в степень имеет приоритет перед умножением и делением. В следующем примере вначале выполнится возведение в степень, а затем умножение:
				alert(2 * 2 ** 3);

		Операции для изменения переменной в JavaScript:

			Над текущим значением переменной можно производить какие-то операции, а затем записывать результат обратно 
			в эту же переменную. Пример:
				let num = 1;   // объявляем переменную num и записываем в нее значение 1
				num = num + 2; // записываем в num ее саму плюс 2
				alert(num);    // выведет 3

		Сокращенные операции в JavaScript:

			Для таких операций, когда в переменную записывается ее текущее значение плюс еще что-то, существует 
			специальный сокращенный синтаксис. В этом синтаксисе вместо обычного присваивания применяется специальный
			оператор +=. Посмотрим на примере:
				let num = 1;
				num += 3; // эквивалентно num = num + 3;

			Существуют аналогичные операторы для остальных математических операций:
				let num = 2;
				num -= 3; // эквивалентно num = num - 3;


				let num = 2;
				num *= 3; // эквивалентно num = num * 3;


				let num = 2;
				num /= 3; // эквивалентно num = num / 3;

		Операции инкремента и декремента в JavaScript:

			Рассмотрим следующий код:
				let num = 0;
				num = num + 1; // прибавляем к переменной num число 1
				alert(num);    // выведет 1

			Как мы уже знаем этот код можно написать в сокращенном виде через оператор +=:
				let num = 0;
				num += 1;     // прибавляем к переменной num число 1
				alert(num);   // выведет 1

			На самом деле прибавление единицы в программировании встречается так часто, что для этой операции придуман 
			еще более сокращенный синтаксис - специальный оператор инкремент ++, увеличивающий значение переменной на 1.

			Перепишем наш код с его помощью:
				let num = 0;
				num++;        // прибавляем к переменной a число 1
				alert(num);   // выведет 1 

			Есть также операция декремент --, уменьшающая значение переменной на 1. Пример:
				let num = 0;
				num--;        // отнимаем от переменной num число 1
				alert(num);   // выведет -1

		Префиксный и постфиксный тип в JavaScript:

			На самом деле операции инкремента и декремента можно записывать двумя способами. Рассмотрим эти способы на примере ++, 
			а для -- все будет аналогично.

			В первом способе операция записывается после имени переменной, вот так: a++, а во втором способе - перед 
			именем переменной, вот так ++a.

			Первая форма называется постфиксной, а вторая - префиксной. Рассмотрим, в каких случаях проявляется разница между этими двумя 
			формами.

			Пусть у нас есть код alert(a++) и код alert(++a).

			В случае alert(a++) переменная сначала выведется, а потом увеличится на единицу, а в случае alert(++a) переменная 
			сначала увеличится на единицу а потом выведется.

			В следующем примере первый alert выведет 0, так как вначале сработает вывод на экран, а затем уже переменная увеличится:
				let num = 0;
				alert(num++); // выведет 0
				alert(num);   // выведет 1

			А теперь переменная вначале увеличится, а затем уже будет вывод на экран:
				let num = 0;
				alert(++num); // выведет 1 - переменная увеличилась сразу

			Такое поведение справедливо не только для вывода на экран, но и для присваивания:
				let num1 = 0;
				let num2 = num1++; // в переменную num2 запишется 0
				alert(num2); // выведет 0
				alert(num1); // выведет 1 - переменная num1 поменялась после записи в num2

			А теперь поменяем постфиксную форму на префиксную:
				let num1 = 0;
				let num2 = ++num1; // в переменную num2 запишется 1
				alert(num2); // выведет 1

			Если наша операция выполняется на отдельно строке, то разницы между постфиксной и префиксной формами нет:
				let num = 0;
				++num;
				num++;
				alert(num); // выведет 2
			
		Неточные вычисления в JavaScript:

			Дроби хранятся в компьютерах в таком виде, что часто могут быть представлены неточно. В этом случае вас может ждать некоторый сюрприз, когда 
			банальная операция выдает странный результат. Пример:
				let a = 0.1 + 0.2;
				alert(a); // выведет 0.30000000000000004

			Для борьбы с таким поведением можно применить специальный метод toFixed, выполняющий округление до заданного знака в дробной части. 
			Давайте округлим наш результат:
				let a = 0.1 + 0.2;
				alert(a.toFixed(2)); // выведет '0.30'

			Метод toFixed() отдает результат в виде строки. Можно преобразовать его результат в число:
				let a = 0.1 + 0.2;
				alert(+a.toFixed(2)); // выведет 0.3

		Проверка отстатка от деления в JavaScript: 

			Пусть у нас есть две переменные с числами:
				let a = 10;
				let b = 3;

			Давайте найдем остаток от деления одной переменной на другую:
				let a = 10;
				let b = 3;

				console.log(a % b); // выведет 1

			Пусть теперь в переменных хранятся такие значения, что одна переменная делится на вторую нацело:
				let a = 10;
				let b = 5;

				console.log(a % b); // выведет 0

			Давайте напишем скрипт, который будет проверять, длится ли нацело одно число на второе:
				let a = 10;
				let b = 3;

				if (a % b === 0) {
					console.log('делится нацело');
				} else {
					console.log('делится с остатком');
				}

			Пусть теперь требуется, если число делится с отстатком, вывести этот остаток в консоль:
				let a = 10;
				let b = 3;

				if (a % b === 0) {
					console.log('делится нацело');
				} else {
					console.log('делится с остатком ' + a % b);
				}

			В приведенном выше коде получается, что остаток вычисляется в двух местах, а это не оптимально. 
			Поправим проблему:
				let a = 10;
				let b = 3;
				let rest = a % b;

				if (rest === 0) {
					console.log('делится нацело');
				} else {
					console.log('делится с остатком ' + rest);
				}	

	СТРОКИ:

		Строки в JavaScript:

			Как уже упоминалось ранее, данные могут иметь различный тип. Один из типов - числа, мы уже немного изучили. Перейдем к строкам:
			
			Строки создаются с помощью кавычек:
				let str = 'abc';
				alert(str); // выведет 'abc'

			Кавычки могут быть не только одинарными, но и двойными:
				let str = "abc";
				alert(str); // выведет 'abc'

			Между одинарынми и двойными кавычками в JavaScript нет никакой разницы. Их исопльзование зависит от наших предпочтений.

		Сложение строк в JavaScript:

			Для сложения строк, так же, как и для сложения чисел, испольхуется оператор "+":
				let str = 'abc' + 'def'; // складываем две строки
				alert(str); // выведет 'abcdef' 

			Строки также могут хранится в переменных:
				let str1 = 'abc';
				let str2 = 'def';
				alert(str1 + str2); // выведет 'abcdef'

			Можно также складывать переменные и строки:
				let str1 = 'abc';
				let str2 = 'def';
				alert(str1 + '!!!' + str2); // выведет 'abc!!!def'

			Пусть две строки хранятся в переменных, а при их сложении мы хотим вставить между ними пробел. Это делается так:
				let str1 = 'abc';
				let str2 = 'def';
				alert(str1 + ' ' + str2); // выведет 'abc def'

			Пусть переменная только одна:
				let str = 'abc';
				alert(str + ' ' + 'def'); // выведет 'abc def'

			В этом случае нет смысла выделять пробел, как отдельную строку - вставим его как часть второго слагаемого:
				let str = 'abc';
				alert(str + ' def'); // выведет 'abc def'

		Длина строки в JavaScript:

			Количество символов в строке содержится в свойстве length:
				let str = 'abcde';
				alert(str.length); // выведет 5			

			Свойство length можно применять непосрественно к строке:
				alert('abcde'.length); // выведет 5

			Пробел также является символом:
				alert('ab de'.length); // выведет 5

		Шаблонные строки в JavaScript:

			Существует специальный тип кавычек - косые:
				let str = `abc`;
				alert(str); // выведет 'abc'

			В косых кавычках можно выполять вставку переменных. Для этого имя переменной нужно написать в конструкции ${}:
			
			Посмотрим на примере. Пусть мы хотим выполнить сложение строк и переменной:
				let str = 'xxx';
				let txt = 'aaa ' + str + ' bbb';

			Этот код можно переписать следующим образом:
				let str = 'xxx';
				let txt = `aaa ${str} bbb`;

		Многострочность:

			В JavaScript строках, созданных через одинарные или двойные кавычки, не допустим перенос строки. То есть вот так не будет работать:
				let str = 'abc
				def'; // так не будет работать

			И так не будет работать:
				let str = "abc
				def"; // так не будет работать

			А вот косые кавычки специально предназначены для создания многострочных строк:
				let str = `abc
				def`; // так будет работать

	СПЕЦИАЛЬНЫЕ ЗНАЧЕНИЯ:

		Специальные значения в JavaScript:

			В JavaScript, как и в других языках программирования, существуют ключевые слова для некоторых специальных значений. 
			Вот они: undefined, null, true, false, NaN, Infinity, -Infinity.

		Значение undefined:

			Значение undefined обозначает неопределенность. Такое значение будет у переменной, если мы объявили ее, но не записали в нее значение:
				let a;
				alert(a); // выведет undefined

			Это значение можно присвоить явно:
				let a = undefined;
				alert(a); // выведет undefined 

		Значение null:

			Значение null обозначает "ничего". К примеру, мы можем присвоить переменной такое значение в знак того, 
			что там ничего не лежит:
				let a = null;
				alert(a); // выведет null

		Значение true и false:

			Значения true и false обозначают истину и ложь соответственно. Они используются для таких вещей, которые предполагают два варианта ответа - да или нет.
		
		Значение NaN:

			Значение NaN (Not-A-Number) обозначает **не число**. Такое значение получается тогда, когда мы пытаемся делать математические операции не с числами, 
			а с чем-то другим. К примеру, такое значение даст попытка умножить строку на число:
				alert('abc' * 3); // выведет NaN

			Любые операции с NaN приводять к тому, что результатом все равно останется NaN:
				alert(NaN + 1); // выведет NaN

		Infinity и -Infinity в JavaScript:

			Значения Infinity и -Infinity обозначают соответственно бесконечность и минус бесконечность. Такие значения получаются, если какое-то число поделить на ноль - 
			в этом случае JavaScript не выдаст ошибку, как в других языках программирования, а возвращает эти значения:
				alert( 1 / 0); // выведет Infinity
				alert(-1 / 0); // выведет -Infinity

	КОНСОЛЬ:

		Работа с консолью в JavaScript:

			Для удобства программистов в каждом браузере есть специальная **панель разработчика**. Чтобы открыть эту панель, нам нужно, находять на странице сайта кликнуть правой кнопкой мыши
			в любое место. В появившемся меню нужно выбрать самый нижний пункт (он будет назыаваться Inspect или как-то похоже на это).

			В открывшейся панели мы в основном будем пользоваться двумя вкладками: Elements и Console. В первой вкладке мы можем получать информацию по тегам страницы, а во второй - отладочную информацию
			JavaScript. 

			Разберемся с возможностями консоли.

			С помощью специальной команды console.log мы в своих скриптах можем выводить данные в консоль. Это применятся для того, чтобы заниматься отладкой программ.

			Для примера что-нибудь выведем в консоль:
				console.log(123)

			А теперь выведем значение переменной:
				let num = 123;
				console.log(num); 

			Можно вывести несколько перемнных по очереди:
				let num1 = 123;
				let num2 = 456;

				console.log(num1);
				console.log(num2);

			Можно вывести несколько переменных с помощью отдной команды, написав эти переменные чепез запятую:
				let num1 = 123;
				let num2 = 456;
				console.log(num1, num2);

		Типы данных в консоли JavaScript:

			В консоли разным цветом выводятся строки и числа. Это часто помогает найти ошибки в программах. 

			Выведем рядом число и строку, чтобы можно было увидеть разницу в цвете:
				console.log(123);
				console.log('123');

		Ошибки в консоли JavaScript:

			Когда в нашем коде допускается синтаксическая ошибка, JavaScript выводит информацию об этом в консоль. Такая ошибка будет выведена красным цветом, а справа от нее будет указан номер строки,
			на которой случилась эта ошибка. Этот номер является ссылкой - на него можно нажать и в консоли откроется наш код на строке с ошибкой.

			Попробуем на практике. Обратимся к несуществующей переменной. В этом случае JavaScript выдаст ошибку:
				alert(eee); // Uncaught ReferenceError: eee is not defined 

	ТИПЫ ДАННЫХ:
		
		Преобразование к числу в JavaScript:

			Рассмотрим следующий код:
				let a = '2';
				let b = '3';
				alert(a + b); // выведет '23'
			
			Как мы видим, в нашем случае обе переменных содержат в себе строки и складываются, соответственно, как строки.

			Пусть мы хотели бы, чтобы значения наших переменных в данном случае складывались не как две строки, а как числа. В этом случае мы можем принудительно преобразовать
			тип нашей переменной к числу, используя специальную функцию Number: 
				let a = '2';
				let b = '3';
				alert(Number(a) + Number(b)); // выведет 5

			Можео преобразовать строки в числа не в операции сложения, а сразу при записи в переменную - это будет работать:
				let a = Number('2'); // в переменную запишется число 2
				let b = Number('3'); // в переменную запишется число 3
				alert(a + b); // выведет 5

		Преобразование некорректных чисел в JavaScript:

			При попытке преобразовать строку, содержащую не только цифры, но и другие символы, функция Number вернет своим результатом значение NaN:
				alert(Number('2s')); // выведет NaN

			Тот же эффект даст использование плюса:
				alert(+'2s'); // выведет NaN

		Выделение чисел в JavaScript:

			Функция Number работает только со строками, состоящими из цифр, Однако при программировании на JavaScript часто встречаются ситуации, 
			когда вам нужно обращаться со строками, в начале которых стоит число, а затем буквы. 

			Примером такой строки может быть значение в пикселях: "12px". Пусть нам необходимо достать стоящее в начале число, отбросив строковую часть. 
			Для такой операции существует функция parseInt(). Давайте посмотрим ее работу на примере:
				let num = parseInt('12px');
				alert(num); // выведет 12

			Пиксели, однако иногда бывают дробными: "12.5px". В этом случае функция parseInt() пасует и выводит только целую часть:
				let num = parseInt('12.5px');
				alert(num); // все равно выведет 12
			
			В общем-то возможно такое поведение - это именно то, что нам нужно. Но если нет - будем использовать функцию parseFloat(), которое извлекает число 
			вместе с его дробной частью:
				let num = parseFloat('12.5px');
				alert(num); // выведет 12.5

			Конечно же, отсутствие дробной части не мешает фукнции parseFloat() работать корректно:
				let num = parseFloat('12px');
				alert(num); // выведет 12

		Преобразование к строке в JavaScript:
		 
		 	Иногда нужно выполнить обратное преобразование - из числа в строку. Для этого предназначена фукнция String:
				let str = String(123); // теперь в переменной строка '123'

			Еще пример:
				let num1 = 1;
				let num2 = 2;

				alert(String(num1) + String(num2)); // выведет '12'

		Применение преобразования к строкам в JavaScript:

			Пусть у нас будет переменная num с каким-то числом:
				let num = 12345;

			Найдем количество цифр в этом числе. Как мы уже знаем, чтобы найти длину строки, можно использовать свойство length.

			Оно, однако работает только со строками, а будучи применено к числу, не будет работать:
				let num = 12345;
				alert(num.length); // выведет undefined

			Для решения проблемы преобразуем наше число к строке и найдем длину этой строки:
				let num = 12345;
				let str = String(num); // преобразуем наше число к строке
				alert(str.length);     // найдем длину строки

			Можно не вводить промежуточную переменную str, а применить свойство length сразу к результату функции String:
				let num = 12345;
				alert(String(num).length); // найдем длину строки

		Преобразование логического типа в JavaScript:

			Сейчас рассмотрим, как ведут себя специальные значение true и false при преобразовании их к строкам или числам.

			Итак, попробуем выполнить преобразование к строке, используя функцию String:
				alert(String(true));  // выведет 'true'
				alert(String(false)); // выведет 'false'

			Как мы видим, значение true преобразуется в строку 	'true', а значение false - в строку 'false'. То есть при
			попытке сложения строки и логического значения, это логическое значение преобразуется в строку и произойдет сложение строк:
				alert('a' + true);    // выведет 'atrue'

			При приведении к числу значение true преобразуется в число 1, а значение false - в число 0:
				alert(Number(true));  // выведет 1
				alert(Number(false)); // выведет 0  

			Во всех математических операциях логические значения вначале преобразуется к числу. Пример:
				alert(true + 1);     // выведет 2
				alert(true + true);  // выведет 2

			Теперь изучим преобразование других типов данных к логическому. Такое преобразование осуществляется с помощью функции Boolean. Вот значения, которые при приведению к логическому типу 
			дают false: 
				console.log(Boolean(0));          // false
				console.log(Boolean(-0));         // false
				console.log(Boolean(+0));         // false
				console.log(Boolean(null));       // false
				console.log(Boolean(false));      // false
				console.log(Boolean(NaN));        // false
				console.log(Boolean(undefined));  // false
				console.log(Boolean(''));         // false
			
			Вот остальные значения в JavaScript (в других языках бывает не так) дают true. Вот значения, пирводящие к true, но могущие вызвать у вас сомнения:
				console.log(Boolean(-1));          // true
				console.log(Boolean(Infinity));    // true
				console.log(Boolean(-Infinity));   // true 

			Слещующие значения являются строками, так как взяты в кавычки, и также приводятся к true:
				console.log(Boolean('0'));         // true
				console.log(Boolean('false'));     // true
				console.log(Boolean('NaN'));       // true
				console.log(Boolean('null'));      // true
				console.log(Boolean('undefined')); // true 

		Получение к логическому типу в JavaScript:

			Теперь изучим преобразование других типов данных к логическому. Такое преобразование осуществляется с 
			помощью функции Boolean. Вот значения которые при приведению к логичекскому типу дают false:
				console.log(Boolean(0));          // false
				console.log(Boolean(-0));         // false
				console.log(Boolean(+0));         // false
				console.log(Boolean(null));       // false
				console.log(Boolean(false));      // false
				console.log(Boolean(NaN));        // false
				console.log(Boolean(undefined));  // false
				console.log(Boolean(''));         // false 

			Вот остальные значения в JavaScrip (в других языках бывает не так) дают true. Вот значения, приводящиеся к true, 
			но могущие вызвать у нас сомнения:
				console.log(Boolean(-1));          // true
				console.log(Boolean(Infinity));    // true
				console.log(Boolean(-Infinity));   // true

			Следующие значения являются строками, так как взяты в кавычки, и также приводят к true:
				console.log(Boolean('0'));         // true
				console.log(Boolean('false'));     // true
				console.log(Boolean('NaN'));       // true
				console.log(Boolean('null'));      // true
				console.log(Boolean('undefined')); // true

		Получение символов строки на JavaScript:

			Пусть у нас есть какая-то строка. Каждый символ в этой строке имеет свой порядковый номер: первый символ 0, второй символ - номер 1,
			третий символ 2 и так далее. 

			Как мы уже заметили, нумерация символов начинается с нуля (ноль как начало нумерации часто встречается в программировании).

			При необходимости можно получить доступ к определенному символу строки по его номеру. Для этого пишется имя переменной, 
			после этого имени ставятся квадратные скобки и в этих скобках указывается номер символа. 

			Посмотрим на примере. Пусть у нас дана вот такая строка:
				let str = 'abcde';

			Обратимся к каким-нибуль символам этой строки:
				let str = 'abcde';

				alert(str[0]); // выведет 'a'
				alert(str[1]); // выведет 'b'
				alert(str[2]); // выведет 'c'

			Номер символа может также наодиться и в переменной:
				let str = 'abcde';
				let num = 3; // номер символа в переменной

				alert(str[num]); // выведет 'd' 

		Неизменяемость строк в JavaScript:

			Символы строк можно читать, но нельзя изменять. Следующий пример кода выдаст ошибку (в строгом режиме):
				let str = 'abcde';
				str[0] = '!';

		Последний символ строки в JavaScript:

			Выведем последний символ строки. При этом сделаем так, чтобы наш скрипт сам определял номер последнего символа, 
			не зависимо от длины строки:
				let str = 'abcde';

			Как мы видим, количество символов в этой строке равно 5. Если немного подумать, то становится очевидным, что
			номер последнего символа этой строки будет на 1 меньше ее длины, так как нумерация символов начинается с нуля. 

			Получается, что зная длину строки, мы можем отнять у нее один и получить номер последнего символа, а затем
			по этому номеру можно получить сам последний символ. 

			Как мы уже знаем, длину строки можно найти с помощью свойства length. Исходя из этого найдем номер последнего символа:
				let str = 'abcde';
				let last = str.length - 1; // номер последнего символа

			Испольузем найденный номер для вывода символа на экран:
				let str = 'abcde';
				let last = str.length - 1; // номер последнего символа
				alert(str[last]); // выведет 'e'

			Промежуточную переменную last можно и не вводить:
				let str = 'abcde';
				alert(str[str.length - 1]); // выведет 'e'

		Строки с цифрами в JavaScript:

			Пусть у нас есть строка, содержащая только цифры:
				let test = '12345'; // строка с цифрами

			Найдем, например, сумму первого и второго ее символов:
				let test = '12345';
				alert(test[0] + test[1]); // выведет '12' - суммирует как строки 

			Как мы видим, символы нашей строки также являются строками и суммируются как строки. Пусть мы хотим 
			суммировать их как числа. Используем для этого функцию Number:
				let test = '12345'; // строка
				alert(Number(test[0]) + Number(test[1])); // выведет 3

		Обращение к цифрам числа в JavaScript:
			
			Пусть теперь в переменной у нас хранится не только число в кавычках, а просто число. В этом случае попытка
			обратиться к его отдельному символу выдаст undefined, так как такое обращение работает только для строк:
				let test = 12345;
				alert(test[0]); // выдаст undefined

			Для решение проблемы преобразуем наше число в строку:
				let test = String(12345); // строка
				alert(test[0]); // выведет '1' - все работает

			Пусть мы теперь хотим найти суммку первых двух цифр:
				let test = String(12345); // строка
				alert(test[0] + test[1]); // выведет '12' - суммирует как строки

			Добавим функцию Number для того, чтобы символы суммировались как числа:
				let test = String(12345); // строка
				alert(Number(test[0]) + Number(test[1])); // выведет 3

			Проблема такого рода возникает только при суммированиию. При умножении, например, преобразование 
			к числам можно не выполнять:
				let test = String(12345); // строка
				alert(test[1] * test[2]); // выведет 6

		

			Средствами JavaScript можно управлять тегами HTML страницы, например, выводить в них текст. Этому мы будем учиться позднее, 
			когда будем проходить раздел, посвященный работе с DOM.

			Иногда, однако, в отладочных целях требуется вывести какой-нибудь текст в окно бразуера. Это делается с помощью команды docunent.write. Посмотрим 
			работу с ней на примерах.

			Выведем числовое значение:
				document.write(123);

			Выведем какой-нибудь текст:
				document.write('text');

			Выведем текст, заключенный в теги:
				document.write('<b>text</b>');

			Выведем текст из переменной:
				let str = 'text';
				document.write(str);

			Заключим текст из переменной в теги:
				let str = 'text';
				document.write('<b>' + str + '</b>');

			Выведем текст в два ряда:
				document.write('text <br> text');

			Выведем много текстов в колонну:
				document.write('text1<br>');
				document.write('text2<br>');
				document.write('text3<br>');

			Можно и вот так:
				document.write('text');
				document.write('<br>');
				document.write('text');

		Автоматическое преобразование типов данных:

			Как мы уже знаем, строки в JavaScript следует брать в кавычки. Может быть такое, что всеми символами строки будут являться цифры:
				let a = '123';

			В этом случае переменная а также является строкой, но с некоторым нюансом.

			Суть нюанса заключается в следующем: елси над строкой с цифрами выполнить какую-либо математическую операцию - эта операция будет выполнена так, 
			будто у нас действительно числа, а не строки:
				alert('2' * '3'); // выведет 6

			В данном случае JavaScript видит, что фактически наши строки - это числа в кавычках. Поэтому JavaScript посчитает операцию неккоректной и 
			сделает ее результатом значение NaN:
				alert('2' * '3s'); // выведет NaN

			Кроме того, автоматическое преобразование происходит, если операция математически корректна, но недопустима для строк. 

			Например, строки нельзя (а числа можно) умножать, делить, вычитать, поэтому во всех таких операциях будет автоматическое преобразование строк с цифрами в числа.

			Однако, строки как и числа, складываются с попощью оператора "+". Это значит, что в случае сложения автоматического преобразования не будет:
				let a = '1' + '2';
				alert(a); // выведет '12' - произошло сложение строк

			Если одно из слагаемых число, а другое - строка, то всегда побеждает строка. 
				let a = 1 + '2';
				alert(a); // выведет '12'

			В таких случаях JavaScript, наоборот, автоматически преобразует числа в строки и выполняет сложение строк. 

			Есть, однако нюансы, когда слагаемых больше, чем два: в этом случае преобразование к определенному типу зависит от порядка выполнения операций. 

			В следующем примере вначалае 2 и 3 сложатся как числа, а затем результат прибавится к строке "1" уже как строка "5", что в итоге даст строку "15":
				let a = '1' + (2 + 3);
				alert(a); // выведет '15'

			Если же убрать скобки, то все будет складываться слева направо. То есть сначала к строке "1" прибавится число 2 и в результате получится строка "12". Затем 
			к этой строке прибавится число 3 и в результате получится строка "123":
				let a = '1' + 2 + 3;
				alert(a); // выведет '123' 

			А вот в следующем примере числа 2 и 3 написаны в начале, поэтому сначала они сложатся как числа, дав в результате число 5, а затем к этому числу прибавится строка "1",
			дав в итоге строку "51".
				let a = 2 + 3 + '1';
				alert(a); // выведет '51'
		
		Массивы в JavaScript

			Внешний вид массива:

				Сейчас мы начнем изучать специальный тип данных, который называется массив. Массив представляет собой переменную, в которой в упорядоченном 
				виде можно хранить целый набро каких-то значений. 

				Значения, которые хранит массив, называюьтся элементами. Элементы разделяются между собой запятой.
				После этой запятой принято ставить пробелы.

				Для создания массива используются квадратные скобки:
					let arr = [];

				Заполним массив строками:
					let arr = ['a', 'b', 'c'];

				А теперь заполним его числами:
					let arr = [1, 2, 3];

				Кроме строк и числе в массиве можно хранить все допустимые типы данных, а также смешивать их между собой в одном массиве,
				пример:
					let arr = [1, 2, 'a', 'b', null, true, false];

			Получение элементов массивов в JavaScript:

				Обращение к элементам массива осуществляется подобно обращениям к символам строки. Каждый элемент массива имеет свой номер:
				первый элемент - номер 0, второй элемент - номер 1 и так далее. Эти номера называются ключами элементов массива. Посмотрим на примере.
				Пусть у нас дан следующий массив:
					let arr = ['a', 'b', 'c'];

				Выведем его элементы:
					console.log(arr[0]); // выведет 'a'
					console.log(arr[1]); // выведет 'b'
					console.log(arr[2]); // выведет 'c'

			Длина массива в JavaScript: 

				Длина массива находится с помощью свойства length:
					let arr = ['a', 'b', 'c'];
					console.log(arr.length) // выведет 3
				
				Зная длину массива, можно получить его последний элемент:
					let arr = ['a', 'b', 'c'];
					console.log(arr[arr.length - 1]) // выведет 'c'

			Изменение элементов массива в JavaScript:

				Элементы массива можно изменять:
					let arr = ['a', 'b', 'c'];

					arr[0] = '!';
					console.log(arr); // выведет ['!', 'b', 'c']

			Перезапись элементов массива в JavaScript:

				Можно также прочитывать текущее значение элемента, выполнять с ним какие-то операции и записывать измененное значение 
				обратно в этот элемент:
					let arr = ['a', 'b', 'c'];

					arr[0] = arr[0] + '!';
					arr[1] = arr[1] + '!';
					arr[2] = arr[2] + '!';

					console.log(arr); // выведет ['a!', 'b!', 'c!'] 

				Предыдущий код можно записать через оператор +=:
					let arr = ['a', 'b', 'c'];

					arr[0] += '!';
					arr[1] += '!';
					arr[2] += '!';

					console.log(arr); // выведет ['a!', 'b!', 'c!']

			Инкремент и декремент элементов массива в JavaScript:

				Можно также применять операции инкремента и декремента:
					let arr = [1, 2, 3, 4];

					arr[0]++;
					++arr[1];
					arr[2]--;
					--arr[3];

					console.log(arr); // выведет [2, 3, 2, 3]

			Добавление элементов по ключам JavaScript:

				Элементы в массив не обязательно добавлять сразу в момент объявления этого массива. Можно вначале объявить массив,
				а затем добавить в него необходимые элементы, вот так:
					let arr = [];

					arr[0] = 'a';
					arr[1] = 'b';
					arr[2] = 'c';

					console.log(arr); // выведет ['a', 'b', 'c']

				Можно также добавлять элементы в массив, уже заполненный данными:
					let arr = ['a', 'b', 'c'];

					arr[3] = 'd';
					console.log(arr); // выведет ['a', 'b', 'c', 'd']

			Разреженные массивы в JavaScript:

				Если в массиве будут ключи с пропусками, то можно получить разряженный массив. Давайте посмотрим, как он выглядит.
				Пусть у нас есть некоторый массив:
					let arr = ['a', 'b', 'c'];

				Добавим к этому массиву еще один элемент так, чтобы ключи имели пропуски:
					arr[4] = '!';

				В результате в массиве образуется дыра, имеющая значение undefined:
					console.log(arr); // выведет ['a', 'b', 'c', undefined, '!']

				Длина массива будет включать в себя все дыры. То есть в нашем случае она будет 5, а не 4:
					console.log(arr.length); // выведет 5  

			Ключи массивов из переменных в JavaScript:
				
				Пусть у нас дан вот такой массив:
					let arr = ['a', 'b', 'c'];

				Выведем его на экран с ключом 0:
					let arr = ['a', 'b', 'c'];
					console.log(arr[0]); // выведет 'a'

				Давайте теперь ключ выводимого элемента не будем писать непосредственно в квадратных скобках, а запишем его переменную:
					let arr = ['a', 'b', 'c'];
					let key = 0; // запишем ключ в переменную

				Используем теперь нашу переменную для вывода соответствующего элемента:
					let arr = ['a', 'b', 'c'];
					let key = 0; // запишем ключ в переменную

					console.log(arr[key]); // выведет 'a'

	ОПЕРАТОРЫ:

		Функция prompt в JavaScript:

			Вы уже знаете о существовании функции alert, выводящей заданное сообщените на экран. Существует также похожая функция prompt,
			которая позволяет получить от пользователя какой либо текст.

			Для примера просим имя пользователя: 
				prompt('Ваше имя?');

			Запустим приведенный выше код, чтобы увидеть окошко, выводимое функцией prompt. Вобьем наше имя и нажмем на кнопку. Если мы проделали 
			все описанные выше манипуляции, то введенное нами имя попадет в наш скрипт.

			Для того, чтобы получить доступ к введенному имени, результат работы функции prompt нужно присвоить в какую нибудь переменную, например вот так:
				let name = prompt('Ваше имя?');

			Давайте на следующей строке кода выведем на экран введенное ранее имя, воспользовавшись функцией alert:
				let name = prompt('Ваше имя?');
				alert('Ваше имя: ' + name);

			Мы должны понимать, что при вызове функции prompt дальнейшее выполнение скрипта блокируется, пока не будут введены соответствующие данные.
			В общем-то, также работает и функция alert, только она ожидает нажатия на соответствующую кнопку. 

			Кстати, использовать переменную необязательно:
				alert('Ваше имя: ' + prompt('Ваше имя?'));

		Проблема с типами в функции prompt в JavaScript:

			Необходимо учитывать, что функция prompt всегда возвращает строку, даже если пользователь вводил число. Для примера
			рассмотрим следущий скрипт:
				let num1 = prompt('Введите первое число');
				let num2 = prompt('Введите второе число');

				alert(num1 + num2); // сложит числа как строки 

		Добавление элементов через push в JavaScript:

			С помощью специального метода push можно добавлять элементы в конец массива. Давайте посмотрим, как это делается.
			Пусть у нас есть слеюущий масиив:
				let arr = [];

			Добавим ему в конец три элемента:
				arr.push('a');
				arr.push('b');
				arr.push('c');

			Посмотрим что получилось:
				console.log(arr); // выведет ['a', 'b', 'c']

		Оператор delete в массивах в JavaScript:

			Можно удалять элементы массивов с помощью оператора delete. Давайте посмотрим на примерах. 
			Пусть у нас дан вот такой массив:
				let arr = ['a', 'b', 'c'];

			Давайте удалим один из элементов нашего массива:
				delete arr[1];

			В результате элемент удалился, но массив станет разреженным:
				console.log(arr); // выведет ['a',, 'c']

		Оператор in в JavaScript:

			С помощью оператора in можно проверять ниличие свойства в объекте. Давайте посмотрим на примере,
			Пусть у нас дан вот такй объект:
				let obj = {a: 1, b: 2, c: 3};

			Давайте проверим наличие в нашем объекте какого-нибудь свойства:
				console.log('b' in obj); // выведет true

			А теперь выполним проверку для несуществующего свойства:
				console.log('x' in obj); // выведет false

		Оператор delete в JavaScript:

			Можно удалять элементы объектов с помощью оператора delete. Давайте посмотрим на примерах. Пусть у нас 
			дан вот такой объект:
				let obj = {a: 1, b: 2, c: 3};

			Давайте удалим один из элементов нашего объекта:
				delete obj.b;

			Посмотрим, что у нас получилось:
				console.log(obj); // выведет {a: 1, c: 3}

		Опреатор spread:

			Опреатор spread в JavaScript:

				В ES6 появился специальный оператор ..., называющийся spread.

				Когда оператор spread стоит перед массивом, он разделяет этот массив на отдельные значения, превращая 
				массив в набор параметров, необходимых для вызова функции. 

				Наверняка звучит непонятно, поэтому давайте посмотрим на простом примере. Пусть у нас есть функция, принимающая 
				3 параметра и возвращающая их сумму:
					function func(num1, num2, num3) {
						return num1 + num2 + num3;
					}

				Пусть у нас также есть массив элементов:
					let arr = [1, 2, 3];

				Очевидно, что мы не можем просто взять и передать этот массив параметром функции, вот так:
					let arr = [1, 2, 3];
					func(arr);

				Ведь в этом случае весь массив попадет в первый параметр функции, а в этот параметр необходимо передать число 
				(да и в остальные тоже).

				Конечно, можно поступить таким способом:
					let arr = [1, 2, 3];
					func(arr[0], arr[1], arr[2]);

				Но есть и более простой путь - использовать оператор spread:
					let arr = [1, 2, 3];
					func(...arr);

				Наличие переменной не является обязательным - можно применять spread прямо к массиву:
					func(...[1, 2, 3]);

			Использование spread в JavaScript:

				Пусть у нас есть вот такая функция с 5-ю параметрами:
					function func(num1, num2, num3, num4, num5) {
						return num1 + num2 + num3 + num4 + num5;
					}

				Мы можем с помощью spread передать в эту функцию один массив:
					func(...[1, 2, 3, 4, 5]);
				
				Но это не обязательно!

				Можно передать два массива:
					func(...[1, 2], ...[3, 4, 5]);

				Можно передать часть параметров обычным способом, а часть с помощью spread:
					func(1, 2, ...[3, 4, 5]);

				Или вот так:
					func(1, ...[2, 3, 4], 5);

			Экстремальные значения массива через spread в JavaScript:

				Посмотрим на следующий код:
					let max = Math.max(1, 2, 3, 4, 5);

				Как вы видите, в этом коде находится максимальное из чисел. Но что делать, если наши числа представлены
				в виде массива? Например вот так:
					let arr = [1, 2, 3, 4, 5];

				Мы, уже, не сможем сделать следующее:
					let arr = [1, 2, 3, 4, 5];
					let max = Math.max(arr); // здесь нельзя передавать массив

				Конечно, же, мы можем вручную поставить элементы массива в Math.max, вот так:
					let arr = [1, 2, 3, 4, 5];
					let max = Math.max(arr[0], arr[1], arr[2], arr[3], arr[4]);

				Однако, в этом случае теряется всякая уникальность: наш код будет находить максимальное значение 
				лишь для массива из 5 элементов.

				А что, если нам понадобится больше или меньше элементов в массиве? Решение есть! Используем 
				оператор spread:
					let arr = [1, 2, 3, 4, 5]
					let max = Math.max(...arr);

				Данный код, несмотря на его простоту, очень мощный. Ведь Math.max может принимать любое количество 
				параметров, а значит с помощью оператора spread мы можем использовать массив произвольного размера!

			Оператор spread и слияние массивов:

				Пусть у нас есть два массива:
					let arr1 = ['a', 'b', 'c'];
					let arr2 = [1, 2, 3];

				Давайте сделаем так, чтобы между первым и вторым элементами массива arr2 вставились элементы массива 
				arr1.

				Говоря другими словами, мы хотим написать код, который из текущего массива arr2 сделает следующий массив:
					[1, 'a', 'b', 'c', 2, 3]

				Задача, в общем-то, решаема, через метод splice. Однако, гораздо проще эта задача решается через spread:
					let arr1 = ['a', 'b', 'c'];
					let arr2 = [1, ...arr1, 2, 3];

					console.log(arr2); // выведет [1, 'a', 'b', 'c', 2, 3]

			Оператор spread для строк в JavaScript:

				Оператор spread, примененный к строке, разбирает эту строку посимвольно:
					...'abcde'; // разобьет строку в символы через запятую: 'a','b','c','d','e'

				Результат такого разбиения можно передавать в параметры функции:
					function func(s1, s2, s3, s4, s5) {
						return s1 + '-' + s2 + '-' + s3 + '-' + s4 + '-' + s5;
					}

					console.log( func(...'abcde') ); // выведет 'a-b-c-d-e'	

				А можно перобразовать этот результат в массив:
					let arr = [...'abcde']; // получим массив ['a', 'b', 'c', 'd', 'e']

			Оператор spread и числа в JavaScript:

				Оператор spread не применим к числам:
					let arr = [...12345]; // будет ошибка

				Для решения проблемы следует преобразовать число в строку, вот так:
					let arr = [...String(12345)]; // получится массив ['1', '2', '3', '4', '5']

		Оператор rest:

			Оператор rest в JavaScript:

				Данный урок начнем с некоторого пояснения. Все предыдущие уроки данного раздела не было полной правды 
				про оператор ...

				На самом деле этот оператор в зависимости от места в коде может называться либо оператором spread, либо 
				оператором rest.

				Как вы уже знаете, когда оператор spread стоит перед массивом или строкой, он разделяет их на отдельные 
				значения. Оператор rest, хотя и имеет такой же синтаксис в виде ..., но предназначен для другого.

				Сейчас будем разбираться, для чего. Пусть у нас есть функция, принимающая два параметра:
					function func(a, b) {
						console.log(a);
						console.log(b);
					}

				Вы должны уже знать, что если в функцию передать лишние параметры, это не приведет к ошибке:
					func(1, 2, 3, 4, 5);

				Оператор rest позволяет получить все лишние параметры в виде массива. Для этого в функцию добавляется еще 
				один параметр (обязательно последним), перед которым пишутся 3 точки:
					function func(a, b, ...rest) {
	
					}

				Эти три точки и есть оператор rest, а имя переменной может иметь любое название, но обычно также принято 
				называть его rest.

				Давайте вызовем нашу функцию с избыточным количеством параметров и посмотрим, что попадет в 
				параметры a и b, а что - в отстаток rest:
					func(1, 2, 3, 4, 5);

					function func(a, b, ...rest) {
						console.log(a);    // выведет 1
						console.log(b);    // выведет 2
						console.log(rest); // выведет [3, 4, 5]
					}

				Если лишних параметров не будет, то в переменную rest запишется пустой массив:
					func(1, 2);

					function func(a, b, ...rest) {
						console.log(a);    // выведет 1
						console.log(b);    // выведет 2
						console.log(rest); // выведет []
					}

				В функции вообще может не быть параметров, но при этом в нее можно добавить rest. В этом случае функцию 
				можно будет вызвать с любым количеством параметров и все они будут попадать в массив rest:	
					function func(...rest) {
						console.log(rest);
					}

		Функция, находящая сумму чисел с помощью операторов rest и spread в JavaScript:

			Давайте напишем функцию, которая будет принимать параметрами произвольное количество чисел и 
			возвращать их сумму.

			Вот примеры работы нашей функции:
				console.log( func(1, 2, 3)       ); // выведет 6
				console.log( func(1, 2, 3, 4)    ); // выведет 10
				console.log( func(1, 2, 3, 4, 5) ); // выведет 15

			Для начала давайте сделаем так, чтобы все переданные параметрами числа попадали в массив:
				function func(...nums) {
					console.log(nums);
				}

				func(1, 2, 3); // выведет [1, 2, 3]

			А теперь запустим цикл по переданному массиву и найдем сумму переданных чисел:
				function func(...nums) {
					let sum = 0;
					
					for (let num of nums) {
						sum += num;
					}
					
					return sum;
				}

				let result = func(1, 2, 3);
				console.log(result); // выведет 6

		Функция, сливающая массивы в двухмерный в JavaScript:

				Давайте сделаем функию uniнe, которая параметрами будет принимать произвольное количество массивов и 
				сливать их в один двухмерный.

				Вот пример работы описанной функции:
					let result = unite([1, 2, 3], [4, 5, 6], [7, 8, 9]);
					console.log(result); // выведет [ [1, 2, 3,] [4, 5, 6], [7, 8, 9] ] 

				Не смотря достаточную сложность функции, ее реализация с помощью оператора rest будет очень лаконичной:
					function unite(...arrs) {
						return arrs;
					}

		Функция, сливающая массивы в один в JavaScript:

			Давайте теперь реализуем функцию merge, параметрами принимающую произвольное количество массивов и сливающую их 
			элемементы в один массив.

			Вот пример работы нашей функции:
				let result = merge([1, 2, 3], [4, 5, 6], [7, 8, 9]);
				console.log(result); // выведет [1, 2, 3, 4, 5, 6, 7, 8, 9]

			Приступим к реализации. Давайте для начала получим переданные массивы в виде одного двухмерного:
				merge([1, 2, 3], [4, 5, 6], [7, 8, 9]);

				function merge(...arrs){
					console.log(arrs); // выведет  [ [1, 2, 3,] [4, 5, 6], [7, 8, 9] ]
				}

			Давайте теперь сольем этот двухмерный массив в одномерный. Используем для этого метод concat и оператор 
			spread:
				let arrs   = [ [1, 2, 3,], [4, 5, 6], [7, 8, 9] ];

				let result = [].concat(...arrs);
				console.log(result); // выведет [1, 2, 3, 4, 5, 6, 7, 8, 9]

			Давайте добавим в этот код нашу функцию merge:
				function merge(...arrs) {
					return [].concat(...arrs);
				}

				let result = merge([1, 2, 3], [4, 5, 6], [7, 8, 9]);
				console.log(result); // выведет [1, 2, 3, 4, 5, 6, 7, 8, 9]

			Как вы видите, эта функция также получилась очень лаконичной.

	ОБЪЕКТЫ:

		Объекты в JavaScript:

			В JavaScript есть специальные структуры данных, которые называются объектами (в другиъ языках программирования они называются
			ассоциативными массивами или хешами).
			
			Объекты создаются с помощью фигурных скобок {}, внутри которых пишутся элементы этого объекта в формате ключ: значение.

			Давайте создадим пустой объект:
				let obj = {};

			А теперь создадим объект с данными:
				let obj = {1: 'a', 2: 'b', 3: 'c'};

			Выведем элемент объекта по его ключу:
				console.log(obj[1]); // выведет 'a' 

		Вывод всего объекта в JavaScript:

			Содержимое всего объекта нельзя нормально посмотреть через функцию alert: 
				let obj = {1: 'a', 2: 'b', 3: 'c'};
				alert(obj); // выведет [Object object]

			Чтобы посмотреть содержимое всего объекта, нужно вывести его в консоль:
				let obj = {1: 'a', 2: 'b', 3: 'c'};
				console.log(obj); // выведет сам объект

		Строковые ключи объектов в JavaScript:
			
			Ключами объектов могут быть строки:
				let obj = {'a': 1, 'b': 2, 'c': 3};

			При этом ключи-строки принято в кавычки не брать:
				let obj = {a: 1, b: 2, c: 3};

			Давайте выведем элемент нашего объекта по ключу:
				console.log(obj['a']); // выведет 1

		Свойтсва объектов в JavaScript:

			Существует альтернативный способ обращения к элементам объекта. В этом способе мы после имени объекта ставим точку 
			и пишем имя ключа. В этом случае ключ называется свойством объекта. Посмотрим как это делается.
			Пусть у нас есть следующий объект:
				let obj = {a: 1, b: 2, c: 3};

			Выведем на экран значение его свойства:
				console.log(obj.a); // выведет 1	 

		Ограничения на ключи объектов в JavaScript:

			Мы можем писать без кавычек на все ключи объектов, а только те, которые удовлетворяют следующим ограничениям: они не могут начинаться с цифры
			и не могут содержать внутри себя дефис, пробел и тому подобные вещи.

			Если строка нарушает ограничение, то ее нужно брать в кавычки. В следующем примере в часть ключей не удовлетворяет условиям и поэтому
			стоят в кавычках:
				let obj = {'1key': 'a', 'key-2': 'b', key3: 'c'};

			К таким ключам можно обращаться только через квадратные скобки:
				console.log(obj['1key']);
				console.log(obj['key-2']);

			Также обращение к таким именам через свойство объекта приведет к ошибке:
				console.log(obj.1key);
				console.log(obj.key-2);

			А вот третий ключ - допустимый, и к нему мы можем обращаться обоими способами:
				console.log(obj['key3']);
				console.log(obj.key3);

		Изменение элементов объектов в JavaScript:

			Элементы объектов можно изменять, обращаясь к ним по ключам. Давайте посмотрим, как это делается.
			Пусть у нас есть следующий объект:
				let obj = {a: 1, b: 2, c: 3};

			Поменяем значение этого элемента:
				obj['a'] = '!';

			Воспользуемся обращением через свойство:
				obj.b = '!';

			Проверим изменился ли объект:
				console.log(obj);

		Добавление элементов в объекты в JavaScript:

			В объекты можно добавлять новые элементы, записывая их в нужные ключи. Давайте посмотрим, как это делается. 
			Пусть у нас есть следующий объект:
				let obj = {};

			Добавим в него новые элементы:
				obj['a'] = 1;
				obj['b'] = 2;
				obj['c'] = 3;

			Можно воспользоваться альтернативным синтаксисом:
				obj.a = 1;
				obj.b = 2;
				obj.c = 3;

			Проверим содержимое объекта:
				console.log(obj);

		Неупорядоченность объектов в JavaScript:

			Как мы уже знаем, в массивах элементы располагаются в строгом порядке, вдь позиция каждого элемента определяет его ключ. В 
			объектах же мы сами назначили ключи, поэтому порядок следования элементов не имеет значения. То есть массивы являются упорядоченными списками, 
			а объекты - нет.
			
			Для примера рассмотрим вот такой объект:
				let obj = {1: 'a', 2: 'b', 3: 'c'};

				console.log(obj[1]); // выведет 'a'
				console.log(obj[2]); // выведет 'b'
				console.log(obj[3]); // выведет 'c'

			Если переставить элементы нашего объекта в произвольном порядке (конечно же, вместе с их ключами), то ничего от этого 
			в работе нашего скрипта не изменится:
				let obj = {3: 'c', 1: 'a', 2: 'b'};

				console.log(obj[1]); // выведет 'a'
				console.log(obj[2]); // выведет 'b'
				console.log(obj[3]); // выведет 'c'  

			Кроме того, числовые ключи не обязательно должны иметь все значения без дырок, подобно массиву. У нас могут быть произвольные числа, 
			и это не будет приводить ни к каким проблемам (подобно разреженности у массивов). Поэтому следующий объект корректный:
				let obj = {7: 'a', 50: 'b', 23: 'c'};

		Массив ключей объекта в JavaScript:

			Можно получить массив ключей объекта. Давайте посмотрим, как это делается. Пусть у нас есть следующий объект:
				let obj = {a: 1, b: 2, c: 3};

			Получим массив его ключей:
				let keys = Object.keys(obj);

			Выведем этот массив в консоль:
				console.log(keys);

		Длина объекта в JavaScript:

			У объектов нет свойства length, позволяющего найти их длину. Давайте убедимся в этом. Пусть у нас есть следующий объект:
				let obj = {a: 1, b: 2, c: 3};

			Попробуем узнать количество его элементов:
				console.log(obj.length); // выведет undefined

			Решим задачу обходным путем - получим массив ключей объекта и найдем его длину:
				console.log(Object.keys(obj).length); // выведет 3

		Ключи объектов из переменных в JavaScript:

			Ключи объектов могут храниться в переменных. Посмотрим на примере. Пусть у нас есть слеюующий объект:
				let obj = {a: 1, b: 2, c: 3};

			Пусть в переменной хранится ключ:
				let key = 'a';

			Выведем элемент объекта по ключу:
				console.log(obj[key]); // выведет 1

		Ошибка обращения к элементу по ключу в JavaScript:

			При обращении к элементу объекта через квадратные скобки имена ключей брать в кавычки, а имена переменных - 
			нет. Не понимание этого часто может приводить к ошибкам. Поэтому давайте еще раз обсудим правила обращения.

			В следующем коде мы из объекта получаем элемент с ключом 'key':
				console.log(obj['key']);

			А в следующем коде мы из объекта получаем элемент с ключом, имя которого хранится в переменной key:
				console.log(obj[key])

		Ошибка обращения к свойству объекта в JavaScript:

			При обращении к свойству объекта имя этого свойства не может храниться в переменной. Давайте посмотрим
			почему. Пусть у нас дан вот такой объект:
				let obj = {a: 1, b: 2, c: 3};

			Пусть в переменной хранится имя свойства, значение которого мы хотим получить:
				let key = 'a';

			Попробуем обратиться к свойсву объекта, используя эту переменную:
				console.log(obj.key); // undefined

			Приведенный код не будет работать, так как фактически мы ищем свойство с именем 'key', а не свойство 
			чье имя хранится в переменной key. То есть фактически наш код эквивалентен следующему:
				console.log(obj['key']);

			Единственным способом обратиться к элементу по ключу из переменной является запись этой переменной в квадратных скобках:
				console.log(obj[key]);

		Вычисляемые свойства в JavaScript:

			При объявлении объекта имена его свойств могут браться из переменных. Такие свойства Такие свойства называются 
			вычисляемыми. Давайте посмотрим, как это делается. Пусть у нас есть следующий объект:
				let obj = {
					a: 1,
					b: 2,
					c: 3
				}; 

			Пусть имя некоторого свойства хранится в переменной:
				let key = 'a';

			Давайте сделаем так, чтобы вместо имени свойства взялось значение из нашей переменной. Для этого переменную следует взять в квадратные скобки:
				let obj = {
					[key]: 1,
					b: 2,
					c: 3
				};
				
			При объявлении вычисляемых свойств можно выполнять некоторый код. Пример:
				let obj = {
					[key + '1']: 1,
					[key + '2']: 2,
					[key + '3']: 3
				};

		Типизация объектов в JavaScript:

			Объекты имеют свой тип данных, который называется 'object'. Проверим с помощью оператора typeof:
				console.log(typeof {}); // выведет 'object'

		Массивы как объекты в JavaScript:

			Массивы на самом деле являются частным случаем объектов. В этом можно убедиться, если проверить массив через 
			оператор typeof:
				console.log(typeof []); // выведет 'object'

		Отличаем массивы от объектов в JavaScript:

			Как было указано выше, оператор typeof не позволяет различать массивы и объекты. Иногда, однако, это 
			необходимо сделать, На помощь придет функция Array.isArray():
				console.log( Array.isArray([]) ); // выведет true
				console.log( Array.isArray({}) ); // выведет false

		Объекты и примитивы в JavaScript:

			Объекты (в том числе и массивы, как вы уже знаете) считаются сложными типами данных. Строки, числа, лошические 
			значения считаются простыми, или примитивными типами данныхэ Их часто так и называют - примитивы, подразумевая 
			все то, что не является объектом. 

			В JavaScript семь примитивных типов данных: string, number, boolean, null, undefined, symbol, bigint. 
			Обязательно нужно запомнить название и их количество - это часто спрашивают на собеседованиях. 

		Передача объектов по ссылке в JavaScript:

			Массивы и объекты несколько отличаются от остальных примитивных типов данных. Отличие в том, что переменная, 
			хранящая массив, на самом деле не содержит его, а просто ссылается на него. 

			На практике это означает, что при записи объекта в другую переменную, обе переменных будут ссылаться на один и тот же объект. 
			Давайте попробуем на практике. Пусть у нас есть следующий объект:
				let obj1 = {a: 1, b: 2, c: 3};

			Присвоим его из одной переменной в другую:
				let obj2 = obj1;

			Изменим одну из переменных:
				obj2.a = '!';

			В результате изменения будут видны в другой переменной:
				console.log(obj1); // {a: '!', b: 2, c: 3}

		Константы с массивами или объектами в JavaScript:

			Константы, содержащие массивы или объекты, раюотают интересным образом. JavaScript не разрешает изменять
			значения этих констант, но изменять свойства объектов и значения элементов массивов - можно.

			Давайте посмотрим на примерах. Пусть у нас дан вот такой объект:
				const obj = {a: 1, b: 2, c: 3};

			Давайте попробуем записать в него что то другое:
				obj = 123; // ошибка

			Давайте попробуем записать в константу другой объект:
				obj = {x: 1, y: 2, z: 3}; // ошибка

			Однако, если мы попробуем изменить свойство объекта, то это сработает:
				obj.a = '+'; // работает!

	УСЛОВИЯ:

		Конструкция if-else в JavaScript:

			Сейчас мы изучим специальную конструкцию if-else, которая позволяет выполнять некоторый код в зависимости 
			от выполнения какого-либо условия. 

			С помощью конструкции if-else мы можем задать программе, к примеру вопрос "Больше ли переменная a, чем переменная b",
			и в зависимости от ответа выполнить или один код, или другой.

			Синтаксис конструкции выглядит так:
				if (операция сравнения) {
					/*
						расположенный здесь код выполниться,
						если результат операция сравнения верный
					*/
				} else {
					/*
						расположенный здесь код выполниться,
						если результат операция сравнения неверный
					*/
				}

			Для операции сравнения в JavaScript существует много операторов. Давайте приступим к их изучению.

		Операторы больше и меньше в JavaScript:

			Для проверки того, которое из значений больше, а которое меньше, используя операторы больше >, 
			больше или равно >=, меньше <, меньше или равно <=. 

			Изучим их работу на практическом примере. Пусть у нас есть переменная test с каким-то значением: 
				let test = 1;

			Давайте проверим, значение этой переменной больше нуля или нет:
				let test = 1;

				if (test > 0) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}  		

			А тепер поменяем значение переменной на отрицательное:
				let test = -1;

				if (test > 0) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

			Пусть теперь значение переменной равно 0. В этом случае мы попадаем в блок else, так как в нашем условии написано, что 
			переменная test должна быть строго больше нуля:
				let test = 0;

				if (test > 0) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

			Давайте поменяем условние на больше или равно:
				let test = 0;

				if (test >= 0) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

			А теперь на меньше:
				let test = 0;

				if (test < 0) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

			А теперь на меньше или равно:
				let test = 0;

				if (test <= 0) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

		Проверка на равенство в JavaScript:

			Для проверки двух значений на равенство используется оператор ==. Давайте для примера проверим, 
			что test переменная равна 0:
				let test = 0;

				if (test == 0) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

			Поменяем значение переменной так, чтобы условие не выполнялось:
				let test = 1;

				if (test == 0) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

		Проверка на неравенство в JavaScript:

			Оператор != проверяет на неравенство. Давайте для примера проверим, что переменная test не равна 0:
				let test = 1;

				if (test != 0) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

			Поменяем значение переменной:
				let test = 0;

				if (test != 0) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

		Сравнение переменных в JavaScript: 

			В примерах выше мы сравнивали переменную с каким-то числом. Но никто не запрещает нам сравнивать две переменные. 
			Смотрите пример: 
				let test1 = 1;
				let test2 = 2;

				if (test2 > test1) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				} 

		Равенство строк в JavaScript:

			При использовании конструкции if можно сравнивать и строки. Для примера пусть в переменной test хранится какая-то строка, 
			например 'abc':
				let test = 'abc';

			Давайте проверим, равно ли содержимое переменной test строке 'abc':
				let test = 'abc';

				if (test == 'abc') {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

		Равенство строк и чисел в JavaScript:

			Как вы знаете, число в кавычках представляет собой строку. Например '3' - это строка. Однако при сравнении 
			таких строк с числами JavaScript считает, что строка в кавычках равна такому же числу. 

			Давайте для примера сравним строку '3' и число 3:
				if ('3' == 3) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

		Равенство по значению и типу в JavaScript:

			Пусть вы хотите сравнивать так, чтобы число в кавычках не было равно такому же числу без кавычек. Говоря другими словами, вы хотите сравнивать так, 
			чтобы сравнение было не только по значению но и по типу данных. Для этого вместо оператора == следует использовать оператор ===. В следующем примере 
			при сравнении строки '3' и числа 3 условие будет ложным, так как переменные, хотя и равно по значению, не равны по типу:
				if ('3' === 3) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

			А вот при сравнении двух строк '3' значение будет истинно:
				if ('3' === '3') {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

			Так же, как и при сравнении чисел:
				if (3 === 3) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

			Разница между оператором == и оператором === появляется именно тогда, когда значения одинаковые, но разный тип данных. В остальных случаях 
			эти операторы работют одинаково. К примеру, при сравнении разных чисел, конечно же выведется '---':
				if (2 === 3) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

		Неравенство по значеню и типу в JavaScript:

			Кроме оператора != существует также оператор !==, учитывающий тип при сравнении. Давайте рассмотрим 
			различия между ними на примерах. 

			Пусть с помощью оператора != сравниваются два числа 3. Данный оператор сравнивает значения на то, что они НЕ равны. 
			Так как наши значения как раз-таки равны, то условие будет ложным:
				if (3 != 3) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

			Пусть теперь одно из наших значений будет в кавычках. В этом случае оператор != все равно посчитает их равными (так как совпадает значение, 
			а тип не важен для данного оператора) и опять условие будет ложным: 
				if ('3' != 3) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

			Давайте теперь сравним два числа 3 с помощью оператора !==. Он также посчитает их равными:
				if (3 !== 3) {
					console.log('+++');
				} else {
					console.log('---'); // сработает это
				}

			А вот если теперь одну из троек взять в кавычки, то оператор !== посчитает наши тройки неравными, так как, 
			хотя значения их и совпадают, но у них разный тип: 
				if ('3' !== 3) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

		Логическое И в JavaScript:
			
			Можно группировать операции сравнения с помощью оператора &&, представляющего собой логическое И. 
			В следующем примере, если переменная num больше нуля и одновременно меньше 10, только тогда выведется '+++':
				let num = 3;

				if (num > 0 && num < 10) {
					console.log('+++');
				} else {
					console.log('---');
				}

			Условия могут налагаться не на одну переменную, а на разные. В следующем примере, елси переменная num1 равна 2
			и одновременно переменная num2 равна 3, только тогда условие будет истинно:
				let num1 = 2;
				let num2 = 3;

				if (num1 == 2 && num2 == 3) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Логическое ИЛИ в JavaScript:

			Оператор || представляет собой логическое ИЛИ и требует выполнения хотя бы одного условия. 
			
			В следующем примере, если переменная num1 больше 0 или переменная num2 больше 0, то условие 
			будет истинно (достаточно выполнерия хотя бы одного из условий):
				let num1 = 10;
				let num2 = -5;

				if (num1 > 0 || num2 > 0) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

		Приоритет логических операторов в JavaScript:

			Операция && имеет приоритет над ||. В следующем примере условие будет истинно, если переменная num от 0 до 5 ИЛИ от до 20:
				let num = 3;

				if (num > 0 && num < 5 || num > 10 && num < 20) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Группировка условий в JavaScript:

			Хотя операция && и имеет приоритет над ||, часто удобнее использоваться группирующие круглые скобки, чтобы явно показать приоритет операций:
				let num = 3;

				if ( (num > 0 && num < 5) || (num > 10 && num < 20) ) {
					console.log('+++');
				} else {
					console.log('---');
				}

			Конечно же, группировка может быть использована и в том случае, когда вам нужен свой приоритет операций, а не тот,
			который получается по умолчанию:
				let num1 = 3;
				let num2 = 5;

				if ( num1 > 0 && (num2 == 3 || num2 == 5) ) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Инвертирование логических выражений в JavaScript:

			Рассмотрим следующий код:
				if (num > 0 && num < 5) {
					console.log('+++');
				} else {
					console.log('---');
				}

			Сейчас наше условие такое: num должно быть от 0 до 5. Давайте инвертируем это условие, то есть превратим его в его противоположность. 
			Противоположное условие получится таким: num должно быть меньше или равно 0 ИЛИ больше или равно 5:
				if (num <= 0 || num >= 5) {
					console.log('+++');
				} else {
					console.log('---');
				}

			Как вы видите, чтобы инвертировать условие, приходится несколько задуматься. Гораздо проще будет использовать оператор !,
			представляющий собой логическое НЕ. С помощью этого оператора нам достаточно поставить знак ! перед изначальным условием - и оно 
			инвертируется само:
				if ( !(num > 0 && num < 5) ) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Условие с булевыми значениями в JavaScript:

			Пусть у нас есть какая-то переменная, которая может принимать значения true или false:
				let test = true;

			Напишем if, проверяющий нашу переменную на значение true:
				let test = true;

				if (test === true) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Сравнение значений с булевым типом в JavaScript:

			В предыдущем примере мы использовали для сравнения оператор ===. В этом случае нааша переменная
			сравнивалась на равенство true как по значению, так и по типу. 

			Для такого сравнения можно использовать и оператор ==. Если в переменной test всегда будет одно из значений true или false 
			, то ничего не изменится:
				let test = true; // тут пишем или true, или false

				if (test == true) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Сокращенная форма проверки на истину в JavaScript:

			Пусть мы хотим узнать, равна ли переменная test значению true. В этом случае конструкцию if можно записать так:
				let test = true;

				if (test == true) {
					console.log('+++');
				} else {
					console.log('---');
				}

			При программировании такие проверки требуются очень часто, поэтому для них существует более изящная сокращенная форма:
			вместо if(test == test) можно написать просто if(test). 

			Перепишем наш код в сокращеннной форме:
				let test = true;

				if (test) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Сокращенная форма проверки на ложь в JavaScript:

			Пусть теперь мы хотим проверить значение переменной на ложь. Это можно сделать 
			следующим образом:
				let test = true;

				if (test === false) {
					console.log('+++');
				} else {
					console.log('---');
				}

			Можно также написать эквивалентный код с отрицанием:
				let test = true;

				if (test !== true) {
					console.log('+++');
				} else {
					console.log('---');
				}

			Приведенный код может быть переписан в сокращенной форме следущим образом:
				let test = true;

				if (!test) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Общая сокращенная форма проверки в JavaScript:

			Сокращенная форма проверки работает и для других типов данных. В этом случае эти данные сначала перобразуются 
			к булеву типу, а потом сравниваются с true. Пример:
				let test = 3;

				if (test) {
					console.log('+++'); // сработает это
				} else {
					console.log('---');
				}

			Фактически приведенный код эквивалентен этому:
				let test = 3;

				if (Boolean(test) === true) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Сложные условия в сокращенной форме в JavaScript:

			В сокращенной форме можно использовать операторы && и ||. Прмиер:
				let test1 = true;
				let test2 = true;

				if (test1 && test2) {
					console.log('+++');
				} else {
					console.log('---');
				}

			Еще пример:
				let test1 = true;
				let test2 = true;

				if (test1 || test2) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Необязательность конструкции else в JavaScript:

			Конструкция else не является обязательной. В следующем примере в консоль выведется сообщение только в том случае,
			если значение переменной равно 1. В противоположном случае ничего не случится:
				let test = 1;

				if (test == 1) {
					console.log('+++');
				}

		Необязательность фигурных скобок в JavaScript:

			В случае, если в фигурных скобках if или else будет только одно выражение, можно эти фигурные скобки не писать. 
			Пусть, к примеру, дан вот такой код со всеми скобками:
				if (test === 0) {
					console.log('+++');
				} else {
					console.log('---');
				}

			Можно сократить его вот так:
				if (test === 0) console.log('+++'); else console.log('---');

			Или так:
				if (test === 0) {
					console.log('+++');
				} else console.log('---');

			Можно также убрать все скобки, но оформить все не в линию, а вот так:
				if (test === 0)
					console.log('+++');
				else
					console.log('--');

		Проблема необязательности фигурных скобок в if-else:

			Не смотря на то, что JavaScript допускает показанные выше сокращения с фигурными скобками, я в общем-то не рекомендую так делать,
			так как это рассадник трудноуловимых ошибок. Пусть к примеру есть следующий код:
				let test = 3;

				if (test > 0)
					console.log(test);

			Пусть теперь мы решили в том случае, если условие выполняется, выводить еще и второе сообщение с текстом '+++':
				let test = 3;

				if (test > 0)
					console.log(test);
					console.log('+++');

			Однако, без фигурных скобок внутри условия находится только первое сообщение. Его перая строка будет срабатывать при верном условии, а вторая - всегда. 

			Фактически наш код эквивалентен такому:
				let test = 3;

				if (test > 0) {
					console.log(test);
				}

				console.log('+++'); // эта строка оказалась снаружи условия

			А мы бы хотели такой код:
				let test = 3;

				if (test > 0) {
					console.log(test);
					console.log('+++'); // эта строка внутри условия
				}

			Именно поэтому рекомендуется всегда выполнять расстановку фигурных скобок, дабы не попадать в такого рода ошибки.
			
		Конструкция else if в JavaScript:

			Конструкция else if позволяет задавать условия в блоке else. Посмотрим на примере:
				let num = 1;

				if (num == 1) {
					console.log('value1');
				} else if (num == 2) {
					console.log('value2');
				} else if (num == 3) {
					console.log('value3');
				}
			
			Преимуществом использования else if вместо нескольких ифов является возиожность отловить ситуацию, когда значение переменной num не подходит 
			ни под одно из условий:
				let num = 1;

				if (num == 1) {
					console.log('value1');
				} else if (num == 2) {
					console.log('value2');
				} else if (num == 3) {
					console.log('value3');
				} else {
					console.log('неверное значение переменной num');
				}

		Вложенные конструкции if-else в JavaScript:

			Конструкции if-else можно вкладывать друг в друга проивольным образом. Пример:
				let num = 3;

				if (num >= 0) {
					if (num <= 5) {
						console.log('меньше или равно 5');
					} else {
						console.log('больше 5');
					}
				} else {
					console.log('меньше нуля');
				}

		Конструкция switch-case в JavaScript:

			С помощью конструкции switch-case можно выполнять различный код, в зависимости от значения переменной. Вот синтаксис этой конструкции:
				switch (переменная) {
					case 'значение1':
						/*
							здесь код, который выполнится в случае,
							если переменная имеет значение1
						*/
					break;
					case 'значение2':
						/*
							здесь код, который выполнится в случае,
							если переменная имеет значение2
						*/
					break;
					case 'значение3':
						/*
							здесь код, который выполнится в случае,
							если переменная имеет значение3
						*/
					break;
					default:
						/*
							здесь код, который выполнится в случае,
							если не совпала ни с одним значением
						*/
					break;
				}

			Напишем пример кода с конструкцией switch-case:
				let num = 1;

				switch (num) {
					case 1:
						console.log('value1');
					break;
					case 2:
						console.log('value2');
					break;
					case 3:
						console.log('value3');
					break;
					default:
						console.log('incorrect value');
					break;
				}

		Необязательность break в конструкции switch-case в JavaScript:

			Команда break в конструкции switch-case не является обязательной. При отстуствии break после выполнения 
			задуманного case, выполнятся и case ниже него. 

			Посмотрим на примере:
				let num = 1; // пусть здесь число 1

				switch (num) {
					case 1:
						console.log(1); // сработает это
					case 2:
						console.log(2); // сработает и это
					case 3:
						console.log(3); // сработает и это
				}

			Изменим значение переменной:
				let num = 2; // пусть здесь число 2

				switch (num) {
					case 1:
						console.log(1);
					case 2:
						console.log(2); // сработает это
					case 3:
						console.log(3); // сработает и это
				}

			Изменим значение переменной:
				let num = 3; // пусть здесь число 3

				switch (num) {
					case 1:
						console.log(1);
					case 2:
						console.log(2);
					case 3:
						console.log(3); // сработает это
				}

			Иногда такую особенность используют, при решении задач. Смотрите пример:
				let num = 1;
				let res;

				switch (num) {
					case 1:
					case 2:
						res = 'a';
					break;
					case 3:
						res = 'b';
					break;
				}

				console.log(res);

			Очевиднее однако решить такую задачу через if:
				let num = 1;
				let res;

				if (num == 1 || num == 2) {
					res = 'a';
				}

				if (num == 3) {
					res = 'b';
				}

				console.log(res);	

		Тернарный оператор в JavaScript:

			В данном уроке будет расмотрен специальный тернарный оператор, представляющий собой сокращенный вариант конструкции if-else.
			Его синтаксис выглядит следующим образом:
				let переменная = условие ? значение1 : значение2;

			Оператор работает так, если условие истинно, то возвращается значение1, в противном случае - значение2.
			Сделаем пример кода с использованием данного оператора:
				let age = 17;
				let adult = age >= 18 ? true: false;
				console.log(adult);

			Тернарный оператор следует использовать только в самых простых случаях, так как его использование затрудняет понимание кода.

		Логические операции в JavaScript:

			Операторы сравнения можно использовать вне конструкции if. Пример:
				console.log(1 == 1); // выведет true
				console.log(1 == 2); // выведет false

			Можно сравнивать переменные:
				let a = 1;
				let b = 2;

				console.log(a == b);

			Можно не выводить результат сразу в консоль, а присвоить его какой-нибудь переменной:
				let a = 1;
				let b = 2;

				let result = a == b;
				console.log(result);	

	ФУНКЦИИ:

		Основы работы с пользовательскими функциями в JavaScript:

			Сейчас мы с вами научимся создавать свои функции, которые затем можно будет использовать подобно стандартным функциям и методам
			JavaScript. Давайте рассмотрим синтаксис для создания своей функции.

			Функция создается с помощью команды function. Далее через пробел следует имя функции, круглые скобки, а затем фигурные скобки,
			в которых пишется какой-то код:

			function () {
				// какой-то код
			}

			Давайте рассмотрим на каком нибуль примере. Сделаем функцию с именем func, которая при своем вызове будет выводить в консоль какой-то 
			знак:
				function func() {
					console.log('!');
				}

			Давайте теперь вызовем нашу функцию. Для этого необходимо написать ее имя и круглые скобки:
				function func() {
					console.log('!');
				}

				// Вызываем нашу функцию:
				func(); // выведет '!'

			Можно вызвать нашу функцию несколько раз - в этом случае каждый вызов функции будет выдавать новый алерт:
				function func() {
					console.log('!');
				}

				func(); // выведет '!'
				func(); // выведет '!'
				func(); // выведет '!'

			Функции могут быть вызваны до места своего определения:
				func(); // выведет '!'

				function func() {
					console.log('!');
				}

		Параметры функций в JavaScript:

			Функции могу принимать праметрами данные. Для примера давайте сделаем функцию, которая параметром будет принимать число:
				function func(num) {
	
				}

			Давайте сделаем так, чтобы функция возводила переданное число в квадрат:
				function func(num) {
					console.log(num ** 2);
				}

			Проверим работу функции, вызвав ее с различными числами:
				func(2); // выведет 4
				func(3); // выведет 9

		Несколько параметров функций в JavaScript:

			Функция может принимать не один параметр, а несколько. В этом случае их нужно перечислить через запятую. Давайте для примера сделаем 
			фукнцию, параметром принимающую два числа и выводящую в консоль их сумму:
				function func(num1, num2) {
					console.log(num1 + num2);
				}			

			Проверим работу нашей функции:
				func(1, 2); // выведет 3

		Параметры-переменные функций в JavaScript:

			В параметры функции можно передавать переменные. Давайте посмотрим на примере. Пусть у нас есть следующая функция:
				function func(num) {
					console.log(num ** 2);
				} 

			Пусть у нас есть следующая переменная:
				let param = 2;

			Вызовем нашу функцию, передав ей параметром число из переменной:
				let param = 2;
				func(param);

		Необязательные параметры в JavaScript:

			Параметры функций можно делать необязательными. Для этого параметрам нужно задать значения по умолчанию. Пусть для примера 
			у нас есть следующая функция:
				function func(num) {
					console.log(num ** 2);
				}

			Давайте сделаем так, чтобы этот параметр по умолчанию имел значение 0:
				function func(num = 0) {
					console.log(num ** 2);
				}

			Проверим работу нашей функции с параметром:
				func(2); // выведет 4

			Проверим работу нашей функции без параметра:
				func(); // выведет 0

		Инструкции return:

			Пусть у нас есть функция, которая выводит в консоль квадрат переданного числа:
				function func(num) {
					console.log(num ** 2);
				}

			Пусть не хотим выводить значение в консоль, а записать в какую-нибудь переменную, вот так:
				let res = func(3); // в переменной res теперь 9

			Для этого в JavaScript существует специальная инструкция return, которая позволяет указать значение, которое возвращает функция. Под словом
			"возвращает" понимают то значение, которое запишется в переменную, если ей присвоить вызванную фукнцию. 

			Итак, давайте перепишем нашу функцию так, чтобы она не выводила результат в консоль, а выводила результат в переменную:
				function func(num) {
					return num ** 2;
				} 

			Вызовем теперь нашу функцию, записав ее ответ в переменную:
				let res = func(3); // в переменную запишется 9

			После того, как данные записаны в переменную, их можно, например, вывести в консоль:
				let res = func(3);
				console.log(res); // выведет 9

			А можно сначала как-то изменить эти данные, а затем вывести их в консоль:
				let res = func(3);
				res = res + 1;
				console.log(res); // выведет 10

			Можно сразу выполнять какие-то действия с результатом работы функции перед записью в переменную:
				let res = func(3) + 1;
				console.log(res); // выведет 10

			А можно не записывать результат в переменную, а сразу вывести его в консоль:
				console.log(func(3)); // выведет 9

			Можно вызвать функцию в одном выражении с различными параметрами:
				let res = func(2) + func(3);
				console.log(res); // выведет 13

		Последовательный вызов функций в JavaScript:

			Можно результат работы одной функции передать параметром в другую. В следующем примере мы сначала найдем квадрат числа 2, а затем 
			квадрат результата:
				function func(num) {
					return num ** 2;
				}

				let res = func(func(2));
				console.log(res); // выведет 16

			Функции конечно же, не обязательное должны быть одинаковыми. Пусть, например, у нас есть функция, возвращающая 
			квадрат числа, и функция, возвращающая куб числа:
				function square(num) {
					return num ** 2;
				}

				function cube(num) {
					return num ** 3;
				}

			Давайте с помощью этих функций возведем число 2 в квадрат, а затем результат этой операции возведем в куб:
				let res = cube(square(2));
				console.log(res);

			Пусть теперь у нас есть функция, возвращающая квадрат числа, и функция, находящая сумму двух чисел:
				function square(num) {
					return num ** 2;
				}

				function sum(num1, num2) {
					return num1 + num2;
				}

			Найдем с помощью этих функций сумму квадрата числа 2 и квадрата числа 3:
				let res = sum(square(2), square(3));
				console.log(res);

		Тонкое место return в JavaScript:

			После того как выполнится инструкция return - функция закончит свою работу и никакой код дальше не выполнится.
			Пример:
				function func(num) {
					return num ** 2;
					
					console.log('!'); // этот код никогда не выполнится
				}

				let res = func(3);

			Это не значит что в функции должен быть один return. Но выполнится только один из них. В следующем примере в зависимости 
			от значения параметра выполнится либо первый, либо второй return:
				function func(num) {
					if (num >= 0) {
						return '+++';
					} else {
						return '---';
					}
				}

				console.log(func( 3)); // выведет '+++'
				console.log(func(-3)); // выведет '---'

		Циклы и return в JavaScript:

			Пусть у нас есть функция, возрващающая сумму чисел от 1 до 5:
				function func() {
					let sum = 0;
					
					for (let i = 1; i <= 5; i++) {
						sum += i;
					}
					
					return sum;
				}

				let res = func();
				console.log(res); // выведет 15
				
			Пусть теперь мы расположим return внутри цикла, вот так:
				function func() {
					let sum = 0;
					
					for (let i = 1; i <= 5; i++) {
						sum += i;
						return sum;
					}
				}

				let res = func();
				console.log(res);

			В этом случае, цикл прокрутится лишь одну итерацию и произойдет автоматический выход из функции (ну и заодно из цикла). 
			А за одну итерацию цикла в переменной sum окажется лишь число 1, а не вся нужная сумма.

		Применение return в циклах в JavaScript:

			То, что return расположен внутри цикла, не всегда является ошибкой. В следующем примере сделана функция, которая определеяет,	
			сколько первых элементов массива нужно сложить, чтобы сумма стала больше или равна 10:
				function func(arr) {
					let sum = 0;
					
					for (let i = 0; i < arr.length; i++) {
						sum += arr[i];
						
						// Если сумма больше или равна 10:
						if (sum >= 10) {
							return i + 1; // выходим из цикла и из функции
						}
					}
				}

				let res = func([1, 2, 3, 4, 5]);
				console.log(res); 

			А в следующем примере сделана функция, которая вычисляет, сколько целых чисел, начиная с 1, нужно сложить, чтобы 
			результат был больше 100:
				function func() {
					let sum = 0;
					let i = 1;
					
					while (true) { // бесконечный цикл
						sum += i;
						
						if (sum >= 100) {
							return i; // цикл крутится пока не выйдет тут
						}
						
						i++;
					}
				}

				console.log( func() );

		Прием работы с return в JavaScript:

			Существуют некоторые приемы работы с return, упрощающие код. Рассмотрим, к примеру, следующий код:
				function func(num) {
					let res;
					
					if (num >= 0) {
						res = Math.sqrt(num);
					} else {
						res = 0;
					}
					
					return res;
				}

				console.log(func(3));

			Как вы видите, в данном коде в зависимости от условия в переменную res будет попадать либо одно, либо другое 
			значение. А последней строкой функции содержимое переменной res возвращается через return. 

			Давайте перепишем этот код в более сокращенной форме, избавившись от ненужной переменной res:
				function func(num) {
					if (num >= 0) {
						return Math.sqrt(num);
					} else {
						return 0;
					}
				}

				console.log(func(3));

		Флаги в функциях JavaScript:

			В функциях можно использовать флаги в неявном виде с помощью инструкции return. Давайте посмотрим, 
			как это делается. Пусть у нас есть следующая функция, проверяющая, что все элементы массива положительные числа:
				function isPositive(arr) {
					let flag = true;
					
					for (let elem of arr) {
						if (elem < 0) {
							flag = false;
						}
					}
					
					return flag;
				}

			Давайте перепишем код функции с помощью неявного использования флагов:
				function isPositive(arr) {
					for (let elem of arr) {
						if (elem < 0) {
							return false;
						}
					}
					
					return true;
				}

			Как это работает: если в массиве найдется нужный элемент - мы выйдем из функции (и из цикла тоже) с помощью return.
			Но если в массиве не найдется нужный элемент - выхода из функции не произойдет и выполнение дойдет до команды return true.
			И получится, что функция вернет true как знак того, что в массиве все элементы положительные. 
				
		Логиеческие операторы без if в функциях JavaScript:

			Пусть у нас есть функция с ифом. Вот она:
				function func(a, b) {
					if (a > b) {
						return true;
					} else {
						return false;
					}
				}

			Как вы уже знаете из предудыщих уроков, конструкции if, возвращающие булевы значения, можно переписывать в сокращенной форме.
			Давайте сделаем это:
				function func(a, b) {
					return a > b;
				}  

		Советы по созданию функций в JavaScript:

			1. Имена функций должны быть глаголами;
			
			2. Имя каждой функции должно точно означать то, что функция делает;

			3. Функция должна делать только то, что явно подразумевается ее названием, и не делать другого;
			
			4. Каждая функция должна выполнять только одно действие;

			5. Используйте внутри функции вспомогательные функции;

			6. Код функции лечше не делать больше 10-15 строк;

			7. Длинные функции лучше разбивать на ряд вспомогательных;

			8. Используйте общепринятые префиксы в именах функций: show, get, set, calc, create, change, check;

			9. Выносите дублирующийся код в функции. 

		Глобальные переменные в функциях JavaScript:

			В JavaScript (в других языках чаще всего не так) переменные, определенные снаружи функции, будут видны внутри 
			этой функции. Такие переменные называются глобальными. Помотрим на примере:
				let num = 1; // переменная снаружи функции

				function func() {
					console.log(num); // переменная num видна внутри функции
				}

				func(); // выведет 1

			На самом деле переменная должна быть определена не перед определением функции, а перед ее вызовом:
				function func() {
					console.log(num);
				}

				let num = 1; // переменная снаружи функции
				func();      // выведет 1

			Если менять значение переменной и после этого каждый раз вызывать функцию - каждый вызов ее будет менять результат:
				function func() {
					console.log(num);
				}

				let num; // объявим переменную

				num = 1; // задаем значение 1
				func();  // выведет 1

				num = 2; // задаем значение 2
				func();  // выведет 2

			Если у нас несколько функций, то глобальная переменная будет доступна в каждой из этих функций:
				function func1() {
					console.log(num);
				}

				function func2() {
					console.log(num);
				}

				let num = 1;

				func1(); // выведет 1
				func2(); // выведет 1

			Если в одной из функций произойдут изменения с глобальной переменной, то эта переменная поменяется во всех функциях, 
			использующих эту переменную:
				function func1() {
					console.log(num);
					num++; // меняем глобальную переменную
				}

				function func2() {
					console.log(num);
				}

				let num = 1;

				func1(); // выведет 1
				func2(); // выведет 2

			Так как любая из функций легко может поменять глобальную переменную, то их использование представляет собой рассадник 
			трудноуловимых ошибок. По этой причине использование глобальных переменных в скрипте нужно сводить к минимуму. Желательно, 
			чтобы их вообще не было или было самое минимальное количество. 

		Изменение глобальных переменных в JavaScript:

			Учтите, что глобальная переменная будет меняться только в момент вызова функции. 
			Если вызова функции нет - переменная не изменится:
				let num = 1;

				function func() {
					num = 2; // не написан let - меняем внешнюю переменную
					console.log(num);
				}
				// func(); - закомментировали вызов функции

				console.log(num); // выведет 1 - переменная не поменялась

			А сейчас продемонстрируем кодом то, что глобальная переменная поменяется только после вызова функции:
				let num = 1;

				function func() {
					num = 2;
				}

				console.log(num); // выведет 1
				func(); // меняем переменную
				console.log(num); // выведет 2

		Глобальные переменные и параметры функции в JavaScript:

			Пусть у нас есть функция, принимающая параметром число:
				function func(localNum) {
					console.log(localNum);
				}

			Пусть снаружи есть переменная num:
				function func(localNum) {
					console.log(localNum);
				}

				let num = 1; // внешняя глобальная переменная

			Давайте вызовем нашу функцию, передав ей параметром переменную num:
				function func(localNum) {
					console.log(localNum);
				}

				let num = 1;
				func(num); // вызываем функцию с параметром, выведет 1

			Получится, что внутри функции будет доступна как переменная localNum (параметр функции), так и переменная 
			num (как внешняя переменная):
				function func(localNum) {
					console.log(num); // выведет 1
					console.log(localNum); // выведет 1
				}

				let num = 1;
				func(num); 

			Сама переменная localNum будет локальной переменной функции и не будет доступна извне:
				function func(localNum) {
					
				}

				let num = 1;
				func(num); // вызываем функцию с параметром
				console.log(localNum); // выдаст ошибку

			Так как переменная localNum - локальная, то никакие изменения с ней ничего не поменяют снаружи:
				function func(localNum) {
					localNum = 2; // ничего не меняет снаружи
				}

				let num = 1;
				func(num);

			Если же поменять внутри переменную num (глобальную), то изменения появятся и снаружи:
				function func(localNum) {
					num = 2;
				}

				let num = 1;
				func(num);
				console.log(num); // выведет 2

			Однако, если внутри функции объявить переменную num через let, то мы создадим таким образом локальную переменную num, 
			никак не влияющую на внешнюю переменную:
				function func(localNum) {
					let num = 2; // объявим через let
				}

				let num = 1;
				func(num);
				console.log(num); // выведет 1 - ничего не поменялось

		Локальные переменнвые в функциях в JavaScript:

			Переменные, определенные внутри функции, называются локальными. В отличии от глобальных переменных, локальные переменные 
			видны только внутри функции, и не видны снаружи:
				function func() {
					let num = 5; // локальная переменная
					console.log(num);
				}

				console.log(num); // ничего не выведет, а выдаст ошибку в консоль

		Одинаковые имена переменных в функциях в JavaScript:

			Пусть и снаружи функции и внутри функции есть переменная num. В этом случае любые изменения с локальной переменной num 
			никак не влияют на глобальную переменную num:
				let num = 1; // глобальная переменная

				function func() {
					let num = 2; // локальная переменная
					console.log(num);
				}
				func(); // вызываем функцию, выведет 2

				console.log(num); // выведет 1 - глобальная переменная не поменялась

			Но, если мы забудем объявить локальную переменную через let то внутри функции не создастся локальная переменная num, 
			а просто изменится глобальная переменная:
				 let num = 1;

				function func() {
					num = 2; // забыли написать let - меняем внешнюю переменную
					console.log(num);
				}
				func(); // вызываем функцию, выведет 2

				console.log(num); // выведет 2 - переменная поменялась

			Тут может быть две ситуации: или мы действительно хотели поменят глобальную переменную (тогда все ок), или мы забыли let 
			и случайно поменяли глобальную переменную. 

			Второй случай является трудноуловимой ошибкой, ведущей к непредсказуемому поведению скрипта. Поэтому всегда, вводя новую переменную
			объявляйте ее через let.

		Совпадение имен с параметрами в JavaScript:

			Параметры функции являются локальными переменными внутри нее. Давайте назовем параметр функции таким же именем, 
			как и внешнюю глобальную переменную:
				function func(num) {
					console.log(num);
				}

				let num = 1;
				func(num);

			В данном случае у нас получится так, что снаружи функции будет переменная num и внутри функции будет переменная num. Но это 
			будут разные переменные: изменение переменной внутри функции будет приводить к изменению локальной переменной функции. А внешняя
			переменная функции будет недоступна и не сможет быть изменена никаким способом. Проверим:
				function func(num) {
					num = 2; // меняем локальную переменную
				}

				let num = 1;
				func(num);
				console.log(num); // выведет 1 - ничего не поменялось 

		Параметры-оюъекты в JavaScript:

			Объекты, в отличие от примитивов, передаются по ссылке. Это значит, что изменение объекта внутри функции приведет
			к тому, что он поменяется и снаружи функции. Смотрите пример:
				function func(arr) {
					arr[0] = '!';
				}

				let arr = [1, 2, 3];
				func(arr);
				console.log(arr); // выведет ['!', 2, 3]

		Исходный код функции и ее результат в JavaScript:

			В JavaScript можно написать имя функции без круглых скобок. В этом случае мы увидим не результат работы функции, 
			а ее исходный код.

			Давайте попробуем. Пусть у нас есть какая-то функция, например, такая:
				function func() {
					return '!';
				}

			Давайте вызовем эту функцию, написав ее имя и круглые скобки. В этом случае мы увидим результат работы функции:
				function func() {
					return '!';
				}

				console.log(func()); // выведет '!'

			А теперь давайте попробуем опустить после имени круглые скобки. В этом случае мы увидим исходный код нашей функции:
				function func() {
					return '!';
				}

				console.log(func); // увидим код функции 

		Функция как переменная в JavaScript:

			Итак, в предыдущем уроке мы с вами выяснили, что обратившись к функции без круглых скобок, мы получаем ее исходный код.

			На самом деле все намного интереснее. В JavaScript, в отличие от других языков, функции являются такими же значениями переменных,
			как числа, строки и массивы.

			Давайте посмотрим на примере. Пусть у нас есть, например, функция func:
				function func() {
					console.log('!');
				}

			На самом деле, у нас нет функции func. У нас есть переменная func, хранящая в себе исходный код функции. 

			Мы можем, к примеру затереть переменную func чем-нибудь другим, например, строкой. В этом случае функция func больше не будет функцией,
			а будет строкой. Смотрте на примере:
				function func() {
					console.log('!');
				}
				func(); // выведет '!'

				func = 'string'; // затрем переменную func
				console.log(func); // выведет 'string'

		Запись функции в другую переменную в JavaScript:

			Пусть у нас есть функция func:
				function func() {
					console.log('!');
				}

			Давайте скопируем ее исходный код в переменную test:
				function func() {
					console.log('!');
				}

				let test = func; // теперь test такая же функция, как и func

				// Проверим:
				test(); //выведет '!'
				func(); //выведет '!'

		Присваивание функций в переменные в JavaScript:

			Итак, мы с вами уже выяснили, что название функции и ее исходный код отделены друг от друга. Поэтому в JavaScript существует 
			альтернативный синтаксис для создания функции: создается функция без имени и присваивается в какую нибудь переменную. Эта переменная 
			и становится именем функции.

			Давайте посмотрим на примере:
				let func = function() {
					console.log('!');
				};

				func(); // выведет '!'

		Совпадение имени функции и переменной в JavaScript:

			Из описанного выше следует, что существование переменной и функции с одинаковым именем легко может привести к проблеме. 

			В следующем примере функция func будет затерта и вместо нее станет строка 'string':
				function func() {
					return '!';
				}

				func = 'string'; // затрем переменную с функцией строкой
				func(); // получим ошибку, т.к. func - не функция

		Function Expression и Function Declaration в JavaScript:

			В JavaScript фукнцию можно объявить двумя способами. 

			Первый способ - это просто объявить функцию через function, сразу задав ее имя:
				function func() {
					console.log('!');
				}

				func(); // выведет '!' 

			Второй способ - это сделать безымянную функцию и записать ее в какую-либо переменную:
				let func = function() {
					console.log('!');
				};

				func(); // выведет '!'

			По научному певый способ называется Function Declaration (объявление функции), а второй 
			Function Exression (функциональное выражение).

		Разница объявлений функций:

			Оба способа объявления функции эквивалентны, но есть существенная разница: функции, объявленные как Function Declaration,
			будут доступны, даже если обратится к ним до того, как они были объявлены.

			Смотрите пример:
				// Обращаемся к функции до ее объявления:
				func(); //выведет '!'

				function func() {
					console.log('!');
				}

			А функциональные выражения создаются в момент выполнения кода и недоступны выше. Поэтому такой код выдаст ошибку:
				func(); //ошибка, такой функции еще нет!

				let func = function() {
					console.log('!');
				}; 

		Точка с запятой при объявлении функций в JavaScript:

			При объявлении функции как Function Declaration после фигурной скобки } точка запятой не ставится:
				function func() {
					console.log('!');
				} 

			Если же функция объявлена Function Expression, то после } ставится точка с запятой:
				let func = function() {
					console.log('!');
				};

			Почему: потому что в JavaScript любое выражение должно заканчиваться точкой запятой, а в данном случае у нас как раз-таки
			выражение. Эта точка с запятой не обязательна, так как JavaScript вообще разрешает их не ставить, но желательно ставьте всегда.

		Нюансы функциональных выражений в JavaScript:
			Название Function Expression (функциональное выражение) дано не просто так. Оно действительно означает это - то, 
			что такие функции являются частью какого-то выражения. 
			
			Например, мы можем сложить какую-нибудь строку и безымянную функцию:
				let str = 'str' + function() {return 3;};
				console.log(str); // выведет 'strfunction() {return 3;}'

			Почему мы видим такой странный результат, а не число 3? Потому что второе слагаемое - это не результат работы функции,
			а ее исходный код (ведь мы эту функцию не вызвали, а просто написали).

			То есть название функциональное выражение означает то, что такая функция принимает участие в каком-нибудь выражении.

			Присваивание к переменной тоже выражение:
				let func = function() {
					console.log('!');
				}; 

			Можно также, к примеру передать функцию в качестве параметра алерта и он выведет ее сходный код а консоль - 
			это тоже будет считаться выражением:
				console.log(function() {return 3;});

			Почему это важно: потому что отличие между Function Declaration и Function Expression совсем не в том, что первая
			функция создается с именем, а вторая изначально имени не имеет. Это не так.

			Пример. Вот у нас функция без имени, но при этом не учавствует ни в каком выражении (то есть с ней не совершается 
			никаких действий, говоря по-простому):
				/*
					Данная функция будет Function Declaration,
					но с синтаксической ошибкой:
				*/
				function() {
					console.log('!');
				}  

			Такой код вообще выдаст ошибку! Почему: так как функция не участвует ни в каком выражении, то браузер 
			считает ее Function Declaration, но не находит ее имени и выдаст ошибку.

			Чтобы ошибка исчезла, нужно заставить функцию стать частью какого-либо выражения. Например, напишем перед ней операцию +:
				+function() { // такой код корректен
					console.log('!');
				};

			Как это работает: сама по себе операция + ничего не делает, это все равно как написать вместо числа 3 число +3 - допустимо,
			но ничего не меняет. 

			Но в случае с функцией - меняет. Теперь наша функция уже не просто написана, а учавсвтует в выражении. Поэтому ошибки 
			теперь не будет. Результата выполнения функции тоже не будет, ведь мы ее просто написали, но не вызвали. 

			Вместо + можно написать все что угодно. Например:
				-function() { // такой код корректен
					console.log('!');
				};

				!function() { // такой код корректен
					console.log('!');
				};
				
			Можно также взять нашу функцию в круглые скобки, в этом случае она также станет функциональным выражением:
				(function() { // такой код корректен
					console.log('!');
				});

		Функция с именем, но Fucntion Expression в JavaScript:

			Давайте теперь сделаем функцию, которая будет иметь имя, но при этом будет Funciton Expresion, потому что 
			учавствует в выражении:
				+function func() {
					console.log('!');
				}

			Интересно, что по имени func мы не сможем обратиться к нашей функции, это будет приводить к ошибке:
				+function func() {
					console.log('!');
				}

				func(); // выдаст ошибку

			Чтобы иметь возможность вызвать функцию, ее нужно присвоить какой-нибудь переменной:
				let test = function func() {
					console.log('!');
				};

				test(); // выведет '!'
			
			Еще раз: функция, являющаяся функциональным выражением не может быть вызвана по ее имени. Такая функция может быть 
			вызвана только с использованием переменнной, в которую была записана эта функция. 

			Но тем не менее, функциональное выражение может иметь имя функции, это будет синтаксически корректно. Зачем такое нужно, 
			мы будем разюираться в следующих уроках.

			Подведем итог: функции являются Funciton Declaration или Function Expression не потому, что имеют имя или не имеют, а потому,
			что являются участниками выражений или не являются.

			Как вы видели выше, функция без имени может быть воспринята как Function Declaration, а функции с именем может быть 
			Function Expression. 

		Именованные функциональные выражения в JavaScript:

			Пусть у нас есть вот такое функциональное выражение:
				let test = function() {
					console.log('!');
				};

				test(); // выведет '!'

			Давайте нашей функции дадим имя func:
				let test = function func() {
					console.log('!');
				};

				test();

			Как вы уже знаете, по этому имени не обратиться у функции:
				let test = function func() {
					console.log('!');
				};

				test(); // выведет '!'
				func(); // выдаст ошибку

			Зачем же давать имя функции, если оно не будет доступно? Дело в том, что это имя будет недоступно снаружи функции, 
			но доступно внутри этой функции.

			Проверим:
				let test = function func() {
					console.log(func); // функция выведет свой же исходный код
				};

				test(); // вызываем функцию

			Если запустить этот код, то в консоль будет выводиться бесконечное количетсво выводов в консоль. 

			На самом деле наша функция может быть вызвана внутри себя не только как func, но и как test:
				let test = function func() {
					console.log('!');
					test(); // вызываем сами себя
				};

				test(); 

			В чем же разница? Разница в том, что имя test - это просто переменная. В процессе работы скрипта наша функция может записаться
			в другую переменную или передаться параметром - в этом случе связь между переменной test и функцией может пропасть.

			Имя func же жестко привязано к функции специально для того, чтобы можно было обратиться к нашей функции внутри нее самой.

			Такие Funtion Expression с именем функции называются именованными функциональными выражениями. 

		Как проверить тип функции в JavaScript:

			В задачах ниже, вам нужно будет определить функция определена как Funtion Declaration или Funtion Expression. 

			В простых случаях это не составляет труда сделать визуально. Но как проверить, что вы сделали это правильно? Используйте
			разницу между Funtion Declaration или Funtion Expression: первые могут быть вызваны выше своего определения, а вторые - нет.

			Пусть у нас есть вот такая функция:
				let test = function() {
					console.log('!');
				}

			Обратимся к этой функции до ее определения:
				test(); // выведет ошибку в консоль, значит Function Expression

				let test = function() {
					console.log('!');
				}

			Вот еще пример:
				func(); // выведет '!', значит Function Declaration

				function func() {
					console.log('!');
				}

			Поставим перед нашей функцией плюсик:
				func(); // выведет ошибку в консоль, значит Function Expression

				+function func() {
					console.log('!');
				}

			Так как функция выше - это Function Expression и она не присвоена никакой переменной, то ее никак нельзя вызвать,
			ведь по имени func она будет недоступна.

		Выражение слева функции в JavaScript:

			Давайте рассмотрим следующий код:
				+function func() {
					console.log('!');
				}

			Как вы уже знаете, эта функция является функциональным выражением, ни смотря на то, что у нее задано имя (мы уже выяснили,
			что наличие имени вообще не критерий). Уберем плюс - и получим Function Declaration:
				function func() {
					console.log('!');
				}

			Давайте поставим + на строчке перед функцией - она опять станет Function Expression:
				+
				function func() {
					console.log('!');
				} 

			А теперь после плюса поставим число 1 и точку с запятой - наша функция станет Funcion Declaration:
				+1;
				function func() {
					console.log('!');
				}

			Почему так: потому что на первой строчке написана одна законченная команда, закрытая точкой запятой. 
			Поэтому эта команда никак не влияет на нашу функцию. 

			На самом деле точку с запятой можно убрать, ведь в JavaScript она не обязательна - функция все равно 
			останется Function Declaration:
				+1
				function func() {
					console.log('!');
				}

			А вот если после 1 влепить еще один плюс, то функция станет Fucntion Expression:
				+1+
				function func() {
					console.log('!');
				}

			Почему так: потому что на первой строчке незавершенное выражение - стоит плюс и после него ничего. Поэтому интерпретатор 
			JavaScript считает, что этот плюс относится к строке ниже, то есть к нашей функции. 

			Если же на первой строке стоит завершенное выражение. то JavaScript автоматически ставит ему точку с запятой и это 
			выражение никак не влияет на нашу функцию.

		Выражение справа функции в JavaScript:

			Учтите, что выражение в котором учавтвует функция, должно быть слева от нее. Если мы что-то пытаемся сделать справа
			от функции, это не сделает ее функциональным выражением. Пример:
				function func() { // это Function Declaration
					console.log('!');
				} + 1;

			Почему так: потому что в данном случае этот +1 является просто новой командой, написанной после функции.
			Если написать эту команду с новой строки, все становится очевиднее:
				function func() {
					console.log('!');
				}
				+1; // просто команда

			Сделаем из нашей функции Funcion Expression. Например, поставим перед функцией +:
				+function func() { // это Function Expression
					console.log('!');
				} + 1;

			Или выполним присваивание:
				let test = function func() { // это Function Expression
					console.log('!');
				} + 1;

			Или передадим в параметр алерт:
				console.log(function func() { // это Function Expression
					console.log('!');
				} + 1);

		Массив с анонимными функциями в JavaScript:

			Я уже упминал ранее, что функции в JavaScript ведут себя, будто строки или числа. В частности, можно сделать массив, 
			состоящий из функции. Сделаем:
				let arr = [
					function() {console.log('1')},
					function() {console.log('2')},
					function() {console.log('3')},
				];	

			Давайте, например выведем в консоль содержимое нулевого элемента массива:
				let arr = [
					function() {console.log('1')},
					function() {console.log('2')},
					function() {console.log('3')},
				];

				console.log(arr[0]); // увидим исходный код первой функции

			Как вы видите, в примере выше мы получаем исходный код функции, а не результат. 

			Чтобы происходил вызов функции, к ней нужно дописать круглые скобки. Так как наша функция хранится а arr[0], то 
			круглые скобки нужно будет написать после квадратных, вот так: arr[0](). Проверим:
				let arr = [
					function() {console.log('1')},
					function() {console.log('2')},
					function() {console.log('3')},
				];

				arr[0](); // выведет '1' 

			Можно также перебрать наш массив с функциями циклом в этом цикле вызвать каждую из функций:
				let arr = [
					function() {console.log('1')},
					function() {console.log('2')},
					function() {console.log('3')},
				];

				for (let func of arr) {
					func(); // вызываем наши функции в цикле
				}

		Объект с анонимными функциями в JavaScript:
			
			В предыдущем уроке мы с вами делали массив, состоящий из функций. Давайте теперь вместо массива сдедаем объект 
			с ключами, значениями которых будут функции:
				let obj = {
					func1: function() {console.log(1)},
					func2: function() {console.log(2)},
					func3: function() {console.log(3)},
				};

			Воспользуемся нашим объектом:
				let obj = {
					func1: function() {console.log(1)},
					func2: function() {console.log(2)},
					func3: function() {console.log(3)},
				};

				obj.func1(); // выведет 1

		Применение объекта с функциями в JavaScript:

			Давайте сделаем объект с двуми функциями, каждая их которых параметром будет принимать число. Пусть первая функция возводит 
			переданное число в квадрат, а вторая функция - в куб. Реализуем:
				let math = {
					square: function(num) {return num * num},
					cube: function(num) {return num * num * num},
				};

			Воспользуемся нашими функциями:
				let math = {
					square: function(num) {return num * num},
					cube: function(num) {return num * num * num},
				};

				console.log( math.square(2) ); // выведет 4
				console.log( math.cube(2) ); // выведет 8

		Передача функций параметрами в JavaScript:

			Функции, подобно числами строкам и массивам, могут передаваться параметрами в другие функции. 

			Рассмотрим подробнее на практическом примере. Пусть у нас есть функция test, принимающая два параметра:
				test (параметр1, параметр2);

			Давайте в первый параметр функции test передадим анонимную функцию, возвращающую 1, а во второй параметр - 
			анонимную функцию, возвращающую 2:	
				test(
					function() {return 1;},
					function() {return 2;}
				);

			Код, приведенный выше, пока не рабочий, так как мы не создали саму функцию. Сделаем это:
				function test(func1, func2) {
					
				}

			При определении функции мы указали два параметра - func1 и func2. Эти параметры ничего не знают про то, что в них 
			будет передаваться. Можем, например передать числа:
				test(1, 2); // вызываем функцию

				function test(func1, func2) {
					console.log(func1); // выведет 1
					console.log(func2); // выведет 2
				}

			А можем передать функции:
				test(
					function() {return 1;}, // первый параметр
					function() {return 2;}  // второй параметр
				);

				function test(func1, func2) {
					console.log(func1); // выведет 'function() {return 1;}'
					console.log(func2); // выведет 'function() {return 2;}'
				}

			Как вы видите, теперь в консоль выводится исходный код функций. Давайте сделаем так, чтобы он выводил из результаты.
			Для этого напишем функциям круглые скобки:
				test(
					function() {return 1;},
					function() {return 2;}
				);

				function test(func1, func2) {
					console.log( func1() ); // выведет 1
					console.log( func2() ); // выведет 2
				}

			Давайте выведем в консоль сумму результатов первой и второй функций:
				test(
					function() {return 1;},
					function() {return 2;}
				);

				function test(func1, func2) {
					console.log( func1() + func2() ); // выведет 3
				}

		Именованные функции-параметры в JavaScript:

			Функции, которые передаются параметрами, не обязательно должны быть анонимными.

			Давайте сделаем их как Function Declaration. Первую функцию назовем get1, а вторую - get2:
				function get1() {
					return 1;
				}
				function get2() {
					return 2;
				}

			Передадим в параметры функции test имена функций get1 и get2 (то есть их исходный код, а не результат):
				function get1() {
					return 1;
				}
				function get2() {
					return 2;
				}

				test(get1, get2); // выведет 3

				function test(func1, func2) {
					console.log( func1() + func2() );
				} 	

			Переделаем на Function Expression:
				let get1 = function() {
					return 1;
				}
				let get2 = function() {
					return 2;
				}

				test(get1, get2); // выведет 3

				function test(func1, func2) {
					console.log( func1() + func2() );
				}

		Параметры передаваемых функций в JavaScript:

			Пусть у нас есть функция test, которая параметром принимает другую функцию и в консоль выводит результат работы 
			этой переданной функции:
				function test(func) {
					console.log( func() );
				} 

			Пусть переданная функция func параметром принимает число и что-то с ним делает. Предеадим ей, например, число 3:
				function test(func) {
					console.log( func(3) );
				}	

			Давайте теперь, вызовем функцию test, передав в нее параметром анонимную фнукцию. Эта анонимная функция параметром 
			будет принимать число и возвращать квадрат этого числа.

			В результате всего этого наша конструкция выведет квадрат этого числа 3, то есть 9:
				// Выведет 9:
				test(
					function(num) {
						return num * num;
					}
				);

				function test(func) {
					console.log(func(3));
				}

			Оформим код более изящно:
				// Выведет 9:
				test(function(num) {
					return num * num;
				});

				function test(func) {
					console.log(func(3));
				}
			
		Передача числа параметром в JavaScript:

			Давайте теперь число, с которым что-то делает предаваемая функция, не будем жестко хранить внутри test, а передадим первым параметром:
				function test(num, func) { // первым параметром приходит число
					console.log(func(num));
				} 		

			Воспользуемся нашей функцией:
				function test(num, func) {
					console.log(func(num));
				}

				// Выведет 4:
				test(2, function(num) {
					return num * num;
				});

			В удобство нашей конструкции: у нас есть одна функция test, параметром принимающая число. Но то, что будет происходить с числом 
			не зашито жестко в функции test.

			Мы можем, к примеру вторым параметром функции test передать функцию, вовзводящую в квадрат, а можем к примеру возводящую в куб:
				function test(num, func) {
					console.log(func(num));
				}

				// Найдем квадрат числа:
				test(2, function(num) {
					return num * num; // возвращает квадрат
				});

				// Найдем куб числа:
				test(2, function(num) {
					return num * num * num; // возвращает куб
				});	

		Применение передачи функции параметром в JavaScript:

			Давайте сделаем функцию, которая параметром будет принимать массив, а вторым параметром - функцию. 
			Переданная функция должна будет примениться к каждому элементу массива:
				function test(arr, func) {
					// вернем измененный массив
				}	

			Реализуем:
				function test(arr, func) {
					// Запускаем цикл:
					for (let i = 0; i < arr.length; i++) {
						arr[i] = func(arr[i]); // применяем функцию к каждому элементу
					}
					
					return arr; // возвращаем измененный массив
				}

			Применим нашу функцию к какому-нибудь массиву:
				function test(arr, func) {
					for (let i = 0; i < arr.length; i++) {
						arr[i] = func(arr[i]);
					}
					
					return arr;
				}

				// Преобразуем массив чисел в массив их квадратов:
				let result = test(
					[1, 2, 3],
					function(num) {return num * num;}
				);

				console.log(result); // выведет [1, 4, 9]

			Оформим вызов нашей функции изящнее (так более принято):
				function test(arr, func) {
					for (let i = 0; i < arr.length; i++) {
						arr[i] = func(arr[i]);
					}
					
					return arr;
				}

				// Оформим код изящнее:
				let result = test([1, 2, 3], function(num) {
					return num * num;
				});

				console.log(result); // выведет [1, 4, 9]

		Вложенные функции в JavaScript:

			Пусть у нас есть функция, параметром принимающая два числа и возвращающая сумму квадратов этих чисел:
				function func(num1, num2) {
					return num1 * num1 + num2 * num2;
				}

				console.log(func(2, 3)); // выведет 13 (результат 2 * 2 + 3 * 3)

			Давайте операцию возведения в квадрат вынесем в спомогательную функию square:
				function square(num) {
					return num * num;
				}

				function func(num1, num2) {
					return square(num1) + square(num2);
				}

				console.log(func(2, 3)); // выведет 13

			Пусть мы уверены, что функция square будет использоваться только в функции func и больше ни в какой другой.

			В этом случае было бы удобно сделать так, чтобы ее никто случайно не использовал (вы сами или другой программист, работающий вместе с вами).

			В JavaScript есть изящное решение: можно нашу вспомогательную функцию square поместить вовнутрь func. В этом случае наша вспомогательная 
			функция будет доступна только внутри func, а снаружи - не будет.

			Сделаем это:
				function func(num1, num2) {
					function square(num) {
						return num * num;
					}
					
					return square(num1) + square(num2);
				}

				console.log(func(2, 3)); // выведет 13
				
			Попытка вызвать square снаружи func приведет к ошибке:
				function func(num1, num2) {
					function square(num) {
						return num * num;
					}
					
					return square(num1) + square(num2);
				}

				console.log(square(2)); // выдаст ошибку

		Область видимости вложенных функций в JavaScript:

			Если функция содержит внутри другую функцию - переменные внешней функции видны во внутренней:
				function test() {
					let num = 1; // переменная внешней функции
					
					function func() {
						console.log(num); // выведет 1
					}
					
					func(); // вызываем внутреннюю функцию
				}

				test(); // вызываем внешнюю функцию

			Также во внутренней функции будут видны переменные, определенные снаружи внешней функции:
				let num = 1; // глобальная переменная

				function test() {
					function func() {
						console.log(num); // выведет 1
					}
					
					func(); // вызываем внутреннюю функцию
				};

				test(); // вызываем внешнюю функцию

		Параметры внешней функции также будут доступны во внутренней:
			function test(num) {
				function func() {
					console.log(num); // выведет 1
				}
				
				func(); // вызываем внутреннюю функцию
			};

			test(1); // передаем параметром число

		Параметры внешней и внутренней функции в JavaScript:

			Давайте сделаем так, чтобы и внешняя функция и внутренняя принимала параметры:
				function test(num) {
					function func(localNum) {
						console.log(localNum);
					}
				}

			Передадим параметр внешней функции в вызов внутренней функции:
				function test(num) {
					function func(localNum) {
						console.log(localNum); // выведет 1
					}
					
					func(num); // передаем параметр
				}

				test(1); // передаем параметром число

			Получается, что во внутренней функции будет доступна переменная num как внешняя переменная из родительской функции и переменная localNum,
			являющаяся локальной переменной внутренней функции.

			Обе эти переменные будут иметь одинаковые значения:
				function test(num) {
					function func(localNum) {
						console.log(num); // выведет 1
						console.log(localNum); // выведет 1
					}
					
					func(num);
				}

				test(1);

			Разница между ними будет в следующем: если во внутренней функции изменить переменную num - она поменяется и во внешней функции:
				function test(num) {
					function func(localNum) {
						num = 2; // меняем переменную num
					}
					
					func(num);   // передаем параметр
					console.log(num);  // выведет 2
				}

				test(1); // передаем параметром число

			А переменная localNum будет локальной. Ее изменения не будут приводить ни к каким изменениям во внешней функции. Да и сама переменная 
			localNum не будет видна снаружи внутренней функции:
				function test(num) {
					function func(localNum) {
						localNum = 2; // меняем переменную num
					}
					
					func(num); // передаем параметр
				}

				test(1); // передаем параметром число

		Одноименные параметры в JavaScript:

			Пусть теперь внешняя и внутренняя функция имюет одноименные параметры:
				function test(num) {
					function func(num) {
						console.log(num); // выведет 1
					}
					
					func(num);
				};

				test(1);	

			В этом случае во внутренней функции будет локальная переменная num. Ее изменение во внутренней функции никак не будет влиять на 
			внешнюю переменную num:
				function test(num) {
					function func(num) {
						num = 2; // меняем локальную переменную num
					}
					
					func(num);
					console.log(num); // выведет 1 - ничего не поменялось
				}

				test(1);

			Получится, что внутренная функция никак не сможет обратиться к внешней переменной num для того, чтобы изменить ее:
				function test(num) {
					function func(num) {
						// тут нельзя получить доступ в внешней переменной num
					}
					
					func(num);
				}
				test(1);

		Функция, возвращающая функцию в JavaScript:

			Пусть у нас есть вот такая функция, возвращающая строку:
				function func() {
					return '!';
				}

				let result = func();
				console.log(result); // выведет '!'	

			Давайте теперь вместо строки, по аналогии, вернем анониммую функцию:
				function func() {
					return function() {
						return '!';
					};
				}

				let result = func(); // в переменной result будет функция
				console.log(result); // выведет 'function() {return '!';}'

			Как вы видите, переменная result теперь представляет собой функцию. Давайте выведем в консоль результат ее работы. 
			Для этого напишем ей круглые скобки:
				function func() {
					return function() {
						return '!';
					};
				}

				let result = func();
				console.log( result() ); // выведет '!'

			Так как вызов func() возвращает функцию, то мы можем сразу же и вызвать эту возвращаемую функцию, вот так: func()() - первые круглые скобки
			получают результаты функции func (который сам является функцией), а вторые круглые скобки применяются к результату func. 

			Давайте попробуем:
				function func() {
					return function() {
						return '!';
					};
				}

				console.log( func()() ); // выведет '!' 

		Любой уровень вложенности в JavaScript:

			Могут быть и такие вызовы функции: func()()() и func()()()() - и так далее до бесконечности. 

			Для этого нужно, чтобы внутренняя функция тоже возвращала функцию, та - еще одну и так далее. Вот пример:
				function func() {
					return function() {
						return function() {
							return '!';
						};
					};
				}

				console.log( func()()() ); // выведет '!'	

		Параметры вовзращаемой функции в JavaScript:

			В изученные нами вызовы функции можно передавать параметры. В следующем примере внутренная функция ожидает параметром строку и 
			выводит ее в консоль:
				function func() {
					return function(str) {
						return str;
					};
				}

			Внутренней функции соотвествует вторая скобка при вызове, значит в эту вторую скобку и передаеи желаемую строку:
				function func() {
					return function(str) {
						return str;
					};
				}

				console.log( func()('!') ); // выведет '!'

			Давайте сделаем так, чтобы и первая принимала параметр, и вторая. А результатом вызова сделаем сумму этих параметров:
				function func(num1) {
					return function(num2) {
						return num1 + num2;
					};
				}

				console.log( func(1)(2) ); // выведет 3

		Функции-коллбэки в JavaScript:

			Функции можно передавать параметрами в другие функции. Такие функции-параметры назваются коллбэками (англ. callback). 
			Давайте посмотрим работу с ними на примере.

			Пусть мы хотим сделать функцию, которая первым параметром будет принимать массив, а вторым - коллбэк, который будет применять
			к каждому элементу массива:
				function each(arr, callback) {
					// тут какой-то код
				} 	

			Напишем реализацию нашей функции:
				function each(arr, callback) {
					let result = [];
					
					for (let elem of arr) {
						result.push( callback(elem) ); // вызываем функцию-коллбэк
					}
					
					return result;
				}

			Наша функция each - универсальная. Это значит, что мы можем передавать в нее различные коллбэки, выполняя разные операции над 
			массивами. При этом код нашей функции остается неизменным - будут меняться только передаваемые коллбэки. 

			Давайте для примера с помощью нашей функции возведем в квадрат каждый элемент какого-нибудь массива. Для этого передадим параметром 
			соответствующий коллбэк:
				let result = each([1, 2, 3, 4, 5], function(num) {
					return num ** 2;
				});

				console.log(result);

			А теперь возведем элементы массива в куб. Для этого в качестве параметра передадим уже другой коллбэк, выполняющий эту операцию:
				let result = each([1, 2, 3, 4, 5], function(num) {
					return num ** 3;
				});

				console.log(result);

		Нюансы коллбэков в JavaScript:

			Коллбэки не обязательно должны быть анонимными функциями. Пусть для примера у нас есть следующая функция:
				function square(num) {
					return num ** 2;
				}	

			Давайте с ее помощью возведем каждый элемент массива в квадрат:
				function square(num) {
					return num * num;
				}

				let result = each([1, 2, 3, 4, 5], square);
				console.log(result);

		Стрелочные функции в JavaScript:

			Давайте теперь рассмотрим стрелочные функции, упрощающие синтаксис функций.

			В следующем примере кода первой написана обычная функция, а второй - соотвествующая ей стрелочная функция 
			(обе функции делают одно и то же):
				let func1 = function(num1, num2) {
					let result = num1 * num2;
					return result;
				}

				let func2 = (num1, num2) => {
					let result = num1 * num2;
					return result;
				}

			Если в функции одна строка, то в стрелочных функциях можно не писать return и фигурные скобки:
				let func1 = function(num1, num2) {
					return num1 * num2
				}

				let func2 = (num1, num2) => num1 * num2;

			Если параметр стрелочной функции один - кгрулые скобки можно не писать:
				let func1 = function(num) {
					return num * num;
				}

				let func2 = num => num * num

			Если в функции вообще нет параметром - нужно писать пустые круглые скобки:
				let func1 = function() {
					console.log('!!!');
				}

				let func2 = () => console.log('!!!')

		Применение стрелочных функций в JavaScript:

			Особое преимущество стрелочные функции имеют в качестве коллбэков. Давайте посмотрим на примере, насколько упрощается код в таком случае.
			Пусть для примера у нас есть следующая функция filter:
				function filter(arr, callback) {
					let res = [];

					for (let elem of arr) {
						if ( callback(elem) === true ) {
							res.push(elem);
						}
					}
					
					return res;
				}  

			Вызовем функцию, передав ей коллбэк:
				let result = filter([1, 2, 3, 4, 5], function(elem) {
					if (elem % 2 === 0) {
						return true;
					} else {
						return false;
					}
				});

			Давайте теперь упростим нашу функцию. Для начала давайте избавимся от крнструкции if и напишем условие просто через оператор ===:
				let result = filter([1, 2, 3, 4, 5], function(elem) {
					return elem % 2 == 0;
				});

			Заменим теперь обычную функцию на стрелочную:
				let result = filter([1, 2, 3, 4, 5], elem => elem % 2 == 0);
				
		Доступ к внешним переменным функций в JavaScript:

			Давайте рассмотрим следующий код:
				let num = 1; // задаем значение переменной

				function func() {
					console.log(num); // выводим его в консоль
				}

				func(); // вызываем функцию

			Как уже упоминалось ранее, значение переменной не обязательно должно быть перед определением функции, главное, чтобы оно стояло 
			перед ее вызовом:
				function func() {
					console.log(num);
				}

				let num = 1;
				func();

			На самом деле это не совсем так. Наша функция даже до своего вызова знает значение переменной num:
				let num = 1;

				function func() {
					console.log(num); // функция уже знает, что num = 1
				} 

			Вот более сложный пример:
				let num = 1; // функция в этот момент узнает, что num = 1

				function func() {
					console.log(num);
				}

				num = 2; // функция в этот момент узнает, что num = 2

			Добавим вызовы функции:
				let num = 1; // функция в этот момент узнает, что num = 1
				func(); // выведет 1

				function func() {
					console.log(num);
				}

				func(); // выведет 1
				num = 2; // функция в этот момент узнает, что num = 2
				func(); // выведет 2

			Еще раз: на самом деле, функция знает значения внешних переменных, даже не будучи вызванной.

		Лексическое окружение функций в JavaScript:

			Все внешние, доступные функции переменные, называются ее лексичским окржуением (англ. LexicalEnvironment).
			
			В следующем примере функции доступны две переменные: num1 и num2, которые и ялвяются лексическим окружением нашей функции:
				let num1 = 1;
				let num2 = 2;

				function func() {
					// функция знает про переменные num1 и num2
				}

			Само лексическое окружение представляет собой некий внутренний объект JavaScript, привязанный к нашей функции. В данном случае
			его можно представить в следующем виде:
				{num1: 1, num2: 2}

			Значение любой переменной лексического окружения всегда равно текущему значению этой переменной:
				let num1 = 1; // окружение {num1: 1}
				let num2 = 2; // окружение {num1: 1, num2: 2}

				// Поменяем переменную num1:
				num1 = 123; // окружение {num1: 123, num2: 2}

				function func() {
					
				} 

			Когда мы пытаемся обратиться к какой либо переменной внтури функции, эта переменная вначале ищется среди локальных переменных функции и, 
			если такой переменной там нет, то ищектся в лексическом окружении функции.  
							
		Применение лексического окружения функций в JavaScript:

			Пусть у нас есть функция, своим результатом возвращающая другую функицю:
				function test() {
					return function() {
						
					}
				}		

			Если родительская функция имеет какие-либо переменные, то эти переменные будут содержаться в лексическом окружении возвращаемой функции:
				function test() {
					let num = 1; // переменная родительской функции
					
					return function() {
						// лексическое окружение = {num: 1}
					}
				}

			Напишем в коде нашей возвращаемой функции алерт, выводящий в консоль значение переменной num:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
					}
				}

			Давайте теперь вызовем родительскую функцию test и результат ее работы запишем в переменную func:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
					}
				}

				let func = test();

			В переменную func запишется возвращаемая функция. Давайте вызовем нашу функцию - своим результатом она выведет содержимое
			переменной num:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
					}
				}

				let func = test();
				func(); // выведет 1

			Если же просто попытаться вывести переменную num вне функции - она будет недоступна:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
					}
				}

				console.log(num); // переменная num тут недоступна

			Как вы видите, локальная переменная num привязалась к лексическому окружению нашей функции и теперь, вызвав в любом месте,
			кода эту функцию, мы сможем получить значение переменной num, даже если в месте вызова сама по себе эта переменная и недоступна.
			
			На самом деле аналогичного результата можно добиться, сделав переменную num глобальной:
				function test() {
					return function() {
						console.log(num);
					}
				}

				let num = 1; // глобальная переменная
				let func = test();
				func(); // выведет 1

			Здесь, однако, будет существенная разница: в новом варианте переменную num можно менять вне функции (так как она глобальная),
			а в старом - нет.

		Замыкания в JavaScript:

			Давайте тепер изучим понятие замыкание (англ. closure). На самом деле вы уже знакомы с этим понятием, осталость только узнать
			правильную терминологию. 

			Итак, замыкание - это функция вместе со всеми внешними переменными, которые ей достпуны. Или, другими словами, замыкание - это Функция
			вместе со своим лексическим окружением. 

			В JavaScript чаще всего, говоря "замыкание функции", имеют ввиду не саму эту функцию, а именно ее внешние переменные. Если же какая-то
		 	функция получает переменную из своего лексического окружения, то говорят "переменная бетеся из замыкания".

			Вспомним код, который мы сделали в предыдщем уроке:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
					}
				}

				let func = test();
				func(); // выведет 1 

			В данном случае и можно сказать, что функция func получает значение переменной num из замыкания. Также можно сказать,
			что функция func хранит значение переменной num в замыкании.
			
		Счетчик на замыканиях в JavaScript:

			Давайте перепишем рассмотренный код так, чтобы возвращаемая функция каждый раз увеличивала значение переменной num на единицу:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
						num++; // прибавляем единицу
					}
				}

				let func = test();

			Получится, что каждый вызов функции будет выводить в консоль новое значение:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
						num++;
					}
				}

				let func = test();

				func(); //выведет 1
				func(); //выведет 2
				func(); //выведет 3
				func(); //выведет 4
				func(); //выведет 5

			Получается, что мы реализовали счетчик вызова функции, используя замыкание (точнее используя переменную num из замыкания нашей функции).

			Учтите, что каждый вызов функции test будет возвращать новую функцию, у которой будет свое замыкание.
			То есть разные счетчики будут работать независимо:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
						num++;
					};
				}

				let func1 = test(); // первый счетчик
				func1();  //выведет 1
				func1();  //выведет 2

				let func2 = test(); // второй счетчик
				func2();  //выведет 1
				func2();  //выведет 2

			Получается, что одна и так же переменная num для разных функций будет иметь разное значение!

			То есть если мы вызовем функцию test два раза, то полученные из нее функции будут работать независимым образом и каждая из этих функций 
			будет иметь свою независимую переменную num. 

		Локальная переменная счетчика JavaScript:

			Рассмотрим следующий код:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
						num++;
					};
				}

				test()(); // выведет 1
				test()(); // выведет 1

			Почему всегда выводится число 1? Для того, чтобы понять это, перепишем наш код по другому:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
						num++;
					};
				};

				let func1 = test(); // первая функция
				func1();  //выведет 1

				let func2 = test(); // вторая функция
				func2();  //выведет 1

			То есть каждый вызов функции test таким образом: test()(), создает свою функцию со своим замыканием и сразу же вызывает эту функцию.

		Глобальная переменная счетчика в JavaScript:

			Вынесем переменную num за функции, тем самым сделав ее глобальной:
				let num = 1; // глобальная переменная

				function test() {
					return function() {
						console.log(num);
						num++;
					};
				}

			В этом случае все возвращаемые функции будут изменять эту глобальную переменную и счетчики будут работать уже зависимо друг от друга:
				let num = 1;

				function test() {
					return function() {
						console.log(num);
						num++;
					};
				}

				let func1 = test(); // первый счетчик
				func1();  // выведет 1
				func1();  // выведет 2

				let func2 = test(); // второй счетчик
				func2();  // выведет 3
				func2();  // выведет 4 

			Почему же наш предыдущий код делал независимые счетчики? Напомню этот код:
				function test() {
					let num = 1;
					
					return function() {
						console.log(num);
						num++;
					};
				};

			Дело в том, что переменная num - локальная внутри функции test. Поэтому каждый выхов test порождает свою локальную переменную.

			Поэтому возвращаемые функции будут ссылаться каждая на свою локальную переменную функции test. Именно так и достигается независимость
			работы.

			Если же сделать num глобальной переменной - это тоже будет замыканием. Просто лексические окгружения возвращаемых функций ссылкаются на одну 
			и ту же переменную num - любые изменения с этой переменной будут видны во всех функциях.

		Вызов функции на месте в JavaScript:

			Сейчас мы разберем прием, который позволяет вызвать функцию прямо на месте ее объявления. 
			Такая конструкция называется Immediately Invoked Function Expression (IIFE). 

			Давайте посмотрим на примере. Пусть у нас есть вот такое функциональное выражение:
				let func = function() {
					console.log('!');
				};

				func(); // выведет '!'

			Давайте теперь не будем присваивать нашу функцию в переменную. а вызовем ее сразу же, "на месте". Для этого после функции 
			поставим круглые скобки: 
				+function() {
					console.log('!'); // выведет '!'
				}();

			Наличие плюс в данном случае является обязательным условием, так как без него функция станет Function Declaration, а их на месте
			(да еще без имени) вызывать нельзя. Конечно же, вместо плюса может быть все, что угодно - главное, чтобы наша функция была функциональным 
			выражением. 

		Присваивание функции в переменную в JavaScript:

			Пусть теперь наша вызываемая на месте функция не выводит что-то алертом в консоль, а возвращает через return:
				+function() {
					return '!';
				}();

			Давайте присвоим результат работы нашей функции в переменную и выведем его в консоль. Так как в данном случае идет присваивание 
			в переменную, то плюс уже не нужен:
				let result = function() {
					return '!';
				}();

				console.log(result); // выведет '!'

		Применение вызова функции на месте в JavaScript:

			Давайте применим вызов функции на месте в качестве одного из слагаемых:
				let sum = 1 + function() {
					return 2;
				}();

				console.log(sum); // выведет 3

		Круглые скобки в IIFE в JavaScript:

			Обычно при вызове функции на месте вместо плюса используются круглые скобки, так как такой способ оформления считается более очеыидным:
				(function() {
					console.log('!');
				}());

			Чаще всего круглые скобки вызова функции ставят снаружи, вот так:
				(function() {
					console.log('!');
				})();

		Параметры функции при вызове на месте в JavaScript:

			Пусть наша функция, которую мы собираемся вызвать на месте, параметром принимает строку для вывода алертом:
				function(str) {
					console.log(str);
				} 

			Давайте вызовем нашу функцию на месте, передав ей строку для вывода в консоль:
				(function(str) {
					console.log(str); // выведет '!!!'
				})('!!!'); 

		Множественные вызовы IIFE в JavaScript:

			Пусть вам предложат хитрую задачу: сделать несколько вызывающих скобок, вот так:
				(function() {
					// какой-то код
				})()(); // несколько вызывающих скобок

			Если поразмыслить, то становится очевидно, что в данном случае вызов функции на месте должен возвращать анонимную функцию, вот так:
				(function() {
					return function() {
						console.log('!');
					};
				})()(); // выведет '!'

		Подводные камни IIFE в JavaScript:

			Давайте рассмотрим два кусочка кода.

			Первый:
				let result = 1
				+function() {
					return 2;
				}();

				console.log(result);

			Второй:
				let result = 1;
				+function() {
					return 2;
				}();

				console.log(result);

			Эти два кусочка кода практически одинпковы, но если их зпуститть - результат будет отличаться. Первый код выведет в 
			консоль число 3, а второй - число 1.

			Почему получилась такая разница: все дело в том, что в одном случае в первой строке кода в конце отсутствует
			точка с запятой, а во втором случае - присутсвует. 

			Вы можете спросить: как же так, ведь в JavaScript точка с запятой в конце команды не является обязательной!
			На самом деле это не совсем так. Давайте разберемся, что у нас на самом деле происходит.

			первый код можно переписать так:
				let result = 1 + function() {
					return 2;
				}();

				console.log(result); // выведет 3

			Теперь, сразу становится очевидным, что к единице прибавляется результат вывода функции на месте, то есть 2. Поэтому
			итоговый результат будет 3.

			Если же после единицы поставить точку с запятой, то код будет воспринят интерпретатором по-другому:
				// Первая команда:
				let result = 1;

				// Вторая команда:
				+function() {
					return 2;
				}();

				// Третья команда:
				console.log(result); // выведет 
				
			То есть присваивание в переменную и вызов функции на месте станут разными командами. И все из-за наличия точки с запятой!

			Получается, что в данном случае вызов функции на месте вообще ничего не делает - просто вникуда возвращает число 2, 
			которое никак не влияет на переменную result.

			Давайте тогда разберемся, а почему мы вообще не можем писать точку с запятой в JavaScript. Пусть у нас 
			есть вот такой код:
				let result = 1 // в result запишется 1
				let test = 2   // в test запишется 2

			Он работает корректно, так как интерпретатор сам расставил в конце каждой строки точку с запятой. 

			Но посмотрите вот такой код:
				let result = 1
				+ 2; // в result запишется 3

			Теперь точка с запятой в конце первой строки не поставится автоматически, так как интерпретатор понимает, что команда 
			второй строки - это часть команды первой строки.

			Но если мы проставим точку с запятой - результат будет совсем другим:
				let result = 1; // в result запишется 1
				+ 2; // команда ничего не делает, но и ошибки не будет

			Получается, что интерпретатор сам ставит точку с запятой, только если следующая команда не является частью предыдущей.

			А теперь посмотрите на следующий код:
				let result = 1
				+function() {
					return 2;
				}();

				console.log(result);

			Действительно, вторая строка - просто продолжение команды первой строки и интерпретатор не ставит точку с запятой 
			автоматически. Именно поэтому, если мы сами напишем точку с запятой в конце первой строки - результат будет совсем другим.
			Это говорит о том, что лучше всего всегда ставить точку с запятой в нужных местах, во избежание проблем. 
				
		Точка с запятой для безопасности в IIFE:

			Пусть теперь наша вызывающаяся на месте функция будет не с плюсом вначале, а обернута круглыми скобками, вот так:
				(function() {
					console.log(1); // выведет 1
				})();	

			Пусть переменная num задается снаружи функции:
				let num = 1; // точка с запятой стоит

				(function() {
					console.log(num); // выведет 1
				})();

			Пусть теперь мы забыли поставить точку с запятой:
				let num = 1

				(function() {
					console.log(num); // выдаст ошибку
				})();

			Получается, что такой код выдаст ошибку, так как JavaScript воспринимает нашу функцию как продолжение
			команды первой строки.

			Чтобы избежать таких проблем, перед вызовом функции на месте всегда необходимо ставить точку с запятой, вот так:
				let num = 1

				;(function() {
					console.log(num); // выведет 1
				})();

			Кажется, что проблема несколько надуманна. На самом деле, это не так. Может быть такая ситуация, что у вас на странице 
			подключается несколько скриптов из отдельных файлов. В этом случае в конце одного файла может быть
			опущена точка с запятой и это автоматически приведет к проблеме, если второй файл начинается с вызова функции на месте.

			Поэтому, всегда-всегда ставьте точку с запятой перед вызовом функции на месте, даже если вы на данный момент уверены, 
			что проблем не будет. Они могут возникнуть потом. 

			Применим сказанное выше и вызовем функцию на месте, поставив в начале точку с запятой:
				;(function() {
					console.log(1); // выведет 1
				})(); 

		Замыкания и вызов функции на месте в JavaScript:

			Как вы уже знаете, можно вызвать анонимную функцию на месте и присвоить результат работы какой-либо переменной:
				let result = function() {
					return '!';
				}();

				console.log(result); // выведет '!'

			Часто функцию, вызывающую на месте, в таком случае берут в круглые скобки, хотя в этом и нет нужды.
			Это делается для того, чтобы сразу было видно, что функция вызывается на месте:
				let result = (function() {
					return '!';
				})();

				console.log(result); // выведет '!'

			Пусть теперь результатом вызванной на месте функции будет анонимная функция:
				let func = (function() {
					return function() {
						console.log('!');
					}
				})();

				func(); // выведет '!'

			Давайте сделаем так, чтобы возвращаемая функция хранила в замыкании переменную num:
				let func = (function() {
					let num = 1;
					
					return function() {
						console.log(num);
					}
				})();

			Если добавить еще num++, то функция func станет готовым счетчиком:
				let func = (function() {
					let num = 1;
					
					return function() {
						console.log(num);
						num++;
					}
				})();

				func(); //выведет 1
				func(); //выведет 2
				func(); //выведет 3
				func(); //выведет 4
				func(); //выведет 5

		Работа с рекурсией в JavaScript:

			В программировании есть такое понятие, как рекурсия - это когда функция вызывает сама себя. Давайте 
			посмотрим на примере. Выведем с помощью рекурсии числа от 1 до 10:
				let i = 1;

				function func(){
					console.log(i);
					i++;
					
					if (i <= 10){
						func(); // здесь функция вызывает сама себя
					}
				}
				func();	

			Давайте обсудим, как работает этот код.

			У нас есть глобальная переменная i и функция func, внутри которой в консоль выводится содержимое переменной i,
			а затем делается ++. 

			Если наша переменная i меньше или равна 10, то функция вызывается повторно. Так как переменная i - 
			глобальная, то при каждом новом вызове функции в ней будет заданное при предыдущем вызове значение переменной i.

			Получится, что функция будет вызывать себя до тех пор, пока i не станет больше 10. 

			Учтите, что в нашем случае нельзя функцию запустить без if - если это сделать, то получится 
			бесконечный вызов функциий.
	
		Пример с параметром через рекурсию в JavaScript:

			Давайте, с помощью рекурсии последовательно выведем элементы массива. Пусть массив изначально передается параметром 
			функции:
				func([1, 2, 3]);

			Давайте пока без рекурсии испольщуя метод shift выведем все элементы массива по очереди:
				function func(arr) {
					console.log(arr.shift()); // выведет 1
					console.log(arr); // выведет [2, 3] - массив уменьшился
					
					console.log(arr.shift()); // выведет 2
					console.log(arr); // выведет [3] - массив уменьшился
					
					console.log(arr.shift()); // выведет 3
					console.log(arr); // выведет [] - массив пуст
				}

				func([1, 2, 3]);

			Как вы видите, метод shift вырезает и возврашает первый элемент массива, при этом сам массив уменьшается на этот 
			момент.

			Давайте теперь используем рекурсию:
				function func(arr) {
					console.log(arr.shift(), arr);
					
					if (arr.length != 0) {
						func(arr);
					}
				}

				func([1, 2, 3]);

			На самом деле, конечно же проще всего перебирать элементы массива циклом. Приведенные примеры пока просто 
			демонстрируют работу рекурсии на простых примерах (не жизненных). Более полезные примеры применения рекурсии 
			просто более сложные, мы их разберем чуть ниже.  

		Сумма элементов массива при рекурсии в JavaScript:

			Давайте теперь не будем выводить элементы массива в консоль, а найдем сумму элементов этого массива:
				function getSum(arr) {
					let sum = arr.shift();
					
					if (arr.length !== 0) {
						sum += getSum(arr);
					}
					
					return sum;
				}

				console.log(getSum([1, 2, 3]));

		Рекурсия и многомерные структуры в JavaScript:

			Дан массив многомерный произвольного уровня вложенности, например, такой:
				let arr = [
					1,
					[
						2, 7, 8
					],
					[
						3, 4, [5, [6, 7]],
					]
				];

			Как вы видите, данный массив имет сложную структуру, причем предполагается, что эта структура можеть быть
			произвольной и уровни вложенности могут быть сколько угодно глубоко.

			Пусть мы хотим вывести в консоль все примитивные (то есть не массивы) элементы нашего массива. В этом случае 
			для перебора такого массива у нас просто не получится использовать циклы, так как массив имеет неправильную структуру
			и неизвестный уровень вложенности. 

			Зато для перебора такого массива очень удобно будет использовать рекурсию.

			Для начала сделаем функцию, в которую параметром будет передавать наш массив, а в функции сделаем цикл для перебора 
			нашего массива:
				function func(arr) {
					for (let elem of arr) {
						console.log(elem);
					}
				}

				func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]); 

			Сделанный нами цикл будет перебирать только элементы основного массива. То есть вначале он выведет 1, потом 
			[2,7,8], а потом [3,4[5[6,7]]].

			Давайте теперь будем разделять в цикле элементы-примитивы и элементы-массивы:
				function func(arr) {
					for (let elem of arr) {
						if (typeof elem == 'object') {
							// элемент - массив
						} else {
							// элемент - примитив
							console.log(elem);
						}
					}
				}

				func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);

			А теперь сделаем так, чтобы если наш элемент - массив, функция вызывала сама себя, передавая параметром этот массив:
				function func(arr) {
					for (let elem of arr) {
						if (typeof elem == 'object') {
							func(elem);
						} else {
							console.log(elem);
						}
					}
				}

				func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]); 

		Сумма элементов массива через рекурсию в JavaScript:

			Давайте найдем сумму примитивных элементов нашего массива:
				function func(arr) {
					let sum = 0;
					
					for (let elem of arr) {
						if (typeof elem == 'object') {
							sum += func(elem);
						} else {
							sum += elem;
						}
					}
					
					return sum;
				}

				console.log(func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]));	

		Манипуляция с элементами в JavaScript:

			Давайте что-нибудь сделаем с перебираемыми элементами массива, к примеру, запишем им в конец знак '!'.
			В этом случае нам придется воспользоваться обычным циклом for, а не for-of, вот так:
				function func(arr) {
					for (let i = 0; i < arr.length; i++) {
						if (typeof arr[i] == 'object') {
							arr[i] = func(arr[i]);
						} else {
							arr[i] = arr[i] + '!';
						}
					}
					
					return arr;
				}

				console.log(func([1, [2, 7, 8], [3, 4, [5, 6]]]));	

	ЦИКЛЫ:

		Введение в циклы в JavaScript:

			В данном уроке мы начнем изучение циклов. Циклы используются для того, чтобы некоторый участок кода 
			выполнился несколько раз подряд. 

			Зачем это нужно - представим, что нам нужно возвести в квадрат 100 элементов массива. Если обращаться к каждому элементу 
			отдельно по его ключу - это займет 100 строчек кода, и для того, чтобы написать этот код, нужно будет потратить довольно много времени.

			Но это не нужно - у нас есть возможность сделать так, чтобы JavaScript за нас выполнил некоторую операцию нужное количество раз.
			Например, возвел все элементы массива в квадрат. Это и делается с помощью циклов.

			Циклы могут повторять некоторый код заданное количество раз. Каждый такой проход цикла называется итерацией цикла. 

			В циклах часто использются специальные переменные, которые каждую итерацию увеличивают свое значение на единицу.
			Такие переменные называются счетчиками циклов. Счетчики используются для того, чтобы подсчитывать, сколько раз выполнится цикл.
			Для счетчиков принято использовать буквы i, j и k.

			В следующих уроках мы приступим к изучению циклов в JavaScript.

		Цикл for в JavaScript:

			Цикл for позволяет повторить некоторый код заданное количество раз. Вот его синтаксис:
				for ( начальные команды; условие окончания; команды после прохода ) {
					тело цикла
				}

			Начальные команды - это то, что выполнится перед стартом цикла. Они выполняются только один раз. Обычно там размещают 
			начальные значения счетчиков, например i = 0.

			Условие окончания цикла - это условие, при котором цикл будет крутиться, пока оно истинное, например: i <= 10.

			Команды после прохода цикла - это команды, которые будут выполняться каждый раз при окончании прохода цикла.
			Обычно там увеличивают счетчики, например: i++.

			Давайте с помощью цикла for выведем последовательно числа от 1 до 9:
				for (let i = 1; i <= 9; i++) {
					console.log(i); // выведет 1, 2... 9
				} 

			А теперь будем увеличивать счетчик не на 1 а на 2:
				for (let i = 1; i <= 9; i += 2) {
					console.log(i); // выведет 1, 3, 5...
				}

			Можно выполнить обратный отсчет:
				for (let i = 10; i > 0; i--) {
					console.log(i); // выведет 10, 9, 8...
				}

		Цикл for для массивов в JavaScript:

			Массивы также можно перебирать циклом for. Давайте посмотрим, как это делается. Пусть у нас дан вот такой массив:
				let arr = [1,2,3,4,5];

			Выведем элементы этого массива в цикле:
				for (let i = 0; i <= arr.length - 1; i++) {
					console.log(arr[i]);
				}

			Можно не отнимать от длины массива единицу, а использовать нестрогое сравнение:
				for (let i = 0; i < arr.length; i++) {
					console.log(arr[i]);
				}

			Перебор массива через цикл for дает больший контроль за происходящим. К примеру, можно вывести элементы не с нулевого, а с первого:
				for (let i = 1; i < arr.length; i++) {
					console.log(arr[i]);
				}

			Можно вывести элементы в обратном порядке:
				for (let i = arr.length - 1; i >= 0; i--) {
					console.log(arr[i]);
				}

		Перебор массива циклом for-of в JavaScript:

			Цикл for-of позволяет перебирать элементы массивов. Он имеет следующий синтаксис:
				for (let переменнаяДляЭлемента of массив) {
					/*
						В переменнуюДляЭлемента по очереди
						будут попадать элементы перебираемого массива.
					*/ 
				}

			Давайте помотрим на примере. Пусть дан следующий массив:
				let arr = [1, 2, 3, 4, 5];

			Переберем этот массив циклом и выведем его элементы в консоль:
				for (let elem of arr) {
					console.log(elem);
				}

		Перебор объекта циклом for-in в JavaScript:

			Для перебора объектов предназначен цикл for-in. Он имеет следующий синтаксис:
				for (let переменнаяДляКлюча in объект) {
	
				}

			В переменнуюДляКлюча по очереди будут попадать ключи перебираемого объекта. Давайте попробуем на каком-нибудь
			примере. Пусть у нас дан вот такой объект.
				let obj = {a: 1, b: 2, c: 3};

			С помощью цикла for-in выведем ключи этого объекта:
				for (let key in obj) {
					console.log(key); // выведет 'a', 'b', 'c'
				}

			А теперь выведем элементы:
				for (let key in obj) {
					console.log(obj[key]); // выведет 1, 2, 3
				}

		Цикл while в JavaScript:

			Цикл while будет выполняться до тех пор, пока истинно выражение, переданное ему параметром. Он позволяет выполнять 
			произвольно количество итераций. Вот его синтаксис:
				while ( пока выражение истинно ) {
					выполняем этот код циклически;
					в начале каждого цикла проверяем выражение в круглых скобках
				} 

			Цикл закончится, когда выражение перестанет быть инстинным. Если оно было ложным изначально - то он не 
			выполнится ни разу. 

			Давайте для примера последовательно выведем с помощью цикла while число от одного до пяти:
				let i = 1;

				while (i <= 5) {
					console.log(i);
					i++;
				}

			А теперь будем делить заданое число на 2 столько раз, пока результат не станет меньше 10:
				let num = 500;

				while (num > 10) {
					num = num / 2;
				}

				console.log(num); // результат

		Условия в циклах в JavaScript:

			В циклах можно применять условия. Посмотрим на примере. Пусть у нас есть следующий массив:
				let arr = [1, 2, 3, 4, 5];

			Выведем в консоль все элементы этого массива:
				for (let elem of arr) {
					console.log(elem);
				}

			А теперь наложим условие и будем выводить только элементы, которые являются четными числами:
				for (let elem of arr) {
					if (elem % 2 === 0) {
						console.log(elem);
					}
				}

		Накопление чисел в циклах JavaScript:

			Давайте с помощью цикла найдем сумму целых чисел от 1 до 100. Для решения такой задачи в цикле перебираются числа 
			и их сумма последовательно записывается в какую то переменную:
				let res = 0;

				for (let i = 1; i <= 100; i++) {
					res = res + i;
				}	

			Можно упросить решение через оператор +=:
				let res = 0;

				for (let i = 1; i <= 100; i++) {
					res += i;
				}

				console.log(res);

		Накопление элементов массивов в циклах JavaScript:

			Давайте с помощью цикла найдем сумму элементов массива:
				let arr = [1, 2, 3, 4, 5];
				let res = 0;

				for (let elem of arr) {
					res += elem;
				}

				console.log(res); // искомая сумма

		Формирование строк через циклы в JavaScript:

			С помощью фиклов можно формировать строки. Давайте для примера сделаем строку, заполненную десятью буквами 'x':
				let str = '';

				for (let i = 0; i < 10; i++) {
					str += 'x';
				} 

			А теперь сделаем строку '12345'. Для этого будем прибавлять к нашей переменной счетчик цикла:
				let str = '';

				for (let i = 1; i <= 5; i++) {
					str += i;
				}

				console.log(str); // выведет '12345'

		Цифры числа при переборе циклом JavaScript:

			Пусть при переборе чисел мы хотим получать от этих чисел какую-нибудь цифру. К примеру, мы хотим сделать так, 
			чтобы число выводилось в консоль, если его первая цифра равно 1 или 2.

			Напоминаю, что нельзя просто так обращаться к символам числа, то есть вот так не будет работать:
				for (let i = 1; i <= 100; i++) {
					if (i[0] == 1 || i[0] == 2) { // так не будет работать
						console.log(i);
					}
				}

			Сначала необходимо преобразовать число в строку и уже тогда получать опеределенный символ полученной строки, вот так:
				for (let i = 1; i <= 100; i++) {
					let str = String(i); // преобразуем число в строку
					
					if (str[0] === '1' || str[0] === '2') {
						console.log(i);
					}
				}

		Инструкция break в JavaScript:

			Инструкция break позволяет досрочно завешить цикл. Давайте посмотрим, когда такое может пригодиться. 
			Пусть у нас есть цикл, выводящий в консоль элементы массива:
				let arr = [1, 2, 3, 4, 5];

				for (let elem of arr) {
					console.log(elem);
				}

			Перед нами стоит задача, определеить, есть ли в массиве число 3. Если есть - выведем в консоль слово 'есть' 
			(а если нет - ничего не будем делать).

			Решим нашу задачу:
				let arr = [1, 2, 3, 4, 5];

				for (let elem of arr) {
					if (elem === 3) {
						console.log('есть');
					}
				}

			Задача решена, однако есть проблема: после того, как число 3 уже найдено, массив все равно продолжает бесмыссленно перебираться
			дальше, тратя ценные ресурсы процессора и замедляя работу нашего скрипта. 

			Оптимальнее было бы сразу после нахождения числа завершить работу нашего цикла. Это можно сделать с помощью специальной инструкции
			break, позволяющей досрочно заверишть работу цикла. 

			Итак, давайте завершим цикл, как только нам встретится число 3:
				let arr = [1, 2, 3, 4, 5];

				for (let elem of arr) {
					if (elem == 3) {
						console.log('есть');
						break; // выйдем из цикла
					}
				}

			Инструкция break может завершать любые циклы: for, while и так далее.

		Инструкция countinue в JavaScript:

			Существует также инструкция countinue, запускающая новую итерацию цикла. Данная инструкция иногда может быть полезна 
			для упрощения кода, хотя практически всегда задачу можно решить и без нее. Давайте посмотрим на практическом примере.

			Пусть у нас дан массив с числами. Давайте переберем его циклом и числа, которые делятся на 2, возведем в квадрат и выведем 
			в консоль, а числа, которые делятся на 3, возведем в куб и выведем в консоль. Вот решение описанной задачи:
				let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

				for (let elem of arr) {
					let result;
					
					if (elem % 2 === 0) {
						result = elem * elem;
						console.log(result);
						
					} else if (elem % 3 === 0) {
						result = elem * elem * elem;
						console.log(result);
					}
				}  

			Как мы видим, строка console.log(result) повторяется два раза. Давайте вынесесм ее за if, вот так:
				let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

				for (let elem of arr) {
					let result;
					
					if (elem % 2 === 0) {
						result = elem * elem;
					} else if (elem % 3 === 0) {
						result = elem * elem * elem;
					}
					
					console.log(result); // вынесли вывод за условие
				}

			Теперь наш скрипт, однако работает немного не так: получится, что и для обычных элементов, не обработанных через наш if будет 
			выполняться вывод переменной result в консоль, что по условию задачи нам не нужно. 

			Поправим проблему, добавим к нашему if еще условие else, которое будет срабатывать для элементов, не делящихся на 2 или 3,
			и вызовем там инструкцию countinue, которая сразу же будет перебрасывать нас на новую итерацию цикла:
				let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

				for (let elem of arr) {
					let result;
					
					if (elem % 2 == 0) {
						result = elem * elem;
					} else if (elem % 3 == 0) {
						result = elem * elem * elem;
					} else {
						continue; // перейдем на новую итерацию цикла
					}
					
					console.log(result); // выполнится, если делится на 2 или 3
				} 

		Вложенные циклы в JavaScript:

			Циклы, работу с которыми мы уже знаем, можно вкладывать друг в друга. К примеру, решим следующую задачу: выведем на экран строку:
				111222333444555666777888999

			Тут одним циклом не обойтись - нужно запустить два вложенных друг в друга цикла: первый цикл будет перебирать числа, 
			а второй цикл будет повторять эти числа три раза. Давайте реализуем:
				for (let i = 1; i <= 9; i++) {
					for (let j = 1; j <= 3; j++) {
						document.write(i);
					}
				}

		Заполнение массива в JavaScript:

			В цикле можно заполнять массивы данными. Для этого следует использовать метод push:
				let arr = [];

				for (let i = 1; i <= 5; i++) {
					arr.push(i);
				}

				console.log(arr); // выведет [1, 2, 3, 4, 5]
			
		Изменение массива в цикле JavaScript:

			Элементы массивов можно изменять в циклах. Для этого нужно перебирать массивы обычным циклом for.
			Давайте для примера умножим элементы массива на 2:
				let arr = [1, 2, 3, 4, 5];

				for (let i = 0; i < arr.length; i++) {
					arr[i] = arr[i] * 2;
				}

				console.log(arr); // выведет [2, 4, 6, 8, 10]

			А теперь увеличим каждый элемент массива на единицу:
				let arr = [1, 2, 3, 4, 5];

				for (let i = 0; i < arr.length; i++) {
					arr[i]++;
				}

				console.log(arr); // выведет [2, 3, 4, 5, 6]

			А теперь увеличим каждый элемент массива на 5:
				let arr = [1, 2, 3, 4, 5];

				for (let i = 0; i < arr.length; i++) {
					arr[i] += 5;
				}

				console.log(arr); // выведет [6, 7, 8, 9, 10]

		Заполнение объектов через цикл в JavaScript:

			Объекты также можно заполнять данными в циклах. Давайте посмотрим на примере. Пусть у нас есть два массива:
				let keys = ['a', 'b', 'c', 'd', 'e'];
				let values = [1, 2, 3, 4, 5];

			Давайте с их помощью сделаем объект, взяв ключи для этого объекта из первого массива, а значения - из второго.
			Для этого запустим цикл и в цикле будем формировать наш объект:
				let obj = {};

				for (let i = 0; i <= 4; i++) {
					let key = keys[i];
					let value = values[i];
					
					obj[key] = value;
				}

				console.log(obj);

			Не обязательно вводить переменные для ключа и значения, можно просто поступить вот так:
				let obj = {};

				for (let i = 0; i <= 4; i++) {
					obj[keys[i]] = values[i];
				}

				console.log(obj);

		Изменение объектов через цикл в JavaScript:

			Объекты также можно изменять в цикле. Пусть, к примеру, у нас вот такой объект:
				let obj = {a: 1, b: 2, c: 3};

			Давайте переберем его циклом for-in и увеличим каждый из его элементов в 2 раза:
				for (let key in obj) {
					obj[key] = obj[key] * 2;
				}

		Работа с флагами в JavaScript:

			Сейчас мы с вами научимся работать с флагами. Флаг - это специальная переменная, которая может принимать только два значения:
			true или false. С помощью флагов можно решить задачи, проверяющие отсутствие чего-либо: к примеру, можно проверить, что в массивен
			нет элемента с определенным значением. Давайте приступим.

			Давайте решим задачу: дан массив с числами, нужно проверить, есть ли в нем элемент со значением 3 или нет.
			Если есть - выведем '+++', если нет - '---'. 

			Для начала давайте попробуем вывести '+++'. Для этого переберем все элементы нашего массива и ифом будем спрашивать -
			равен ли текущий элемент значению 3. Если равен - выведем '+++:
				let arr = [1, 2, 3, 4, 5];

				for (let elem of arr) {
					if (elem == 3) {
						console.log('+++');
					}
				} 

			Но наше решение не очень хорошее: ведь если в массиве будет не одно значение 3, а несколько, то '+++' выведется 
			несколько раз. Давайте исправим наш массив (сделаем два элемента со значением 3) и убедимся в этом:
				let arr = [1, 2, 3, 4, 3, 5];

				for (let elem of arr) {
					if (elem == 3) {
						console.log('+++'); // выведет несколько раз
					}
				}

			Поправим проблему: завершим цикл с помощью break, если элемент уже найден:
				let arr = [1, 2, 3, 4, 3, 5];

				for (let elem of arr) {
					if (elem == 3) {
						console.log('+++');
						break;  // завершим цикл
					}
				}

			Давайте теперь попробуем сделать так, чтобы, если в массиве вообще нет элементов со значениями 3, выводилось '---'.
			Распространенным заблуждением будет добавить else к нашей структуре if - в этом случае '---' будет выводиться 
			на все элементы, не являющиеся 3:
				let arr = [1, 2, 3, 4, 5];

				for (let elem of arr) {
					if (elem == 3) {
						console.log('+++'); // выведет на элементе 3
					} else {
						console.log('---'); // выведет на элементах 1, 2, 4, 5
					}
				}

			Итак, идея добавить else - плохая идея,	не рабочая. Для решения задач подобного типа (такие задачи встречаются достаточно часто)
			и используют так называемые флаги.

			Как уже упоминалось выше, флаг - это такая переменная, которая может принимать два значения: true или false. 

			Итак, давайте сделаем переменную flag с таким значением: если она равна true, то в массиве есть элемент 3, а если false,
			то такого элемента нет. 

			Изначально поставим переменную flag в значение false - то есть будем считать, что элемента 3 в массиве нет:
				let arr = [1, 2, 3, 4, 5];
				let flag = false; // считаем, что элемента 3 нету в массиве

			Затем запустим цикл с конструкцией if так, как мы делали это раньше. Если цикл обнаружит, что в массиве есть элемент 3 -
			то поставим переменную flag в значение true и выйдем из цикла с помощью break:
				let arr = [1, 2, 3, 4, 5];
				let flag = false; // считаем, что элемента 3 нет в массиве

				for (let elem of arr) {
					if (elem == 3) {
						flag = true; // элемент есть - переопределим переменную flag
						break; // выйдем из цикла
					}
				}

			Ответ на вопрос, если в массиве 3 или нет, мы можем дать только после цикла. И этот ответ у нас уже есть:
			после цикла переменная flag могла остаться false или могла сменить значение на true, если цикл обнаружил в массиве 3:
				let arr = [1, 2, 3, 4, 5];
				let flag = false;

				for (let elem of arr) {
					if (elem == 3) {
						flag = true;
						break;
					}
				}

				// тут переменная flag равна или true, или false

			Теперь после цикла мы можем сделать конструкцию if, которая посмотрит на переменную flag и выведет на экран '+++' 
			или '---':
				let arr = [1, 2, 3, 4, 5];
				let flag = false;

				for (let elem of arr) {
					if (elem == 3) {
						flag = true;
						break;
					}
				}

				if (flag === true) {
					console.log('+++');
				} else {
					console.log('---');
				}

		Советы по написанию кода циклов в JavaScript:

			По мере изучения языка сложность наших программ растет. Пришло время поговорить о том, как правильно писать код так, чтобы 
			он делал то, что мы задумали. Есть хорошая методика.

			Пусть перед нами стоит задача достаточной сложности, для реализации которой нужно написать некоторое количество строк кода.

			Неправильным подходом будет пытаться написать весь код целиком, а потом начать его проверять. В этом случае высока вероятность,
			что у нас ничего не заработает, а ошибку придется искать в большом количестве кода. 

			Правильным подходом является разбиение задачи на маленькие элементарные шаги, которые мы будем реализовывать и сразу проверять их 
			правильность. В этом случае, даже если мы где-то ошиблись, мы сразу заметим проблемы и исправим ее.

			Попробуем на практике. Пусть для примера дан массив с числами:
				let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

			Пусть перед нами стоит задача взять из этого элемента те массивы, которые делятся на 3 и найти их сумму. 

			Первым маленьким шагом можно просто перебрать элементы массива циклом и вывести их в консоль. Сделаем это, и убедимся,
			что все работает:
				for (let elem of arr) {
					console.log(elem);
				}

			Теперь отделим те элементы, которые делятся на 3. Выведем их в консоль и убедимся, что мы получаем правильные результаты:
				for (let elem of arr) {
					if (elem % 3 === 0) {
						console.log(elem); // выведет 3, 6, 9
					}
				}

			Теперь следующим шагом мы можем найти сумму искомых элементов:
				let sum = 0;

				for (let elem of arr) {
					if (elem % 3 === 0) {
						sum += elem;
					}
				}

				console.log(sum);

		Советы по отдадке кода на примере циклов в JavaScript:

			Сейчас мы научимся методике поиска ошибок в коде. Представим себе, что мы по какому-то недоразумению не следовали 
			советам из предыдущего урока и получили не работающий код. Давайте посмотрим, как найти ошибки и заставить его работать.

			Многие начинающие пользуются неправильной методикой поиска. Они берут и смотрят на код, в надежде, что заметят ошибку.
			И так пару часов. Это так не работает. 

			Правильной методикой является вывод переменных в консоль и определения, то ли там лежит, что нужно, или нет. 
			При этом начинать нужно от преполагаемого места проблемы и двигаться вверх по коду. Давайте посмотрим на практике.

			Пусть для примера перед вами стояла задача перебрать массив с двухзначными числами и найти числа, у которых первая 
			цифра на один больше второй. Пусть для простоты в массиве хранятся числа в виде строк. 

			Пусть мы решили задачу и получили следующий код:
				let arr = ['21', '32', '34', '43', '45', '54', '55'];
				let sum = 0;

				for (let elem of arr) {
					if (elem[0] === elem[1] + 1) {
						sum += elem;
					}
				}

				console.log(sum); // выдает 0

			Код отднако выдает 0. В этом случае первым делом нужно проверить, смотрим что в переменной попадает ли выполнение кода 
			в конструкции if. Выведем что-нибудь в консоль:
				let arr = ['21', '32', '34', '43', '45', '54', '55'];
				let sum = 0;

				for (let elem of arr) {
					if (elem[0] === elem[1] + 1) {
						console.log('!'); // ничего не выводит
						sum += elem;
					}
				}

			Так как в консоли ничего не появилось, это значит, что выполение кода просто не заходит в условие. Посмотрим
			своими глащами, что же мы сравниваем:
				let arr = ['21', '32', '34', '43', '45', '54', '55'];
				let sum = 0;

				for (let elem of arr) {
					console.log(elem[0], elem[1] + 1); // '2' и '11', '3' и '21' ...
					
					if (elem[0] === elem[1] + 1) {
						sum += elem;
					}
				}

				console.log(sum);
				
			В результате сразу становится видным, что второе слагаемое двухзначеное. Легко понять, что это из-за того, что 
			единица прибавляется как строка. Исправим проблему:
				let arr = ['21', '32', '34', '43', '45', '54', '55'];
				let sum = 0;

				for (let elem of arr) {
					if (+elem[0] === +elem[1] + 1) { // исправляем
						sum += elem;
					}
				}

				console.log(sum); // '021324354' 

			После исправления мы уже видим, что в переменной sum что-то появилось, хотя и некорректное. Видно, однако, 
			что там лежит то, что нам нужно, но оно сложилось в виде строк, а не чисел. Исправим проблему:
				let arr = ['21', '32', '34', '43', '45', '54', '55'];
				let sum = 0;

				for (let elem of arr) {
					if (+elem[0] === +elem[1] + 1) {
						sum += +elem; // исправляем
					}
				}

				console.log(sum); // все работает

	МНОГОМЕРНЫЕ МАССИВЫ:

		Многомерные массивы в JavaScript:

			Элементы массива могут быть не только строками и числами, но и массивами. В этом случае у нас получится массив
			массивов или многомерный массив. 

			В следующем примере массив arr состоит из трех элементов, в свою очередь являющихся массивами:
				let arr = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']];

			Перепишем в более понятно виде:
				let arr = [
					['a', 'b', 'c'],
					['d', 'e', 'f'],
					['g', 'h', 'i'],
				];

			В зависимости от уровня вложенности массивы могут быть двухерными - массив массивов, техмерными - 
			массив массивов массивов (ну и так далее - четырехмерными, пятимерными и тп).

			Приведенный выше массив является двухмерным, так как внутри одного массива расположены другие подмассивы
			и уже в этих подмассивах нет других массивов. 

			Чтобы вывести какой-либо элемемент из двухмерного массива следует писать уже не одну пару квадратных скобок, а две:
				let arr = [
					['a', 'b', 'c'],
					['d', 'e', 'f'],
					['g', 'h', 'i'],
				];

				console.log(arr[0][1]); // выведет 'b'
				console.log(arr[1][2]); // выведет 'f' 

		Трехмерный массив в JavaScript:

			Вот пример трехмерного массива:
				let arr = [
					[
						['a', 'b'],
						['c', 'd'],
					],
					[
						['e', 'f'],
						['g', 'h'],
					],
					[
						['i', 'j'],
						['k', 'l'],
					],
				];

			Для вывода элементов такого массива уже необходимо написать три квадратные скобки:
				console.log(arr[0][0][0]); // выведет 'a'
				console.log(arr[2][1][0]); // выведет 'k'

		Произвольные массивы в JavaScript:

			Многомерные массивы не обязательно должны быть такими, как мы смотрели выше. Посмотрим, например на следюущий массив:
				let arr = [['a', 'b', [1, 2, 3], [4, 5]], ['d', ['e', 'f']]];

			Как мы видим, этот массив 'неправильный'. В нем рядом с обычными элементами (например, 'a', 'b') располагаются массивы 
			([1,2,3] и [4,5]). Перепишем наш массив в более понятном виде:
				let arr = [
					[
						'a', 'b', [1, 2, 3], [4, 5],
					],
					[
						'd', ['e', 'f'],
					],
				];

		Перебор многомерных массивов в JavaScript:

			Пусть дан следующий двухмерный массив:
				let arr = [[1, 2, 3, 4, 5], [6, 7, 8], [9, 10]];

			Давайте выведем все его элементы в консоль. Для этого нам необходимо запустить два вложенных друг в друга цикла:
				let arr = [[1, 2, 3, 4, 5], [6, 7, 8], [9, 10]];

				for (let subArr of arr) {
					for (let elem of subArr) {
						console.log(elem);
					}
				}

		Перебор через обычный for в JavaScript:

			Массивы также можно перебирать не через цикл for-of, а через обычный for:
				let arr = [[1, 2, 3, 4, 5], [6, 7, 8], [9, 10]];

				for (let i = 0; i < arr.length; i++) {
					for (let j = 0; j < arr[i].length; j++) {
						console.log(arr[i][j]);
					}
				}

		Заполнение многомерных массивов в JavaScript:

			Пусть теперь мы хотим в цикле создать какой-нибудь многомерный массив с числами. Например, вот такой 
			двухмерный массив:
				[[1, 2, 3], [1, 2, 3], [1, 2, 3]]

			Решим поставленную задачу, применив два вложенных цикла. Внешний цикл будет создавать подмассивы, а внутренний - заполнять 
			эти подмассивы числами:
				let arr = [];

				for (let i = 0; i < 3; i++) {
					arr[i] = []; // создаем подмассив
					
					for (let j = 0; j < 3; j++) {
						arr[i].push(j + 1); // заполняем подмассив числами
					}
				}

				console.log(arr);

		Проблемы при заполнении многомерных массивов в JavaScript:

			Давайте рассмотрим следующий код:
				let arr = [];

				for (let i = 0; i < 3; i++) {
					arr[i] = []; // обратите внимание на эту строчку
					
					for (let j = 0; j < 3; j++) {
						arr[i].push(j + 1);
					}
				}

				console.log(arr);

			В этом коде важное место занимает создание пустого подмассива. Мы не можем опустить эту строчку, так как тогда 
			во внутреннем цикле попытка запушить данные в arr[i] выдаст ошибку. 

		Заполнение многомерных массивов по порядку в JavaScript:

			В предыдущих примерах все чисал в подмассивах были одинаковыми. Давайте теперь сделаем так, чтобы числа возрастали, 
			вот так:
				[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

			Для этого нужно сделать специальную переменную-счетчик, которая будет увеличивать свое значение на 1 при
			каждой итерации внутреннего цикла. Значение этого счетчика мы и будем записывать в массив, вот так:
				let arr = [];
				let k = 1; // счетчик

				for (let i = 0; i < 3; i++) {
					arr[i] = [];
					
					for (let j = 0; j < 3; j++) {
						arr[i].push(k); // записываем счетчик
						k++; // увеличиваем счетчик
					}
				}

				console.log(arr);

			Можно упростить код, сделав увеличение счетчика после присваивания:
				let arr = [];

				for (let i = 0, k = 1; i < 3; i++) {
					arr[i] = [];
					
					for (let j = 0; j < 3; j++) {
						arr[i].push(k++);
					}
				}

				console.log(arr);

			Обратите внимание на то, что в данном случае должно быть обязательно k++, а не ++k, так как второй вариант сначала 
			выполнит увеличение счетчика, а уже потом запись в массив (то есть в результате массив начнется с двойки, а не с единицы)
			вот так:
				[[2, 3, 4], [5, 6, 7], [8, 9, 10]]

	МНОГОМЕРНЫЕ ОБЪЕКТЫ:

		Многомерные объекты в JavaScript:

			Многомерными могут быть не только массивы, но и объекты, вот пример:
				let obj = {
					a: {
						key1: 'a1',
						key2: 'a2',
						key3: 'a3',
					},
					b: {
						key1: 'b1',
						key2: 'b2',
						key3: 'b3',
					},
					c: {
						key1: 'c1',
						key2: 'c2',
						key3: 'c3',
					},
				}

			Давайте выведем какие-нибудь элементы нашего объекта:
				console.log(obj['a']['key1']); // выведет 'a1'

			Можно также обращаться к элементам как к свойствам:
				console.log(obj.a.key1); // выведет 'a1'

			Можно комбинировать оба способа:
				console.log(obj['a'].key1); // выведет 'a1'
				console.log(obj.a['key1']); // выведет 'a1'

		Перебор многомерных объектов в JavaScript:

			Пусть дан следующий двумерный объект:
				let obj = {
					a: {
						1: 'a1',
						2: 'a2',
						3: 'a3',
					},
					b: {
						1: 'b1',
						2: 'b2',
						3: 'b3',
					},
					c: {
						1: 'c1',
						2: 'c2',
						3: 'c3',
					},
				}

			Давайте выведем все его элементы на экран. Для этого нам необходимо запустить два вложенных друг в друга цикла for-in:
				for (let key in obj) {
					let subObj = obj[key];
					
					for (let subKey in subObj) {
						console.log(subObj[subKey]);
					}
				}

		Многомерные структуры в JavaScript:

			Можно комбинировать многомерные массивы и объекты, создавая различные структуры. Давайте, к примеру, сделаем объект,
			содержащий внтури себя массивы:
				let days = {
					'ru': ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'],
					'en': ['mn', 'ts', 'wd', 'th', 'fr', 'st', 'sn'],
				};

			Выведем какие-нибудь элементы из этого объекта:
				console.log(days['ru'][0]); // выведет 'пн'
				console.log(days['en'][2]); // выведет 'wd'
			
		Перебор многомерных структур JavaScript:

			Пусть у нас дан объект со студентами:
				let students = {
					'group1': ['student11', 'student12', 'student13'],
					'group2': ['student21', 'student22', 'student23'],
					'group3': ['student31', 'student32'],
				};
						
			Давайте выведем на экран имена всех студентов, перебрав наш объект двумя вложенными циклами. 

			Как вы видите, у нас объект с массивами. Это значит, что первый цикл должен быть по объект, а второй - по массивам.
			То есть первый цикл будет for-in, а второй for-of, вот так:
				for (let group in students) {
					for (let name of students[group]) {
						console.log(name);
					}
				}  

		Массив объектов в JavaScript:

			Самой распростарненной многомерной структурой является массив объектов. У него есть некоторые особенности. Давайте их изучим.
			Пусть у нас дан вот такй массив с юзерами:
				let users = [
					{
						name: 'name1',
						surn: 'surn1',
					},
					{
						name: 'name2',
						surn: 'surn2',
					},
					{
						name: 'name3',
						surn: 'surn3',
					},
				];		

			Давайте переберем всех юзеров и выведем в кносоль их имена и фамилии. При переборе массива объектов как правило используют только один цикл 
			по массиву, а внутри него к объектам обращаются по клюам. Сделаем это:
				for (let user of users) {
					console.log(user.name + ' ' + user.surn);
				}	

		Ключи из переменных в многомерных структурах JavaScript:

			Пусть дан следующий объект:
				let obj = {
					'ru': ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'],
					'en': ['mn', 'ts', 'wd', 'th', 'fr', 'st', 'sn'],
				};

			Давайте выведем какой-нибудь элемент из нашего объекта, например элемент 'чт':
				let obj = {
					'ru': ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'],
					'en': ['mn', 'ts', 'wd', 'th', 'fr', 'st', 'sn'],
				};

				console.log(obj['ru'][3]);

			Пусть теперь язык и номер дня хранятся в переменных:
				let lang = 'ru';
				let day = 3;

			Выведем с помощью наших переменных какой-нибудь день недели:
				let obj = {
					'ru': ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'],
					'en': ['mn', 'ts', 'wd', 'th', 'fr', 'st', 'sn'],
				};

				let lang = 'ru';
				let day = 3;
				console.log(obj[lang][day]);

		Добавление элементов в многомерные массивы в JavaScript:

			Пусть у нас дан вот такой массив с юзерами:
				let users = [
					{
						name: 'name1',
						surn: 'surn1',
					},
					{
						name: 'name2',
						surn: 'surn2',
					},
					{
						name: 'name3',
						surn: 'surn3',
					},
				];

				Давайте добавим в этот массив еще одного юзера. Для этого параметром метода push передадим новый объект с юзером:
					users.push({
						name: 'name4',
						surn: 'surn4',
					}); 

		Добавление элементов в многомерные объекты в JavaScript:

			Пусть у нас дан следующий объект со студентами:
				let students = {
					'group1': ['student11', 'student12', 'student13'],
					'group2': ['student21', 'student22', 'student23'],
					'group3': ['student31', 'student32'],
				};

			Давайте добавим еще одного студента в первую группу:
				students.group1.push('student14');

			Давайте теперь сделаем еще одну, четвертую группу и добавим в нее студента. Для этого сначала обязательно нужно объявить 
			новую группу массивом:
				students.group4 = [];

			И только потом в нее добавлять студентов:
				students.group4.push('student41');

	МЕТОДЫ:

		Сепень и корень в JavaScript:
			
			Метод Math.pow возводит число в заданную степень. Первым параметром передается число, вторым - в какую степень 
			его возвести:
				Math.pow(число, степень);

			Давайте возведем число 3 в степень 4:
				console.log(Math.pow(3, 4));

			Результат выполнения кода:
				81

			Давайте возведем число 2 в степень -5:
				console.log(Math.pow(2, -5));

			Результат выполнения кода:
				0.03125

				Существует также оператор **, возводящий числа в степень:	
					console.log(3 ** 4);

				Результат выполнения кода:
					81


				Метод Math.sqrt возвращает квадратный корень числа.
					Math.sqrt(положительное число);

				Давайте возьмем квадратный корень из 4:
					console.log(Math.sqrt(4));

				Давайте получим квадратный корень из 15:
					console.log(Math.sqrt(15));

				Результат выполнения кода:
					3.872983346207417

				Давайте получим квадратный корень из -100. Так как передано отрицательное число, то будет выведен NaN:
					console.log(Math.sqrt(-100));

				Результат выполнения кода:
					NaN

		Функции округления в JavaScript:

			Math.round:

				Метод Math.round выполняет округление до ближайшего целого числа по правилам математического округления:

				Синтаксис:
					Math.round(число);

				Пример 1:

					Округлим до целых число 6.4:
						console.log(Math.round(6.4));

					Результат выполнения кода:
						6

				Пример 2:
					Округлим до целых число 6.6:
						console.log(Math.round(6.6));

					Результат выполнения кода:
						7

				Пример 3:

					Округлим до целых число 6.5:
						console.log(Math.round(6.5));

					Результат выполнения кода:
						7

				Пример 4:

					Округлим до целых число 6.49999:
						console.log(Math.round(6.49999));

					Результат выполнения кода:
						6

			Math.ceil:

				Метод Math.ceil производит округление дробного числа до целого всегда в большую сторону.

				Синтаксис:
					Math.ceil(число); 
				 
				Пример 1:

					Округлим число 3.00001 в большую сторону:
						console.log(Math.ceil(3.00001));

					Результат выполнения кода:
						4
				
			Math.floor:

				Метод Math.floor производит округление дробного числа всегда в меньшую сторону.

				Синтаксис:
					Math.floor(число);

				Пример 1:

					Округлим число 2.9999 в меньшую сторону:
						console.log(Math.floor(2.9999));

					Результат выполнения кода:
						2

			toFixed:

				Метод toFixed производит округление числа до указанного знака в дробной части. Количество знаков указывается параметром. Если число
				знаков не указано, то по умолчанию берется 0 знаков, то есть до целого числа.

				Синтаксис:
					число.toFixed([количество знаков в дробной части]);

				Пример 1:

					Пусть дана дробь. Давайте округлим ее до 3 знаков в дробной части:
						let num = 1.1111;
						console.log(num.toFixed(3));

					Результат выполнения кода:
						1.111

				Пример 2:

					В следующем примере также оставлено только 3 знака в дробной части, однако последняя цифра увеличилась на 1, 
					так как округление производится по правилам математики:
						let num = 1.1119;
						console.log(num.toFixed(3));

					Результат выполнения кода:
						1.112

				Пример 3:

					В следующем примере дробь округлится до целого числа, так как параметр метода пуст:
						let num = 1.111;
						console.log(num.toFixed());

					Результат выполнения кода:
						1

				Пример 4:

					В следующем примере параметр метода превышает количество знаков в дробной части исходной дроби,
					поэтому метод добавит две цифры 0 в конец нашей дроби:
						let num = 1.1111;
						console.log(num.toFixed(6));

					Результат выполнения кода:
						1.111100

			toPrecision:

				Метод toPrecision округляет	число до заданного знака. В отличие от Math.round окргуление можно проводить не только в дробной
				части. Параметром метода указывается сколько цифр должно остаться в числе. Остальные цифры будут отброшены. Последнее оставшееся 
				число будет округлено по правилам математического округления. Если параметр пуст, то будет возвращено исходное число. Если указанное 
				количество знаков недостижимо обрезанием десятичной дроби - переводит число в экспотенциальную форму.

				Синтаксис:
					число.toPrecision(длина);

				Пример 1:

					В данном примере число 678.19324 с помощью toPrecision приведется к 4 цифрам, причем,
					так как после 1 стоит цифра 9, то по правилам математики единица преобразуется к двойке:
						let num = 678.19324;
						console.log(num.toPrecision(4));

					Результат выполнения кода:
						678.2

				Пример 2:

					В данном примере число должно сократиться до двух знаков и будет отброшена не только дробная часть, 
					но и целая. Поэтому число переведется в экспоненциальную форму:
						let num = 678.19324;
						console.log(num.toPrecision(2));

					Результат выполнения кода:
						6.8e+2

				Пример 3:

					В данном примере число 12 приводится к 3 цифрам. Так как число целое, то в дробной части появится 0:
						let num = 12;
						console.log(num.toPrecision(3));

					Результат выполнения кода:
						12.0

				Пример 4: 

					Давайте теперь приведем число 12 к четырем цифрам. В дробной части появятся два 0:
						let num = 12;
						console.log(num.toPrecision(4));

					Результат выполнения кода:
						12.00

				Пример 5:

					Давайте теперь приведем число 12.1 к пяти цифрам:
						let num = 12.1;
						console.log(num.toPrecision(5));

					Результат выполнения кода:
						12.100

		Экстремальные числа в JavaScript:

			Math.max:

				Метод Math.max возвращает максимальное число из группы чисел, переданных в функцию. Если в функцию ничего не передано. то будет 
				возвращено -Infinity.

				Синтаксис:
					Math.max(число, число, число...);

				Пример 1:

					Давайте выведем максимальное число из группы чисел:
						console.log(Math.max(1, 5, 10, 34, 100));

					Результат выполнения кода:
						100

				Пример 2:

					Давайте выведем максимальное число из группы чисел:
						console.log(Math.max(-1, 0, -20, -56, -100));

					Результат выполнения кода:
						0

				Пример 3:

					В следующем примере выведется -Infinity, так как методу не передали параметров:
						console.log(Math.max());

					Результат выполнения кода:
						-Infinity

				Пример 4:

					По умолчанию функция не работает с массивами. Однако ее можно заставить сделать это с помощью оператора spread. 
					Давайте с его помощью выведем максимальное значение массива:
						let arr = [1, 5, 10, 34, 100];
						let max = Math.max(...arr);

						console.log(max);

					Результат выполнения кода:	
						100

				Пример 5:

					Можно также заставить функцию работать с массивами с помощью метода apply:
						let arr = [1, 5, 10, 34, 100];
						let max = Math.max.apply(null, arr);

						console.log(max);

					Результат выполнения кода:
						100

			Math.min:

				Метод Math.min возвращает минимальное число из группы чисел, переданных параметрами. Если параметрами ничего не передано, то будет возращено Infinity.

				Синтаксис:

				Пример 1:

					Давайте выведем минимальное число из группы чисел:
						console.log(Math.min(40, 20, 42, 100, 67));

					Результат выполнения кода:
						20

				Пример 2:

					Давайте выведем минимальное число из группы чисел:
						console.log(Math.min(-1, -100, -30, -25, 40));

					Результат выполнения кода:
						-100

				Пример 3:

					В следующем примере выведется Infinity, так как методу не передали параметров:
						console.log(Math.min());

					Результат выполнения кода:
						Infinity

				Пример 4:

					По умолчанию функция не работает с массивами. Однако ее можно заставить сделать это с помощью оператора spread. 
					Давайте с его помощью выведем минимальное значение массива:
						let arr = [1, 5, 10, 34, 100];
						let min = Math.min(...arr);

						console.log(min);

					Результат выполнения кода:
						1

				Пример 5:

					Можно также заставить функцию работать с массивами с помощью метода apply:
						let arr = [1, 5, 10, 34, 100];
						let min = Math.min.apply(null, arr);

						console.log(min);

					Результат выполнения кода:
						1

		Рандом в JavaScript:

			Math.random:

				Метод Math.random возвращает случайное дробное число от 0 до 1.

				Синтаксис:
					Math.random();

				Применение:

					Чтобы получить случайное число в определенном промежутке (дробное или целое) следует пользоваться специальными приемами. Получение случайоного 
					дробного числа между min и min происходит так:
						function getRandomArbitary(min, max) {
							return Math.random() * (max - min) + min;
						}

					А тепень получим случайное целое число между min и max:
						function getRandomInt(min, max) {
							return Math.floor(Math.random() * (max - min + 1)) + min;
						}

				Пример 1:

					Давайте выведем случайное число от 0 до 1:
						console.log(Math.random());

					Результат выполнения кода:
						0.5416665468657356

				Пример 2:

					Давайте выведем случайное целое число от 10 до 100:
						function getRandomInt(min, max) {
							return Math.floor(Math.random() * (max - min + 1)) + min;
						}

						console.log(getRandomInt(10, 100));

					Результат выполнения кода:
						12

		Метод charAt:

			Метод charAt возвращает символ, стоящий на указанной позиции в строке. Позиция задается параметром метода
			(нумерация начинается с нуля). Если указанная позиция больше позиции последнего символа - вернется пустая строка.

			Синтаксис:
				строка.charAt(позиция символа);

			Пример 1:

				Давайте выведем символ, стоящий на нулевой позиции:
					let str  = 'abcde';
					let char = str.charAt(0);

					console.log(char);

				Результат выполнения кода:
					'a'

			Пример 2:

				Сейчас будет выведена пустая строка, так как веденная позиция больше, чем позиция последнего символа:
					let str  = 'abcde';
					let char = str.charAt(30);

					console.log(char);

				Результат выполнения кода:
					''

		Модули в JavaScript:

			Math.abs:

				Метод Math.abs возвращает модуль числа, то есть из отрицательного делает положительное.

				Синтаксис:
					Math.abs(число);

				Пример 1:

					Давайте выведем модуль числа -3:
						console.log(Math.abs(-3));

					Результат выполнения кода:
						3

				Пример 2:

					Давайте выведем модуль числа 3:
						console.log(Math.abs(3));

					Результат выполнения кода:
						3

		Регистр символов в JavaScript:
		
			Метод toUpperCase:

				Метод toUpperCase производит преобразование строки в верхний регистр (из маленьких букв делает болшие).
				При этом возвращается новая строка, а исходная строка не меняется. 

				Синтаксис:
					строка.toUpperCase();

				Пример 1:

					Давайте преобразуем все буквы в большие:
						let str = 'abcde';
						console.log(str.toUpperCase());
					
					Результат выполнения кода:
						'ABCDE'

				Пример 2:

					Также используя метод slice можно преобразовать в верхний регистр отдельные буквы:
						let str = 'abcde';
						let res = str.slice(0, 1).toUpperCase() + str.slice(1);

						console.log(res);

					Результат выполнения кода:
						'Abcde'

			Метод toLowerCase:

				Метод toLowerCase преобразует символы строки в нижний регистр (из больших букв делает маленькие). 
				При этом мы получаем новую строку, а исходная строка остается неизменной.

				Синтаксис:
					строка.toLowerCase();

				Пример 1:

					Давайте преобразуем все большие буквы строки в маленькие:
						let str = 'ABCDE';
						console.log(str.toLowerCase());

					Результат выполнения кода:
						'abcde'

				Пример 2:

					Комбинируя метод toLowerCase и метод slice можно задать нижний регистр для отдельных частей строки:
						let str = 'ABCDE';
						let res = str.slice(0, 1) + str.slice(1).toLowerCase();

						console.log(res);

					Результат выполнения кода:
						'Abcde'

		Вырезание строк в JavaScript:

			Метод substr:

				Метод substr возвращает подстроку из строки (исходная строка при этом не изменяется). Первый параметр задает номер позиции,
				с которого метод начнет вырезать символ (нумерация идет с нуля), а второй параметр - сколько символов отрезать.

				Первый параметр может принимать отрицательные значения. В этом случае отсчет символа, с которого начинается обрезание, будет идти
				с конца строки. Последний символ имеет -1. Второй параметр не является обязательным, если он не указан, то вырезаны будут все символы 
				до конца строки.

				Синтаксис:
					строка.substr(откуда отрезать, [сколько символов отрезать]);

				Пример 1:

					Пусть дана строка. Давайте вырежем из нее первые 3 символа:
						
						let str = 'abcde';
						let sub = str.substr(0, 3);

						console.log(sub);

						Результат выполнения кода:
							'abc'

				Пример 2:

					Давайте теперь вырежем символы с 2-ой позиции и до конца строки (для этого не зададим второй параметр метода):
						let str = 'abcde';
						let sub = str.substr(2);

						console.log(sub);

					Результат выполнения кода:
						'cde'

				Пример 3:

					Давайте вырежем подстроку с 3-го символа с конца и возьмем 2 символа:
						let str = 'abcde';
						let sub = str.substr(-3, 2);

						console.log(sub);

					Результат выполнения кода:
						'cd'

				Пример 4:

					А теперь давайте вырежем подстроку с 3-го символа с конца и возьмем всю оставшуюся строку до конца 
					(для этого не зададим второй параметр метода):
						let str = 'abcde';
						let sub = str.substr(-3);

						console.log(sub);

					Результат выполнения кода:
						'cde'

				Пример 5:

					Давайте вырежем последний символ строки:
						let str = 'abcde';
						let sub = str.substr(-1);

						console.log(sub);

					Результат выполнения кода:
						'e'

			Метод substring:

				Метод substring возвращает подстроку из строки (исходная строка при этом не изменяется). Первый параметр задает номер символа, с 
				которого метод начинает отрезать (нумерация идет с нуля), а второй параметр - номер символа, на котором следует закончить вырезание
				(символ с этим номером не включается в вырезанную часть). Второй параметр не является обязательным, если он не указан, то вырезаны 
				будут все символы до конца строки.

				Синтаксис:
					строка.substring(откуда начать отрезать, [докуда отрезать]);

				Пример 1:

					Пусть дана строка. Давайте вырежем из нее символы с первого по третий:
						let str = 'abcde';
						let sub = str.substring(1, 3);

						console.log(sub);

					Результат выполнения кода (символ с номером 3 не включится в вырезанную часть):
						'bc'

				Пример 2:

					Давайте теперь вырежем символы с 1-го и до конца строки (для этого не зададим второй параметр метода):
						let str = 'abcde';
						let sub = str.substring(1);

						console.log(sub);

					Результат выполнения кода:
						'bcde'

			Метод slice:

				Метод slice возвращает подстроку из строки (исходная строка при этом не изменяется). Первым параметром указывается номер символа строки,
				с которого начинается вырезание, а вторым параметром - номер символа, на котором закончится вырезание (при этом символ с этим номером не 
				включается в вырещанную часть). Второй параметр не является обязательным. Если его не указать - подстрока возьмется	с 
				указанного в первом параметре символа до конца строки. Он также может принимать отрицательные значения. В этом случае отсчет символа,
				на котором закончится обрезание, начинается с конца строки. Последний символ имеет номер -1.

				Синтаксис:
					строка.slice(откуда отрезать, [докуда отрезать]);

				Пример 1:

					Пусть дана строка. Давайте вырежем из нее символы с первого по третий:
						let str = 'abcde';
						let sub = str.slice(1, 3);

						console.log(sub);

					Результат выполнения кода (символ с номером 3 не включится в вырезанную часть):
						'bc'

				Пример 2:

					Давайте теперь вырежем символы с 1-го и до конца строки (для этого не зададим второй параметр метода):
						let str = 'abcde';
						let sub = str.slice(1);

						console.log(sub);

					Результат выполнения кода:
						'bcde'

				Пример 3:

					Давайте теперь вырежем символы с позиции 1 по позицию -2:
						let str = 'abcde';
						let sub = str.slice(1, -2);

						console.log(sub);

					Результат выполнения кода (символ с номером -2 не включится в вырезанную часть):
						'bc'

		Поиск по строкам в JavaScript:

			Метод includes:

				Метод includes выполняет поиск заданной строки в текущей с учетом регистра. Перым параметром метод принимает строку, которую нужно 
				найти, вторым необязательным - позицию, с которой нужно начинать поиск. После выполнения метод возрващает true или false.

				Синтаксис:
					строка.includes(что ищем, [откуда начинать поиск]);

				Пример 1:

					Давайте проверим, есть ли строка 'ab' в строке 'abcde':
						let res = 'abcde'.includes('ab');
						console.log(res);

					Результат выполнения кода:
						true

				Пример 2:

					Теперь давайте проведем поиск с пятого символа текущей строки:
						let res = 'ab cd ef'.includes('cd', 5);
						console.log(res);

					Результат выполнения кода:
						false

				Пример 3: 

					Давайте сделаем поиск с учетом регистра символов строки:
						let res = 'abcde'.includes('AB');
						console.log(res);
					
					Результат выполнения кода:
						false

			Метод startsWith:

				Метод startsWith проверяет начинается ли строка с указанной в первом параметре подстроки. Если начинается, то возвращает 
				true, а если не начинается, то false. Вторым необязательным параметром метод принимает позицию, с которой начинается проверка
				(по умолчанию с начала строки).

				Синтаксис:
					строка.startsWith(что ищем, [начало проверки]);

				Пример 1:

					Проверим, начинается ли строка на заданную подстроку:
						let str = 'abcde';
						let res = str.startsWith('abc');

						console.log(res);

					Результат выполнения кода:
					 true

				Пример 2:

					Проверим, начинается ли строка на заданную подстроку:
						let str = 'abcde';
						let res = str.startsWith('xxx');

						console.log(res);

					Результат выполнения кода:
						false

				Пример 3:

					Начнем проверку с заданной позиции:
						let str = 'abcde';
						let res = str.startsWith('bc', 1);

						console.log(res);

					Результат выполнения кода:
						true

			Метод endsWith:

				Метод endsWith проверяет, заканчиватся ли строка на указанную в первом параметре подстроку. Если заканчивается, то возрвращает
				true, а елси нет - то false. Вторым необязательным параметром можно принудительно указать длину строки. В этом случае проверка будет не 
				настоящего конца строки, а указанного.

				Синтаксис:
					строка.endsWith(что ищем, [длина строки]);

				Пример 1:

					Проверим, заканчивается ли строка на заданную подстроку:
						let str = 'abcde';
						let res = str.endsWith('cde');

						console.log(res);

					Результат выполнения кода:
						true

				Пример 2:

					Проверим, заканчивается ли строка на заданную подстроку:
						let str = 'abcde';
						let res = str.endsWith('xxx');

						console.log(res);

					Результат выполнения кода:
						false

				Пример 3:		

					Принудительно зададим длину строки для проверки:
						let str = 'abcde';
						let res = str.endsWith('bc', 3);

						console.log(res);	

					Результат выполнения кода:
						true

			Метод indexOf:

				Метод indexOf осуществляет поиск подстроки в строке. В первом параметре указываем искомую подстроку в нужном нам регистре 
				(большие буквы или маленькие). Метод вернет позицию первого совпадения, а если оно не найдено, то вернет -1. Вторым необязательным 
				параметром можно передать номер символа, откуда начинать поиск.

				Синтаксис:

				Пример 1:

					Давайте найдем позицию первого вхождения подстроки:
						let str = 'ab cd cd cd ef';
						let res = str.indexOf('cd');

						console.log(res);

					Результат выполнения кода:
						3

				Пример 2:

					Давайте укажем позицию, с которой начинать поиск:
						let str = 'ab cd cd cd ef';
						let res = str.indexOf('cd', 4);

						console.log(res);

					Результат выполнения кода:
						6

				Пример 3:

					Теперь поищем несуществующую подстроку:
						let str = 'ab cd cd cd ef';
						let res = str.indexOf('xx');

						console.log(res);

					Результат выполнения кода:
						-1

				Пример 4:

					Давайте поищем подстроку, указанную в неподходящем для текущей строки регистре:
						let str = 'ab cd cd cd ef';
						let res = str.indexOf('CD');

						console.log(res);

					Результат выполнения кода:
						-1

			Метод lastIndexOf:

				Метод lastIndexOf осуществляет поиск последнего вхождения подстроки в строке. При этом необходимо обращать внимание на указанный 
				в первом параметре регистр символом. Поиск ведется с конца строки. Метод вернет позицию первого совпадения с конца, а если оно не 
				найдено, то вернет -1. Вторым необязательным параметром можно передать номер символа, откуда следует начать поиск.

				Синтаксис:
					строка.lastIndexOf(что ищем, [откуда начинать поиск]);

				Пример 1:

					Давайте найдем позицию последнего вхождения подстроки:
						let str = 'ab cd cd cd ef';
						let res = str.lastIndexOf('cd');

						console.log(res);

					Результат выполнения кода:
						9

				Пример 2:

					Давайте зададим позицию начала поиска:
						let str = 'ab cd cd cd ef';
						let res = str.lastIndexOf('cd', 8);

						console.log(res);

					Результат выполнения кода:
						6

		Замена частей строки в JavaScript:

			Метод replace:

				Метод replace осуществляет поиск и замену частей строки. Первым параметром принимается подстрока, которую заменяем, а вторым -
				подстрока, на которую заменяем. 

				Синтаксис:
					строка.replace(что заменяем, на что заменяем);

				Пример 1:
					
					Давайте в строке заменим 'ab' на '!':
						let str = 'abcde';
						let newStr = str.replace('ab', '!');

						console.log(newStr);

					Результат выполнения кода:
						'!cde'

				Пример 2:

					Давайте попробуем заменить все совпадения в строке:
						let str = 'ab cde ab';
						let newStr = str.replace('ab', '!');

						console.log(newStr);

					Мы увидим, что замена произошла только в первом совпадении:
						'! cde ab'

				Пример 3:

					Несмотря на то, что метод replace меняет только первое совпадение, можно заменить все совпадения с помощью цикла:
						let elem = 'ab';
						let str = 'ab cde ab';

						while (str.includes(elem)) {
							str = str.replace(elem, '!');
						}

						console.log(str);

					Результат выполнения кода:
						'! cde !'

		Части строк в JavaScript:

			Метод split:

				Метод split разбивает строки в массив по указанному в первом параметре разделителю. Если он не задан - вернется вся строка. 
				Если он задан как пустые кавычки, то каждый символ строки попадет в отдельный элемент массива. Вторым необязательным параметром
				можно указать максимальное количество элементов в получившемся массиве.

				Синтаксис:
					строка.split([разделитель], [максимальное количество элементов]);

				Пример 1:

					Пусть дана некоторая строка с дефисами. Давайте разобьем эту строку в массив по разделителю '-':
						let str = 'ab-cd-ef';
						let arr = str.split('-');

						console.log(arr);

					Результат выполнения кода:
						['ab', 'cd', 'ef']

				Пример 2:

					Давайте опять разобьем строку по разделителю '-', однако вторым параметром укажем максимальное количество 
					элементов в получившемся массиве, например, 2. В этом случае в массив запишется только 2 элемента:
						let str = 'ab-cd-ef';
						let arr = str.split('-', 2);

						console.log(arr);

					Результат выполнения кода:
						['ab', 'cd']

				Пример 3:

					Давайте каждый символ строки запишем в отдельный элемент массива:
						let str = 'abcde';
						let arr = str.split('');

						console.log(arr);

					Результат выполнения кода:
						['a', 'b', 'c', 'd', 'e']

				Пример 4:

					Давайте первые 3 символа строки запишем в отдельные элементы массива:
						let str = 'abcde';
						let arr = str.split('', 3);

						console.log(arr);

					Результат выполнения кода:
						['a', 'b', 'c']

				Пример 5:

					Давайте с помощью split разобьем строку с числами. Обратите внимание на то, что в результате получится массив строк, а не массив чисел:
						let str = '12345';
						let arr = str.split('');

						console.log(arr);

					Результат выполнения кода:
						['1', '2', '3', '4', '5']

				Пример 6:

					Давайте перевернем символы строки в обратном порядке. Для этого разобьем строку в массив с помощью split по разделителю '' 
					(это разместит каждый символ строки в отдельный элемент массива), перевернем этот массив с помощью reverse и затем 
					сольем перевернутый массив обратно с помощью join:
						let str = '123456789';
						let arr1 = str.split('');
						let arr2 = arr1.reverse();
						let res = arr2.join('');

						console.log(res);

					Результат выполнения кода:
						'987654321'

				Пример 7: 

					Упростим решение предыдущей задачи - сольем все команды в цепочку:
						let str = '123456789';
						let res = str.split('').reverse().join('');

						console.log(res);

					Результат выполнения кода:
						'987654321'

				Пример 8:

					Дана строка с цифрами. Найдем сумму цифр из этой строки. Для этого разобьем строку в массив, а затем переберем этот массив и найдем его сумму. 
					Нас ждет подвох: split возвращает строки, поэтому при суммировании преобразуем эти цифры-строки в настоящие числа с помощью Number:
						let str = '12345';
						let arr = str.split('');
						let sum = 0;

						for (let i = 0; i < arr.length; i++) {
							sum += Number(arr[i]);
						}

						console.log(sum);

					Результат выполнения кода:
						15

				Пример 9:

					Дано число. Давайте запишем каждую цифру этого числа в отдельный элемент массива. Тут есть подвох - split применяется только к строкам, а у нас число. 
					Преобразуем вначале число к строке с помощью String, а затем применим split:
						let num = 12345;
						let str = String(num);
						let arr = str.split('');

						console.log(arr);

					Результат выполнения кода:
						['1', '2', '3', '4', '5']

			Метод join:

				Метод join объединяет элементы массива в строку с указанным разделителем (он будет вставлен между элементами массива). Разделитель
				задается параметром метода и не является обязательным. Если он не задан - по умолчанию в качестве разделителя возьмется запятая.
				Если вы хотите слить элементы массива без разделителя - укажите его как пустую строку.

				Синтаксис:
					массив.join([разделитель]);

				Пример 1:

					Пусть дан некоторый массив. Давайте объединим элементы этого массива в строку с разделителем '-':
						let arr = [1, 2, 3];
						let str = arr.join('-');

						console.log(str);

					Результат выполнения кода:
						'1-2-3'

				Пример 2:

					А теперь давайте не укажем разделитель и по умолчанию разделителем станет запятая:
						let arr = [1, 2, 3];
						let str = arr.join();

						console.log(str);
					
					Результат выполнения кода:
						'1,2,3'

				Пример 3:

					Давайте сольем элементы массива без всякого разделителя:
						let arr = [1, 2, 3];
						let str = arr.join('');

						console.log(str);

					Результат выполнения кода:
						'123'

				Пример 4:

					Давайте перевернем символы строки в обратном порядке. Для этого разобьем строку в массив с помощью split по разделителю '' 
					(этот разделитель положит каждый символ строки в отдельный элемент массива), перевернем этот массив с помощью reverse и затем сольем перевернутый 
					массив обратно с помощью join:
						let str = '123456789';
						let arr1 = str.split('');
						let arr2 = arr1.reverse();
						let res = arr2.join('');

						console.log(res);

					Результат выполнения кода:
						'987654321'

				Пример 5:

					Упростим решение предыдущей задачи - сольем все команды в цепочку:
						let str = '123456789';
						let res = str.split('').reverse().join('');

						console.log(res);

					Результат выполнения кода:
						'987654321'

				Пример 6:

					Дана дата в формате '2025-12-31'. Давайте сделаем из нее формат '31.12.2025'. Для этого разобьем строку в массив с помощью split, 
					перевернем этот массив с помощью reverse и затем сольем перевернутый массив обратно с помощью join:
						let date = '2025-12-31';
						let res = date.split('-').reverse().join('.');

						console.log(res);
					
					Результат выполнения кода:
						'31.12.2025'

		Граничные элементы в JavaScript:

			Метод shift:

				Метод shift удаляет первый элемент из массива. При этом исходный массив изменяется, а результатом метода возвращается удаленный 
				элемент.

				Синтаксис:
					массив.shift();

				Пример 1:

					Давайте удалим первый элемент из массива:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						arr.shift();

						console.log(arr);

					Результат выполнения кода:
						['b', 'c', 'd', 'e']

				Пример 2:

					Давайте удалим первый элемент из массива и выведем его на экран:
						let arr  = ['a', 'b', 'c', 'd', 'e'];
						let elem = arr.shift();

						console.log(elem);

					Результат выполнения кода:
						'a'

				Пример 3:

					Давайте сделаем из массива строку '16-25-34'. Для решения задачи используем комбинацию методов shift, pop, push и join:
						let arr = ['1', '2', '3', '4', '5', '6'];
						let res = [];

						while (arr.length > 0) { // массив уменьшается в цикле пока не достигнет нуля
							let first = arr.shift();
							let last  = arr.pop();
							let str = first + last; // тут будет строка '16', потом '25', потом '34'
							res.push(str);
						}

						// После цикла в res лежит массив ['16', '25', '34']. Сольем его в строку:
						res = res.join('-');
						console.log(res);

					Результат выполнения кода:
						'16-25-34'

			Метод pop:

				Метод pop удаляет последний элемент из массива. При этом исзодный массив изменяется, а результатом метода возвращается удаленный 
				элемент. 

				Синтаксис:
					массив.pop();

				Пример 1:

					Давайте удалим из массива последний элемент:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						arr.pop();

						console.log(arr);

					Результат выполнения кода:
						['a', 'b', 'c', 'd']

				Пример 2:

					Давайте выведем последний элемент, который был удален из исходного массива:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						let del = arr.pop();

						console.log(del);
					
					Результат выполнения кода:
						'e'

				Пример 3:

					Давайте сделаем из массива строку '16-25-34'. Для решения задачи используем комбинацию методов pop, shift, push и join:
						let arr = ['1', '2', '3', '4', '5', '6'];
						let res = [];

						while (arr.length > 0) { // массив уменьшается в цикле пока не достигнет нуля
							let first = arr.shift();
							let last = arr.pop();
							let str = first + last; // тут будет строка '16', потом '25', потом '34'
							res.push(str);
						}

						// После цикла в res лежит массив ['16', '25', '34']. Сольем его в строку:
						res = res.join('-');
						console.log(res);

					Результат выполнения кода:
						'16-25-34'

			Метод push: 

				Метод push добавляет неограниченное количество элементов в конец массива. При этом исходный массив изменяется, а результатом 
				возвращается новая длина массива.

				Синтаксис:
					массив.push(элемент, элемент, элемент...);

				Пример 1:

					Давайте в конец массива добавим еще два новых элемента:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						arr.push('1', '2');

						console.log(arr);

					Результат выполнения кода:
						['a', 'b', 'c', 'd', 'e', '1', '2']

				Пример 2:

					Добавим в массив два новых элемента и выведем новую длину массива:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						let length = arr.push('1', '2');

						console.log(length);

					Результат выполнения кода:
						7

				Пример 3:

					Заполним массив числами от 1 до 9:
						let arr = [];

						for (let i = 1; i <= 9; i++) {
							arr.push(i)
						}

						console.log(arr);
					
					Результат выполнения кода:
						[1, 2, 3, 4, 5, 6, 7, 8, 9]

			Метод unshift:

				Метод inshift добавляет неограниченное количетсво новых элементов в начало массива. При этом исходный массив изменяется, а результатом 
				возвращается новая длина массива. 

				Синтаксис:
					массив.unshift(элемент, элемент, элемент...);

				Пример 1:

					Давайте в начало массива добавим еще два новых элемента и выведем измененный массив:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						arr.unshift('1', '2');

						console.log(arr);

					Результат выполнения кода:
						['1', '2', 'a', 'b', 'c', 'd', 'e']

				Пример 2:

					Давайте добавим два новых элемента и выведем новую длину массива:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						let length = arr.unshift('1', '2');

						console.log(length);

					Результат выполнения кода:
						7

		Вырезание массивов в JavaScript:

			Метод splice:

				Метод splice удаляет или добавляет элементы в массив. Можно только удалять элементы, только добавлять элементы или делать и то и 
				другое одновременно. Метод очень универсальный и сложный для понимания. Метод изменяет сам массив и возвращает при этом массив
				удаленных элементов. 

				Первым параметром метод принимает номер элемента массива, который нужно удалить. Вторым параметром - сколько элементов массива следует 
				удалить. Если его поставить в 0, то элементы удалены не будут (только добавлены новые). Дальше через запятую идут элементы, которые 
				нужно добавить в массив (являются необязательными параметрами). Эти элементы добавляются вместо удаленных элементов массива.

				Если удаления не было (когда второй параметр 0) - элементы вставятся в массив начиная с той позиции, которая указана первым параметром метода.
				Первый параметр может иметь отрицательное значение. В этом случае отсчет позиции начнется не с начала массива. а с конца. Последний элемент
				при этом будет иметь номер -1.

				Синтаксис:
					массив.splice(откуда удаляем, сколько удаляем, [вставить], [вставить]...);

				Пример 1:
					Давайте удалим три элемента, начиная с первого:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						arr.splice(1, 3);

						console.log(arr);

					Результат выполнения кода:
						['a', 'e']

				Пример 2:

					Давайте выведем массив удаленных элементов:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						let del = arr.splice(1, 3);

						console.log(del);

					Результат выполнения кода:
						['b', 'c', 'd']

				Пример 3:

					Давайте сначала удалим элемент с номером 2, а потом вместо него вставим еще три новых элемента:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						arr.splice(2, 1, '1', '2', '3');

						console.log(arr);

					Результат выполнения кода:
						['a', 'b', '1', '2', '3', 'd', 'e']

				Пример 4:

					Давайте теперь ничего не будем удалять, но на позицию 2, вставим еще три новых элемента:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						arr.splice(2, 0, '1', '2', '3');

						console.log(arr);

					Результат выполнения кода:
						['a', 'b', '1', '2', '3', 'c', 'd', 'e']

				Пример 5:

					Давайте удалим предпоследний элемент:
						let arr = ['a', 'b', 'c', 'd', 'e'];
						arr.splice(-2, 1);

						console.log(arr);
					
					Результат выполнения кода:
						['a', 'b', 'c', 'e']

		Массив ключей объекта в JavaScript:

			Метод Object.keys:

				Метод Object.keys возвращает массив из свойств объекта в том же порядке, как и при перечислении через цикл.

				Синтаксис:
					let keys = Object.keys(объект);

				Пример 1:

					Давайте получим свойства из следующего объекта:
						let obj = {'a': 1, 'b': 2, 'c': 3};
						console.log(Object.keys(obj));

					Результат выполнения кода:	
						['a', 'b', 'c']

				Пример 2:

					А теперь поставим свойства в объекте в случайном порядке:
						let obj = {2: 'b', 1: 'a', 4: 'd', 3: 'c'};
						console.log(Object.keys(obj));

					После выполнения кода мы увидим, что свойства отсортировались в порядке возрастания:
						['1', '2', '3', '4']

				Пример 3:

					Также с помощью метода Object.keys можно получить позиции элементов массива:
						let arr = ['a', 'b', 'c', 'd'];
						console.log(Object.keys(arr));

					Результат выполнения кода:
						['0', '1', '2', '3']

		Метод concat для строк:	

			Метод concat соединяет указанные строки. Количество строк для объединения не ограничено. По сути действие этого 
			метода аналогично операции '+' для слияния строк.

			Синтаксис:
				строка.concat(еще строка, и еще строка, и еще...);
			
			Пример 1:
				
				Давайте с помощью метода concat сольем три строки в одну:
					let str1 = 'a';
					let str2 = 'b';
					let str3 = 'c';
					let res = str1.concat(str2, str3);

					console.log(res); 

				Результат выполнения кода:
					'abc'

			Пример 2:

				Можно применить метод к пустой строке. В этом случае все сливаемые строки передадутся параметрами метода:
					let str1 = 'a';
					let str2 = 'b';
					let str3 = 'c';
					let res = ''.concat(str1, str2, str3);

				Результат выполнения кода:
					'abc'

		Метод concat для массивов:

			Метод concat сливает указанные массивы в один большой массив. Метод применяется к одному из массивов,
			а в параметрах метода передаются остальные массивы для слияния. При этом метод не изменяет исходный массив,
			а возвращает новый.

			Синтаксис:
				массив.concat(еще массив, и еще массив, и еще...);

			Пример 1:

				Давайте сольем 3 массива в один с помощью метода concat:	
					let arr1 = [1, 2];
					let arr2 = [3, 4];
					let arr3 = [5, 6];
					let res = arr1.concat(arr2, arr3);

					console.log(res);

				Результат выполнения кода:
					[1, 2, 3, 4, 5, 6]

			Пример 2:

				А теперь давайте сольем два массива вместе:
					let arr1 = [1, 2];
					let arr2 = [3, 4];
					let res = arr1.concat(arr2);

					console.log(res);

				Результат выполнения кода:
					[1, 2, 3, 4]

			Пример 3:

				Можно передавать не только массивы, но и конкретные значения:
					let arr1 = [1, 2];
					let arr2 = [3, 4];
					let res = arr1.concat(arr2, 5, 6);

					console.log(res);

				Результат выполнения кода:
					[1, 2, 3, 4, 5, 6]

			Пример 4:

				Можно применить метод к пустому массиву. В этом случае все сливаемые массивы передадутся параметрами метода:
					let arr1 = [1, 2];
					let arr2 = [3, 4];
					let arr3 = [5, 6];
					let res = [].concat(arr1, arr2, arr3);

					console.log(res);

				Результат выполнения кода:

		Метод map:

			Метод map позволяет применить заданную функию для каждого элемента массива. При этом метод не изменяет исходный массив,
			а возвращает измененный.

			Метод в параметре получает функцию, которая выполнится для каждого элемента массива. То, что вернет эта функция через
			return для элемента массива, станет новым значением этого элемента.

			В функцию можно передавать 3 параметра. Если эти параметры есть (они не обязательны), то в первый автоматически
			попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.

			Синтаксис:

				let новый массив = массив.map(function(элемент, индекс, массив) {
					код
					return измененный элемент;
				});

			Пример 1:

				Создадим массив, каждый элемент которого вдвое больше соотвествующего элемента начального массива:
					let arr = [1, 2, 3, 4, 5];

					let res = arr.map(function(elem) {
						return elem * 2;
					});

					console.log(res); 

				Результат выоплнения кода:
					[2, 4, 6, 8, 10]

			Пример 2:

				Создаем массив, каждый элемент которого получается так - значение элемента умножается на его порядковый номер в массиве:
					let arr = [1, 2, 3, 4, 5];

					let res = arr.map(function(elem, index) {
						return elem * index;
					});

					console.log(res);

				Результат выполнения кода:
					[0, 2, 6, 12, 20]

			Пример 3:

				При необходимости в третий параметр можно передать сам массив:
					let arr = [1, 2, 3, 4, 5];

					let res = arr.map(function(elem, index, arr) {
						тут будет доступен массив arr
					});

			Ключ элемента:

				Функция колл-бек тоже может принимать второй параметр - в него JavaScript разместит ключ элемента массива.

				Давайте посмотрим на примере. Пусть дан вот такой массив:
					let arr = ['a', 'b', 'c', 'd', 'e'];

				Давайте в конец каждого элемента запишем его порядковый номер в массиве:
					let arr = ['a', 'b', 'c', 'd', 'e'];

					let result = arr.map(function(elem, index) {
						return elem + index;
					});

					console.log(result); // выведет ['a0', 'b1', 'c2', 'd3', 'e4']  

			Перебор многомерных массивов:

				Метод map можно использовать и для перебора многомерых массивов. Пусть к примеру, дан вот такой массив:
					let arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

				Давайте переберем этот массив через map и выведем его элементы в консоль:
					let arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

					let result = arr.map(function(elem) {
						console.log(elem);
					});

				В результате console.log выведет [1,2,3], потом [4,5,6], потом [7,8,9].

				Как вы видите в переменную elem попадают подмассивы. Давайте теперь применим метод map к каждому подмассиву
				и возведем каждый его элемент в квадрат:
					let arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

					let result = arr.map(function(elem) {
						return elem.map(function(num) {
							return num * num;
						});
					});

					console.log(result);

		Метод forEach:

			Метод forEach позволяет последовательно перебрать все элементы массива. Метод в параметре получает функцию, которая 
			выполнится для каждого элемента массива. 

			В эту функцию можно передать три параметра. Если эти параметры есть (они не обязательны). то в первый автоматически пойдет 
			элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.

			Синтаксис:
				массив.forEach(function(элемент, индекс, массив) {
					код, который выполнится для всех элементов
				});

			Пример 1:

				Давайте выведем все элементы массива в консоль:
					let arr = [1, 2, 3, 4, 5];

					arr.forEach(function(elem) {
						console.log(elem);
					});

			Пример 2:

				Давайте выведем элементы их и номера в консоль:
					let arr = ['a', 'b', 'c', 'd', 'e'];

					arr.forEach(function(elem, ind) {
						console.log(elem, ind);
					});

			Пример 3:

				Давайте найдем сумму элементов массива:
					let arr = [1, 2, 3, 4, 5];
					let sum = 0;

					arr.forEach(function(elem) {
						sum += elem;
					});

					console.log(sum);

				Результат выполнения кода:
					15

		Метод filter:

			Метод filter позволяет отфильтровать элементы массива, оставив только подходящие под определенное условие элементы.
			Метод в параметре получает функцию, которая выполнится для каждого элемента массива. Своим результатом метод 
			возвращает новый массив, в который войдут только те элементы, для которых переданная функция вернет true.

			В функцию можно передавать три параметра. Если параметры есть (они не обязательны), то в первый автоматически попадет
			элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.

			Синтаксис:
				let новый массив = массив.filter(function(элемент, индекс, массив) {
					код
					return true или false
				});

			Пример 1:

				Давайте отфильтруем массив, оставив в нем только положительные числа:
					let arr = [-2, 5, 1, -5, -1, 1, 3, 4, -1];

					let res = arr.filter(function(elem) {
						if (elem >= 0) {
							return true;
						} else {
							return false;
						}
					});

					console.log(res);

				Результат выполнения кода:
					[5, 1, 1, 3, 4]

			Пример 2:

				Сократим код, воспользовавшись стрелочной функцией:
					let arr = [-2, 5, 1, -5, -1, 1, 3, 4, -1];

					let res = arr.filter(elem => {
						if (elem >= 0) {
							return true;
						} else {
							return false;
						}
					});

					console.log(res);

				Результат выполнения кода:
					[5, 1, 1, 3, 4]

			Пример 3:

				Сократим код, воспользовавшись сокращением логических операций:
					let arr = [-2, 5, 1, -5, -1, 1, 3, 4, -1];

					let res = arr.filter(elem => {
						return elem >= 0;
					});

					console.log(res);

				Результат выполнения кода:
					[5, 1, 1, 3, 4]

			Пример 4:

				Сократим код, воспользовавшись особенностями стрелочных функций:
					let arr = [-2, 5, 1, -5, -1, 1, 3, 4, -1];
					let res = arr.filter(elem => elem > 0);

					console.log(res);

				Результат выполнения кода:
					[5, 1, 1, 3, 4]

			Пример 5: 

				При необходимости в третий параметр можно передать сам массив:
					let res = arr.filter(function(elem, index, arr) {
						тут будет доступен массив arr
					});

		Метод every:

			Проверяет элементы массива в соответствии с переданной функцией. Метод возвращает true, если для всех элементов
			массива переданная функция вернет true, в противном случае метод возвращает false.

			В функцию можно передать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически
			попадет элемент массива, во второй попадет его номер в массиве (индекс), а третий - сам массив.

			Синтаксис:
				массив.every(function(элемент, индекс, массив) {
					return true или false;
				});

			Пример 1:

				Проверим, что все элементы в массиве чисел положительные:
					let arr = [1, 2, 3, 4, 5];

					let check = arr.every(function(elem) {
						if (elem >= 0) {
							return true;
						} else {
							return false;
						}
					});

					console.log(check);

				Результат выполнения кода:
					true

			Пример 2:

				Проверим, что произведение элемента на его порядковый номер всегда меньше 30:
					let arr = [1, 2, 3, 4, 5];

					let check = arr.every(function(elem, index) {
						if (elem * index < 30) {
							return true;
						} else {
							return false;
						}
					});

				Результат выполнения кода:
					true

			Пример 3:

				При необходимости можно передать сам массив:
					let check = arr.every(function(elem, index, arr) {
						тут будет доступен массив arr
					});
 
		Метод some:

			Следующий метод some проверяет элементы массива и возвращает true, если хотя бы для одного элемента 
			коллбэк вернул true, в противном случае метод возвращает false. 

			Проверим, к примеру что в массиве есть хотя бы одно четное число:
				let arr = [2, 4, 6, 8];

				let result = arr.some(function(elem) {
					return elem % 2 == 0;
				});

				console.log(result);

			Упростим:
				let arr = [2, 4, 6, 8];

				let result = arr.some(elem => elem % 2 == 0);
				console.log(result);

		Метод find:

			Метод find помогает найти первый элемент в массиве согласно переданному в параметре коллбэку. Если элемента нет,
			то возвращается undefined. 

			Синтаксис:
				массив.find(функция);

			Пример 1:

				Давайте найдем элемент массива, соответствующий условиям, прописанным в функции:
					let arr = [1, 2, 3, 4];

					let res = arr.find(function(currentValue) {
						return currentValue > 0;
					});

					console.log(res);

				Результат выполнения кода:
					1

			Пример 2:

				Давайте найдем элемент массива, длина которого равна 2:
					let arr = ['abc', 'defg', 'kl', 'mn'];

					let res = arr.find(function(elem) {
						return elem.length == 2;
					});

					console.log(res);

				В результате выполнения кода мы увидим, что метод нашел первый элемент, подходящий к условиям функции:
					'kl'
			
		Метод findLast:

			Метод findLast ищет первый элемент с конца массива согласно переданному в параметре коллбэку. Если элемента нет, 
			то в результат возвращается undefined.

			Синтаксис:
				массив.findLast(функция);

			Пример 1:

				Давайте найдем элемент массива, соответсвтующий условиям, прописанным в функции:
					let arr = [1, 2, 3, 4, 5];

					let res = arr.findLast(function(elem) {
						return elem > 0;
					});

					console.log(res);

				Результат выполнения кода:
					5

		Метод findIndex:

			Метод findIndex позволяет найти индекс первого элемента согласно переданному в параметре коллбэку. Если элемент
			не найден, то возвращается -1.

			Синтаксис:
				массив.findIndex(функция);

			Пример 1:

				Давайте найдем индекс первого четного элемента в массиве:
					let arr = [1, 2, 3, 4, 5];

					let res = arr.findIndex(function (elem){
						return elem % 2 == 0;
					});

					console.log(res);

				Результат выполнения кода:
					1

			Пример 2:

				А теперь давайте зададим такие условия в функции, которым не будет соответствовать ни один элемент в 
				массиве:
					let arr = [1, 2, 3, 4, 5];

					let res = arr.findIndex(function (elem){
						return elem < 0;
					});

					console.log(res);

				Результат выполнения кода:
					-1

		Метод findLastIndex:

			Метод findLastIndex помогает найти индекс первого элемента с конца массива, соответствующий условию согласно 
			переданному в параметре коллбэку. Если элемента нет, то возвращается undefined.

			Синтаксис:
				массив.findLastIndex(функция);
			
			Пример 1:

				Давайте найдем индекс полоэительного числа в массиве:
					let arr = [-12, -13, 14, 15];

					let res = arr.findLastIndex(function(elem) {
						return elem > 0;
					});

					console.log(res);

				Результат выполнения кода:
					3

			Пример 2:

				А теперь давайте найдем индекс элемента, которого нет в массиве:
					let arr = ['a', 'b', 'c', 'd'];

					let res = arr.findLastIndex(function(elem) {
						return elem === 'f';
					});

					console.log(res);

				Результат выполнения кода:
					-1

		Метод reduce:	

			Метод reduce сворачивает массив к одному значению (редуцирует). К примеру с помощью этого метода можно
			легко найти сумму элементов массива (то есть массив сведется к одному значению - к сумме элементов).

			Первым параметром метод reduce получает функцию, которая последовательно выполнится для каждого элемента 
			массива, начиная с первого. В эту функцию можно передавать 4 параметра. Если эти параметры есть 
			(они не обязательны), то в первый автоматически попадет промежуточный результат, во второй попадет 
			элемент массива, в третий - его номер в массиве, а в четвертый сам массив.

			Промежуточный результат - это переменная, в которой будет накапливаться то значение, которое вернет метод reduce,
			когда переберет все элементы массива. К примеру, туда последовательно можно накапливать сумму элементов массива:
			сначала положить первый элемент, при следующем проходе цикла уже сумму первого элемента и второго, при следующем 
			проходе - сумму первого, второго и третьего. И так, пока массив не закончится. Функция, которую принимает reduce, 
			должна возвращать новое значение промежуточного результата.

			Вторым параметром метода reduce указывается начальное значение промежуточного результата. Если его не указать, 
			то оно будет равно первому элементу массива, а обработка элементов начнется со второго элемента.

			Синтаксис:
				массив.reduce(function(промежуточный результат, элемент, индекс, массив) {
					return новый промежуточный результат;
				}, начальное значение);

			Пример 1:

				Давайте найдем сумму элементов массива:
					let arr = [1, 2, 3, 4, 5, 6];

					let res = arr.reduce(function(sum, elem) {
						return sum + elem;
					}, 0);

					console.log(res);

				Результат выполнения кода:
					21				

			Пример 2: 

				Давайте найдем сумму всех положительных чисел массива:
					let arr = [1, -2, -3, 4, 5, -6];

					let res = arr.reduce(function(sum, elem) {
						if (elem >= 0) {
							return sum + elem;
						} else {
							return sum;
						}
					});

					console.log(res);

				Результат выполнения кода:
					10

		Метод reduceRight:	

			Метод reduceRight работает точно также как и reduce. Единственное отличие: reduce перебирает элементы
			слева направо, а reduceRight - справа налево.

			Синтаксис:
				массив.reduceRight(function(промежуточный результат, элемент, индекс, массив) {
					return новый промежуточный результат;
				}, начальное значение);

			Пример 1:

				Давайте найдем сумму элементов массива:

					let arr = [1, 2, 3, 4, 5, 6];

					let res = arr.reduceRight(function(sum, elem) {
						return sum + elem;
					}, 0);

					console.log(res);

				Результат выполнения кода:
					21

			Пример 2:

				Давайте сольем двумерный массив в одномерный:

					let arr = [['a', 'b'], ['c'], ['d', 'e']];

					let res = arr.reduceRight(function(elem1, elem2) {
						return elem1.concat(elem2);
					}, []);

					console.log(res);

				Результат выполнения кода:
					['d', 'e', 'c', 'a', 'b']

		Методы для атрибутов в DOM:

			Метод getAttribute:

				Метод getAttribute считывает знаение атрибута у тега.

				Синатксис:
					элемент.getAttribute(имя атрибута);

				Пример 1:

					Давайте выведем содержимое атрибута value элемета:
						<input id="elem" value="abcde">


						let elem = document.querySelector('#elem');
						let value = elem.getAttribute('value');

						console.log(value);

					Результат выполнения кода:
						'abcde'

			Метод setAttribute:

				Метод setAttribute позволяет изменять значение заданного атрибута какого либо тега.

				Синтаксис:
					элемент.setAttribute(имя атрибута, новое значение);

				Пример 1:

					Давайте элементу поменяем значение атрибута value:
						<input id="elem" value="abcde">
						let elem = document.querySelector('#elem');
						elem.setAttribute('value', '!!!');

					HTML код станет выглядеть так:
						<input id="elem" value="!!!">

			Метод removeAttribute:

				Метод removeAttribute удаляет заданный атрибут у какого-либо тега.

				Синтаксис:
					элемент.removeAttribute(имя атрибута);

				Пример 1:

					Давайте для примера удалим атрибут value:

						<input id="elem" value="abcde">
						let elem = document.querySelector('#elem');
						elem.removeAttribute('value');

					HTML код станет выглядеть так (исчезнет атрибут value):
						<input id="elem">

			Метод hasAttribute:

				Метод hasAttribute проверяет наличие заданного атрибута у элемента. Если атрибут есть - 
				выведет true, если нет - выведет false.

				Синтаксис:
					элемент.hasAttribute(имя атрибута);

				Пример 1:

					Давайте проверим наличие атрибута value у элемента:
						<input id="elem" value="abcde">
						let elem = document.querySelector('#elem');
						console.log(elem.hasAttribute('value'));

					Результат выполнения кода:
						true

				Пример 2:

					А теперь атрибута value нет:
						<input id="elem">
						let elem = document.querySelector('#elem');
						console.log(elem.hasAttribute('value'));

					Результат выполнения кода:
						false

			Метод classList:

				Свойство classList содержит псевдомассив CSS классов элемента, а также позволяет добавлять и удалять классы элемента, 
				проверять наличие отпределенного класса среди классов элемента.

				Речь идет об атрибуте class, внутри которого можно писать несколько классов через пробел, например www ggg zzz. 
				С помощью classList можно удалить, к примеру, класс ggg, не затронув остальные классы.

				Синтаксис:
					элемент.classList;

				Пример 1. Количество классов:

					Узнаем количество классов элемента:
						<p id="elem" class="www ggg zzz"></p>

						let elem = document.querySelector('#elem');

						let length = elem.classList.length;
						console.log(length);

					Результат выполнения кода:
						3

				Пример 2. Перебираем классы:	

					Выведем по очереди классы элемента:
						<p id="elem" class="www ggg zzz"></p>


						let elem = document.querySelector('#elem');
						let classNames = elem.classList;

						for (let className of classNames) {
							console.log(className);
						}

					Результат выполнения кода:
						'www'
						'ggg'
						'zzz'

			Метод add объекта classList:

				 Метод add объекта classList позволяет добавлять css классы элементу.

				 Синтаксис:
				 	элемент.classList.add(класс);

				 Пример 1:
				 	
						Добавим элементу класс kkk:
							<p id="elem" class="www ggg zzz"></p>


							let elem = document.querySelector('#elem');
							elem.classList.add('kkk');

						Результат выполнения кода:
							<p id="elem" class="www ggg zzz kkk"></p>

				 Пример 2:

					Добавим элементу класс zzz, который уже есть в элементе - ничего не произойдет, так как дубли классов 
					не добавляются:
						<p id="elem" class="www ggg zzz"></p>


						let elem = document.querySelector('#elem');
						elem.classList.add('zzz');

					Результат выполнения кода:
						<p id="elem" class="www ggg zzz"></p>
				
			Метод remove объекта classList:	

				Метод remove объекта classList удаляет заданный CSS класс элемента.

				Синтаксис:
					элемент.classList.remove(класс);

				Пример 1:

					Удалим класс ggg:
						<p id="elem" class="www ggg zzz"></p>


						let elem = document.querySelector('#elem');
						elem.classList.remove('ggg');

					Результат выполнения кода:
						<p id="elem" class="www zzz"></p>

			Метод contains объекта classList:

				Метод contains объекта classList проверяет наличие CSS класса элемента.

				Синтаксис:
					элемент.classList.contains(класс);

				Пример 1:

					Проверим, есть ли у элемента класс ggg:
						<p id="elem" class="www ggg zzz"></p>


						let elem = document.querySelector('#elem');

						let contains = elem.classList.contains('ggg');
						console.log(contains);

					Рзультат выполнения кода:
						true

			Метод toggle объекта classList:

				Метод toggle объекта classList чередует заданный CSS класс элемента: добавляет класс, если его нет и удаляет, если есть.

				Синтаксис:
					элемент.classList.toggle(класс);
				
				Пример 1:

					В данном примере при использовании метода toggle класс zzz удалится, так как он уже есть в элементе:
						<p id="elem" class="www ggg zzz"></p>


						let elem = document.querySelector('#elem');
						elem.classList.toggle('zzz');

					Результат выполнения кода:
						<p id="elem" class="www ggg"></p>

				Пример 2:

					В данном примере при использовании метода toggle класс zzz добавится, так как его нет в элементе:
						<p id="elem" class="www ggg"></p>


						let elem = document.querySelector('#elem');
						elem.classList.toggle('zzz');

					Результат выполнения кода:
						<p id="elem" class="www ggg zzz"></p>

	ДЕСТРУКТУРИЗАЦИЯ:

		Деструктуризация массивов в JavaScript:

			В данном уроке мы с вами разберем операцию деструктуризации массивов. Данная операция предназначена для 
			массовой записи элементов массива в переменные в одну строчку кода.

			Синтаксис этой операции такой:
				let [переменная1, переменная2, переменная3] = массив;

			Как вы видите, слева от знака = в квадратных скобках перечисляются имена переменных. Эти переменные массово
			объявляются через let, который располагается перед открывающейся скобкой. 

			В результате операции в первую переменную запишется первый элемент массива (то есть с ключом ноль), 
			во вторую переменную - второй, в третью переменную - третий.

			Давайте посмотрим на практическом примере. Пусть у нас есть массив, хранящий год, месяц и день:
				let arr = [2025, 12, 31];

			Давайте запишем год, месяц и день в соответствующие переменные, испольщуя деструктуризацию:
				let arr = [2025, 12, 31];
				let [year, month, day] = arr;

			Посмотрим на содержимое этих переменных:
				console.log(year);  // выведет 2025
				console.log(month); // выведет 12
				console.log(day);   // выведет 31

			Для сравнения посмотрите, насколько неудобным и длинным получится код без деструктуризации:
				let arr = [2025, 12, 31];

				let year  = arr[0];
				let month = arr[1];
				let day   = arr[2];

				console.log(year);  // выведет 2025
				console.log(month); // выведет 12
				console.log(day);   // выведет 31

		Деструктуризация массива из функции в JavaScript:

			Массив для деструктуризации не обязательно должен храниться в переменной. Он также может быть результатом 
			работы функции. Посмотрим на примере. Пусть дана вот такая функция:
				function func() {
					return [2025, 12, 31];
				}

			Деструктуризируем возвращение этой функцией значение:
				let [year, month, day] = func();

		Пропуск элементов массива при деструктуризации в JavaScript:

			Можно начать записывать в переменные не сначала массива, а пропустить некоторые значения. Давайте к примеру,
			пропустим год, а месяц и день запишем в переменные. Для этого при указании переменных перед первой переменной
			поставим запятую, вот так:
				let arr = [2025, 12, 31];
				let [, month, day] = arr;

				console.log(month); // выведет 12
				console.log(day);   // выведет 31

			Можно пропустить не одно значение, а несколько:
				let arr = [2025, 12, 31];
				let [,, day] = arr;

				console.log(day);   // выведет 31

		Лишние значения при деструктуризации массива в JavaScript:

			Если в массиве меньше элементов, чем в переменных, то в "лишние" переменные запишется undefined:
				let arr = [2025, 12];
				let [year, month, day] = arr;

				console.log(year);  // выведет 2025
				console.log(month); // выведет 12
				console.log(day);   // выведет undefined	

			Если в массиве больше элементов, чем переменных - лишние элементы никуда не запишутся и ничего страшного не 
			произойдет. Для примера добавим в наш массив еще часы, минуты и секунды - от этого ничего не поменяется:
				let arr = [2025, 12, 31, 23, 59, 59];
				let [year, month, day] = arr;

				console.log(year);  // выведет 2025
				console.log(month); // выведет 12
				console.log(day);   // выведет 31

		Остаток массива при деструктуризации в JavaScript:

			Если в массиве больше элементов, чем переменных, при необходимости лишние элементы можно записать 
			в массив с помощью оператора rest:
				let arr = [2025, 12, 31, 23, 59, 59];
				let [year, month, day, ...time] = arr;

				console.log(year);  // выведет 2025
				console.log(month); // выведет 12
				console.log(day);   // выведет 31

				console.log(time);  // выведет [23, 59, 59] 

		Значения по умолчанию при деструктуризации массива в JavaScript:

			Для переменных можно указывать значения по умолчанию. В этом случае, если переменной не хватит элемента 
			массива - возьмется значение по умолчанию. В следующем примере переменной day по умолчанию указано значение
			1:
				let arr = [2025, 12];
				let [year, month, day = 1] = arr;

				console.log(year);  // выведет 2025
				console.log(month); // выведет 12
				console.log(day);   // выведет 1

			А вот если для переменной day будет значение в массиве - значение по умолчанию будет проигнорировано:
				let arr = [2025, 12, 31];
				let [year, month, day = 1] = arr;

				console.log(year);  // выведет 2025
				console.log(month); // выведет 12
				console.log(day);   // выведет 31

		Функции по умолчанию при деструктуризации массива в JavaScript:

			В качестве значения по умолчанию можно также указывать функцию. Пусть, к примеру, у нас есть функция,
			возвращающая текущий день недели:
				function func() {
					return (new Date).getDate();
				}

			Давайте укажем эту функцию в качестве значения переменной day:	
				let [year, month, day = func()] = arr;

		Объявление переменных при деструктуризации массива в JavaScript:

			Не обязательно объявлять переменные при деструктуризации. Они могут быть объявлены заранее и тогда при 
			присваивании не нужно будет писать команду let:
				let arr = [2025, 12, 31];
				let year;
				let month;
				let day;

				[year, month, day] = arr;

			Есть, однако, нюансы. Посмотрим на следующий код:
				let arr = [2025, 12, 31];
				let year;

				let [year, month, day] = arr;

			Как вы видите, переменная year была объявлена заранее, но переменные month и day - нет. Поэтому автор 
			кода решил написать let перед деструктуризирующим присваиванием.

			Это, однако, приведет к ошибке, так как нельзя одну и ту же переменную объявлять два раза через let 
			(получится, что year была объявлена два раза).

		Деструктуризация объектов в JavaScript:

			Можно делать и деструктуризацию объектов. Пусть, к примеру, у нас есть следующий объект:
				let obj = {
					year:  2025,
					month: 12,
					day:   31,
				};

			Давайте выполним его деструктуризацию:
				let obj = {
					year:  2025,
					month: 12,
					day:   31,
				};

				let {year, month, day} = obj;

				console.log(year);  // выведет 2025
				console.log(month); // выведет 12
				console.log(day);   // выведет 31

			При деструктуризации объектов имена переменных должны совпадать с ключами объекта, порядок переменных и 
			элементов в объекте не имеет значения.
			
		Имена переменных при деструктуризации объектов в JavaScript:

			Можно сделать так, чтобы имена переменных не совпадали с именами ключей объекта:
				let obj = {
					year:  2025,
					month: 12,
					day:   31,
				};

				let {year: y, month: m, day: d} = obj;

				console.log(y); // выведет 2025
				console.log(m); // выведет 12
				console.log(d); // выведет 31

		Значения по умолчанию при деструктуризации объектов в JavaScript:

			При деструктуризации объектов можно также указывать значение по умолчанию. При этом, в отличии от 
			деструктуризации массивов, необязательной может быть любая переменная - не обязательно с конца массива.
			Давайте, например, укажем значение по умолчанию для переменной year:
				let obj = {
					month: 12,
					day:   31,
				};

				let {year = 2025, month, day} = obj;

				console.log(year);  // выведет 2025
				console.log(month); // выведет 1
				console.log(day);   // выведет 31

		Переменные и значения по умолчанию в JavaScript:

			Можно также менять названия переменных на свои, при этом задавая значения по умолчанию:
				let obj = {
					month: 12,
					day:   31,
				};

				let {year:y = 2025, month, day} = obj;

				console.log(y);     // выведет 2025
				console.log(month); // выведет 1
				console.log(day);   // выведет 31	

		Объявление переменных при деструктуризации объектов в JavaScript:

			Не обязательно объявлять переменные при деструктуризации. Они могут быть объявлены заранее:	
				let obj = {
					year:  2025,
					month: 12,
					day:   31,
				};

				let year, month, day; // объявим переменные заранее

			Тут, однако, в отличии от массивов, свои нюансы. Без команды let перед фигурными скобками эти фигурные 
			скобки не будут восприняты JavaScript как команда на деструктуризацию (а будут восприняты как блок кода):
				{year, month, day} = obj; // не будет работать

			Для решения проблемы команду на деструктуризацию объекта нужно брать в круглые скобки:
				({year, month, day} = obj);

		Деструктуризация параметров функций в JavaScript:

			Деструктуризация имеет еще одну очень важную область примения - передача параметров функций. 
			Суть в следующем: если функция принимает в качестве параметра массив, мы можем задать прямо в объявлении
			функции то, как деструктуризировать этот массив.

			Давайте посмотрим на примере. Пусть у нас есть функция, параметром принимающая массив с годом, месяцем и 
			днем:	
				func([2025, 12, 31]);
			
			Давайте прямо в параметре укажем, на какие переменные следует разбивать этот массив:
				function func([year, month, day]) {
					console.log(year);  // выведет 2025
					console.log(month); // выведет 12
					console.log(day);   // выведет 31
				}

			Приведенную выше конструкцию следует рассматривать как один параметр функции. Можно при желании 
			добавить еще параметры:
				func('str1', [2025, 12, 31], 'str2');

				function func(param1, [year, month, day], param2) {
					console.log(param1); // выведет 'str1'
					
					console.log(year);   // выведет 2025
					console.log(month);  // выведет 12
					console.log(day);    // выведет 31
					
					console.log(param2); // выведет 'str2'
				}
			
			А в следующем примере первым и вторым параметром функции передаются массивы и мы деструктуризируем оба их 
			них:
				func([2025, 12, 31], [2026, 11, 30]);

				function func([year1, month1, day1], [year2, month2, day2]) {
					console.log(year1);  // выведет 2025
					console.log(month1); // выведет 12
					console.log(day1);   // выведет 31
					
					console.log(year2);  // выведет 2026
					console.log(month2); // выведет 11
					console.log(day2);   // выведет 30
				}

		Деструктуризация объектов параметров функций в JavaScript:

			Аналогичным образом можно деструктурировать параметры-объекты:
				function func({year, month, day}) {
					console.log(year);  // выведет 2025
					console.log(month); // выведет 12
					console.log(day);   // выведет 31
				}

				func({year: 2025, month: 12, day: 31,});

	ВРЕМЯ:

		Работа с объектом Date в JavaScript:

			Сейчас мы с вами начнем изчать работу с датами в JavaScript. Для этого нам понадобится объект Date, 
			с помощью которого в JavaScript можно осуществлять различные манипуляции с датами.

			Объект с датой создается так:
				new Date();

			Давайте запишем созданный объект в какую-то переменную, к примеру, в переменную date:
				let date = new Date();

			После проделанной операции переменная date будет представлять собой объект, хранящий в себе текущий момент 
			времени (секунду, минуту, час и так далее).

			Используя этот объект с помощью специальных методов мы можем получить нужные нам характеристики времени, 
			например текущий час, текущий день, или текущий месяц.

			К примеру, текущий час можно получить так: date.getHours(), а текущий месяц - вот так date.getMonth().
			Смотрите все варианты: 
				let date = new Date();

				console.log(date.getFullYear()); // год
				console.log(date.getMonth());    // месяц
				console.log(date.getDate());     // день

				console.log(date.getHours());    // часы
				console.log(date.getMinutes());  // минуты
				console.log(date.getSeconds());  // секунды

			Учтите, что месяц, который возвращает метод getMonth, начинается с нуля - январь нулевой, февраль первый и так далее.

		Форматирование даты в JavaScript:

			Давайте теперь научимся выводить дату в определенном формате. Пусть к примеру, мы хотим вывести на экран 
			текущие день, месяц и год в формате год-месяц-день.

			Давайте сделаем это:
				let date = new Date();
				console.log(date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate());

			Наш код, однако, имеет проблему: номера месяцев будут начинаться с нуля, а нам, скорее всего, хотелось бы,
			чтобы они начинались с единицы.

			Исправим проблему:
				let date = new Date();
				console.log(date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate());

			Наш код, однако, все равно не совершенен. Но заметить это можно только в определенные месяцы и в определенные
			дни. Пусть, к примеру, сейчас 5-го марта 2020 года. 

			В этом случае наша дата выведется в формате 2020-3-5. А нам хотелось бы, чтобы дата вывелась в формате 
			2020-03-05 - с нулями перед номерами дней и месяцев одной цифры. 

			Для решения проблемы напишем функцию addZero, которая будет добавлять нули перед числами от 0 до 9:
				function addZero(num) {
					if (num >= 0 && num <= 9) {
						return '0' + num;
					} else {
						return num;
					}
				}

			Применим созданную функцию и теперь действительно получим дату в нужном нам формате:
				let date = new Date();

				console.log(
					addZero(date.getFullYear()) + '-' + 
					addZero(date.getMonth() + 1) + '-' +
					addZero(date.getDate())
				);

		Смена формата даты в JavaScript:

			Давайте теперь научимся менять формат даты. Пусть, к примеру, у нас есть строка с датой в формате 
			год-месяц-день. Давайте поменяем формат этой даты на другой, к примеру, на такой: день/месяц/год.

			Давайте решим задачу на конкретном примере. Пусть в переменной date лежит дата '2025-12-31'. Давайте
			преобразуем эту дату в '31/12/2025'. 

			Для решения задачи разобьем нашу строку '2025-12-31' в массив, используя метод split() с разделителем 
			дефисом. В результате в нулевом элемене массив окажется год, в первом - месяц, во втором - день:
				let str = '2025-12-31';
				let arr = str.split('-');
				console.log(arr); // получим массив ['2025', '12', '31']

			Теперь, обращаясь к разным элементам массива, по их ключам, сформируем нужную нам строку:
				let str = '2025-12-31';
				let arr = str.split('-');
				let res = arr[2] + '/' + arr[1] + '/' + arr[0];

				console.log(res); // получим строку '31/12/2025'

			Можно также использовать split, reverse и join:
				let str = '2025-12-31';
				let res = str.split('-').reverse().join('/');

				console.log(res); // получим строку '31/12/2025'

		Получение дня недели на JavaScript:

			С помощью объекта Date можно также получить номер текущего дня недели. Делается это с помощью метода getDay.
			Этот метод возвращает числа от 0 до 6, причем неделя начинается с воскресенья и этот день имеет номер 0.
			Понедельник - это день номер 1, вторник - номер 2 и так далее. 

			Давайте посмотрим работу метода getDay на примере. Пусть к примеру, сегодня вторник. Тогда следующий
			код выведет число 2:
				let date = new Date();
				console.log(date.getDay());

		Вывод частей даты словом в JavaScript:

			Вы уже умеете выводить день недели в виде числа с помощью метода getDay. Зачастую, однако, нам нужен не 
			номер дня недели, а его текстовое название. Давайте напишем код, который будет преобразовывать числа, 
			возвращаемые методом getDay, в соответсвтующие названия дня недели.

			Для начала напишем код, который будет выводить номер текущего дня недели:
				let date = new Date();
				let day = date.getDay();

				console.log(day);  

			А теперь доработаем этот код так, чтобы на экран выводился не номер дня недели, а его название (для краткости
			воскресенье будет 'вс', понедельник 'пн' и так далее).

			Для решения задачи составим массив дней недели days и начнем его с воскресенья (так как это нулевой день):
				let days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];

			Как с помощью этого массива вывести на экран, к примеру 'вт'? Нужно передать в квадратных скобках номер этого 
			дня (вторник имеет номер 2):
				let days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];
				console.log(days[2]); // выведет 'вт' 	

			Однако, мы не хотим передавать день недели вручную, а хотим чтобы JavaScript сам определил текущий 
			день и вывел его название. Для этого нужно совместить то, что возвращает метод getDay, и нащ массив days:
				let date = new Date();
				let day  = date.getDay();
				let days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];

				console.log(days[day]);

		Установка времени в объекте Date в JavaScript:

			Когда мы с вами создавали объект с датой вот таким образом: new Date(), - мы оставляли круглые скобки пустыми.
			В этом случае мы получали текущий момент времени.

			Можно, однако, поступить и по-другому - передать ему параметра в формате new Date(год, месяц, день, часы, 
			минуты, секунду, милисекунды) и в этом случае в переменую date запишется не текущий момент времени, а тот, 
			который мы указали в параметрах. При этом при передаче параметром отсчет времени начинается с нуля.

			Параметры можно опускать с конца. При этом отсутсвующие параметры для милисекунд, секунд и часов считаются 
			равными нулю, а для дней единице. Год и месяц опускать нельзя.

			Давайте создадим объект с датой на определенный момент времени:
				let date = new Date(2025, 10, 5, 12, 59, 59);

			Возможность задания момента времени можно использовать, например, для того, чтобы узнать день недели за
			определенную дату:
				let date = new Date(2025, 10, 5); // установим 5 ноября 2025 года
				let day  = date.getDay();
				let days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];

				console.log(days[day]); 	

		Получение времени в формате timestamp в JavaScript:

			При работе с датой сущесвует специальный формат timestamp, который в JavaScript показывает количество 
			миллисекунд, прошедшее с 1-го января 1970 года по текущий (или заданный момент времени).

			Существует специальный метод getTime, с помощью которого можно получить время в формате timestamp.
			Давайте, например, получим текущий момент времени в этом формате:
				let date = new Date();
				console.log(date.getTime());
 
			Получим заданный момент времени в формате timestamp:
				let date = new Date(2015, 11, 4, 23, 59, 59);
				console.log(date.getTime());

		Разность между датами в формате timestamp в JavaScript:

			Формат timestamp предназначен для нахождения разницы между датами. Давайте для примера получим разницу
			в миллисекундах между текущими и заданным моментом времени:
				let now  = new Date();
				let date = new Date(2015, 11, 4, 23, 59, 59);

				let diff = now.getTime() - date.getTime();
				console.log(diff); 	

			Очевидно, что чаще всего нам нужна разница не миллисекундах, а в днях или в годах. Для этого просто нужно 
			перевести миллисекунды в нужное нам значение.

			Например, чтобы перевести миллисекунды в секунды, нужно миллисекунды поделить на 1000, чтобы секунды перевести
			в минуты, нужно секунды поделить на 60 и так далее.

			Давайте, например, переведем разницу между датами в минуты:
				console.log(diff / (1000 * 60));

			А теперь - в часы:
				console.log(diff / (1000 * 60 * 60));

		Разница между объектами с датой в JavaScript:

			В предыдущих уроках для нахождения разницы между датами мы исопльзовали формат timestamp. Однако,
			на самом деле, в JavaScript это не обязательно: даты, представленные в виде объекта Date, можно вычитать
			друг из друга, и результат их вычитания - разница в миллисекундах.

			Для примера давайте выведем количество миллисекунд, которые прошли с 25 мая 2015 года, 12:59:59 по настоящий 
			момент времени:
				let now  = new Date();
				let date = new Date(2015, 4, 25, 12, 59, 59);

				let diff = now - date; // вычитаем два объекта с датами друг от друга
				console.log(diff);     // увидим разницу в миллисекундах	 

		Автоматическая корректировка дат в JavaScript:

			JavaScript имеет очень интересную и полезную особенность: если при создании объекта Date был указан 
			некорректный момент времени - он автоматически будет перемчитан в корректный. Давайте посмотрим на примере.

			Как вы знаете, даты 35 января не существует. Максимально возможный день января - 31. Получается, что наша 
			дата 35 января имеет 4 лишних дня. JavaScript в таком случае просто прибавит эти лишние 4 дня к следующему 
			месяцу:
				let date = new Date(2018, 0, 35);
				console.log(date); // получится 4 февраля	

			Можно указывать не только лишние дни, но и месяцы. При этом следует помнить, что месяцы начинаются с нуля, а 
			значит последний корректный месяц - 11-ый. Если указать 12-ый месяц, то получится январь следующего года:
				let date = new Date(2018, 12, 1); // указываем 12-тый месяц
				console.log(date); // получится 1 января 2019 года

			Описанная корректировка работает и в меньшую сторону. Как вы знаете, самым минимальным днем месяца является 
			день с номером 1. Поэтому, если указать день с номером 0, то получится последний день предыдущего месяца:
				let date = new Date(2018, 1, 0); // указываем нулевой день
				console.log(date); // получится 31 января 

			Можно также указывать отрицательные значения дней и месяцев. При этом нужно помнить, что минимельный день 
			имеет номер 1, а минимальный месяц - номер 0. Это значит, что минус первый день попадает во 2 день с конца 
			предыдущего месяца, а минус первый месяц попадает просто в последний месяц предыдщуего года:
				let date = new Date(2018, 1, -1); // указываем -1 день
				console.log(date); // получится 30 января

				let date = new Date(2018, -1, 1); // указываем -1 месяц
				console.log(date); // получится 1 декабря 2017 года

			Все сказанное выше аналогично работает с часами, минутами и секундами:
				let date = new Date(2018, 0, 1, 24, 0, 0); // указываем 24-тый час
				console.log(date); // получится 2 января, 0 часов

				let date = new Date(2018, 0, 1, 25, 0, 0); // указываем 25-тый час
				console.log(date); // получится 2 января, 1 час

		Нахождение последнего дня месяца в JavaScript:

			Используем изученную нами раннее автоматическую корректировку дат, чтобы легко решить нашу задачу. 
			Ведь в JavaScript последний день месяца - это нулевой день следующего месяца.

			Для примера определим количество дней в марте 2020 года. Для этого при создании объекта с датой укажем 
			нулевой день апреля (он имеет номер 3, так как нумерация месяцев с нуля):
				let date = new Date(2020, 3, 0);
				console.log(date.getDate());  

		Определение високосного года в JavaScript:

			Используя полученные раннее приемы, мы можем легко определить для любого года, високосный он или нет:
			просто необходимо узнать, сколько дней в феврале. Для этого нам нужно взять нулевой день марта:
				let date = new Date(2020, 2, 0);
				console.log(date.getDate()); // выведет 29, тк 2020 год - високосный

			Усовершнествуем наш код так, чтобы тип года выводился текстом:
				let date = new Date(2020, 2, 0);

				if (date.getDate() == 29) {
					console.log('високосный');
				} else {
					console.log('обычный');
				}

		Проверка корректности даты в JavaScript:

			Давайте теперь научимся проверять дату на корректность. Например, 31 января - это корректная дата, а 32 
			января - некорректная. Как вы знаете, JavaScript автоматически корректирует даты. В нашем случае это значит, 
			что 32 января автометически станет 1 февраля. 

			Такое свойство JavaScript можно использовать для того, чтобы проверить дату на существование. Как будем 
			проверять: создадим объект с датой и проверим, поменялись даты или нет. Другими словами, выполнил ли 
			JavaScript корректировку нашей даты или нет. Если выполнил - значит переданная нами дата некорректна, а если 
			не выполнил - корректна. 

			Давайте сделаем описанное:
				let year  = 2025;
				let month = 0;
				let day   = 32;

				let date = new Date(year, month, day);

				if (date.getFullYear() == year && date.getMonth() == month && date.getDate() == day) {
					console.log('корректна');
				} else {
					console.log('некорректна');
				}  		

		Получение дня текущего года в JavaScript:

			Давайте получим объект с датой, содержащий 8-е марта текущего года. Под словами текущий год имеется ввиду, 
			что скрипт должен работать в любом году, всегда получая тот год, который сейчас на планете.

			Для этого нам нужно сделать еще один вспопогательный объект с датой, содержащей текущий момент времени. 
			С помощью этого объекта мы сможем получить текущий год, а затем использовать этот год при создании объекта
			с желаемой нами датой, вот так:
				let now  = new Date(); // получаем текущий момент
				let date = new Date(now.getFullYear(), 2, 8); // получаем нашу дату

			Полученный момент времени мы можем использовать, например, для того, чтобы определить день недели 
			соответствующей дате:
				console.log(date.getDay());

		День следующего или предыдущего месяца в JavaScript:

			Давайте узнаем день недели первого числа предыдущего месяца. Для этого от текущего месяца отнимем единицу:
				let now = new Date();

				let date = new Date(now.getFullYear(), now.getMonth() - 1, 1);
				console.log(date.getDay());

		День следующего или предыдущего года:

			Давайте получим объект с датой, содержащий 21 января следующего года. Для этого прибавим к текущему году
			единицу:
				let now  = new Date();
				let date = new Date(now.getFullYear() + 1, 0, 21);

		Разность моментов:

			Давайте найдем разность между двумя моментами времени:
				let date1 = new Date();
				let date2 = new Date(2015, 4, 25, 12, 59, 59);

				console.log(date1 - date2); // разность в миллисекундах

		Момент времени дня:

			Давайте получим объект с датой, содержащей полдень сегодняшнего дня:
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 12);

			А теперь получим полдень завтрашнего дня:
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 12);

		Начало дня в JavaScript:

			Давайте получим объект с датой, содержащей начало текущего дня:
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);

			Как вы уже знаете, параметры объекта Date можно опускать с конца. В этом случае часы, минуты и секунды 
			будут иметь значение 0. Опустим их:
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate());

			А вот день опустить нельзя, так как если он опущен, то примет значение 1, а нам нужен текущий день. 
			Опустить месяц не опуская год также нельзя по правилам работы с Date().

			Опустить одновременно год, месяц и день также нельзя - в этом случае возьмется текущий момент времени.
			Почему это плохо, ведь нам и нужен текущий год, текущий месяц и текущий день? Дело в том, что нам нужна 
			полночь, то есть часы, минуты и секунды должны иметь значение 0, а в текущем моменте времени они будут иметь 
			текущие значения, а не полночь.

		Конец дня в JavaScript:

			Давайте получим объект с датой, содержащей конец текущего дня:
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);	

			Можно посчитать концом текущего дня полночь следующего (разница в 1 секунду):
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0);

			Как вы уже знаете, нули в таком случае можно опустить:
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);

			Кстати полночью также будет являться время 24:00:00 текущего дня:
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 24, 0, 0);

			Опустим нули:
				let now  = new Date();
				let date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 24);

		Циклическая проверка моментов времени в JavaScript:

			Давайте найдем все первые числа месяцев текущего года, которые являются воскресеньем:

		Строковое сравнение дат в JavaScript:

			Пусть у нас есть две даты в следующем текстовом формате:
				let date1 = '2020-12-01';
				let date2 = '2019-12-01';

			В таком случае можно выполнять сравнение этих дат и узнать, какая из этих дат больше:
				console.log(date1 > date2); // выведет true

			Каким образом происходит сравнение этих дат? Дело в том, что наши даты представляют собой строки и JavaScript
			сравнивает их как строки. То есть он сначала сравнивает первые символы двух дат: если они одинаковы, то 
			JavaScript сравнивает вторые символы, и так далее, пока не найдет отличия. Благодаря тому, что в нашем формате
			даты сначала расположен год, потом месяц, а потом день, и возможно такое сравнение.

			Дело в том, что если цифра первого года оказывается больше цифры второго года, значит уже не имеет значения, 
			что там с месяцами и днями - первый год точно больше. Если же годы совпадают, то больше будет та дата, у 
			которой больше месяц. А если и месяцы совпадают, то больше будет та дата, у которой больше день. Ну, а если 
			и они одинаковы, то и даты равны.

			Важно также, чтобы даты были в одном формате. В нашем случае разделителем часте дат являются дефисы. Это, 
			конечно же, не обязательно. Например, можно поставить точки:
				let date1 = '2020.12.01';
				let date2 = '2019.12.01'; 

			Или убрать вообще разделители:
				let date1 = '20201201';
				let date2 = '20191201';

			Главное, чтобы сравнение было корректным, размещение должно быть следующим: сначала год, потом месяц, 
			потом день. 

		Сравнение даты без года в JavaScript:

			Необязательно сравнивать года. Дата может состоять просто из месяца и дня:	
				let date1 = '12-01';
				let date2 = '11-01';

				console.log(date1 > date2);

		Попадание даты в промежуток:

			Пусть есть три промежутка: с 1 января по 8 марта, с 9 марта по 17 июня, с 18 июня по 31 декабря. Пусть у нас
			также есть какая-то дата, содержащая месяц и день. Давайте определим, в какой промежуток попадает эта дата:
				let date = '08-20';

				if (date >= '01-01' && date <= '03-08') {
					console.log('1 промежуток');
				}

				if (date >= '03-09' && date <= '06-17') {
					console.log('2 промежуток');
				}

				if (date >= '06-18' && date <= '12-31') {
					console.log('3 промежуток');
				} 

		Сравнение объектов с датами в JavaScript:

			Можно сравнивать не только строки, но и объекты с датами. Посмотрим на примере. Пусть у нас есть два 
			объекта с датами, которые мы создали через new Date и записали в переменные. Давайте сравним, какая дата 
			больше:
				let date1 = new Date(2020, 1, 1);
				let date2 = new Date(2019, 1, 1);

				console.log(date1 > date2); // выведет true 

			Пусть теперь первая дата будет меньше второй:
				let date1 = new Date(2020, 1, 1);
				let date2 = new Date(2021, 1, 1);

				console.log(date1 > date2); // выведет false

	DOM ЭЛЕМЕНТЫ:

		ВВЕДЕНИЕ В DOM:

			Основы работы с DOM в JavaScript:

				В предыдущих уроках мы с вами изучали базовые возможности языка JavaScript. Начиная с данного урока
				ма займемся тем, для чего собственно JavaScript и предназначен - мы будем изменять элементы HTML страницы
				и реагировать на действия пользователя. Наши скрипты станут более зрелищными и полезными. 

				Во всех следующих уроках ваш JavaScript код должен быть размещен ниже HTML кода, к которому он обращается. 
				То есть структура вашего кода должна выглядеть следующим образом:
					<!DOCTYPE html>
					<html>
						<head>
							
						</head>
						<body>
							ваши html теги
							
							<script>
								ваш JavaScript код
							</script>
						</body>
					</html>

				Либо следующим образом, если вы пишите JavaScript в отдельном файле:
					<!DOCTYPE html>
					<html>
						<head>
							
						</head>
						<body>
							ваши html теги
							
							<script src="index.js"></script>
						</body>
					</html>

				В дальнейшем для краткости я не буду приводить полный код, в буду просто указывать, что нужно писать в HTML
				части, а что - в JavaScript части.  

			DOM элементы в JavaScript:

				Каждому тегу страницы в JavaScript соответствует некоторый объект со своими свойствами. В этом объекте хранится текст
				тега, значения его атрибутов, а такеж другие полезные вещи. В JavaScript такие обънекты называют DOM элементами.

				Пусть в нашем HTML коде есть следующий тег:
					<div id="elem">text</div>

				Пусть в переменной elem лежить ссылка на этот тег. В этом случае переменная elem будет объектом со свойствами id
				и textContent. Свойство id будет содержать значение атрибута id нашего тега, а свойство textContent - его текст.

				В следующем уроке мы с вами научимся получать в JavaScript ссылки на теги страницы.

			Получение DOM элемента в JavaScript:

				Сейчас мы с вами научимся получать DOM элементы страницы, чтобы в дальнейшем производить с ними какие-нибудь 
				манипуляции.

				Пусть у нас есть некоторая кнопка:
					<input id="button" type="submit">

				Давайте получим ссылку на эту кнопку в переменную. Для этого следует использовать метод querySelector специального 
				объекта document. Этот метод параметром принимает CSS селектор и возвращает ссылку на найденный по этому селектору
				элемент.

				У нашей кнопочки есть атрибут id со значением button. Значит, мы можем найти эту кнопку по селектору #button. 
				Итак, давайте найдем нашу кнопочку и запишем ссылку на нее в переменную:
					let button = document.querySelector('#button');
					console.log(button);

			Сложные селекторы DOM элемента в JavaScript:

				Давайте сделаем что-нибудь сложное. Пусть к примеру, у нас есть вот такой HTML код:
					<div id="parent">
						<input>
					</div>

				Давайте получим ссылку на инпут, находящийся внутри блока #parent:
					let elem = document.querySelector('#parent input');
					console.log(elem);

				Как вы видите, мы получили наш инпут по селектору #parent input. На самом деле под этот CSS селектор попадают все 
				инпуты, находящиеся в #parent.

				Пусть к примеру у нас два таких инпута:
					<div id="parent">
						<input value="1">
						<input value="2">
					</div>

				Тогда, если написать селектор #parent input в CSS коде, он затронет оба наших инпута:
					#parent input {
						color: red;
					}

				Метод querySelector, однако, работает не так. Он всегда получает только один элемент - первый, попавший под указанный
				селектор. Давайте посмотрим на примере. Пусть у нас есть инпуты с классом elem:
					<input class="elem">
					<input class="elem">

				Давайте получим первый из этих инпутов:
					let elem = document.querySelector('.elem');
					console.log(elem); // здесь будет первый инпут

			Привязывание обработчиков к элементам в JavaScript:

				Давайте теперь научим наши DOM элементы реагировать на действия пользователя сайта. Например, пользователь нажмет куда-либо
				мышкой, а наш код в ответ должен будет обработать это нажатие и вывести на экран какую0либо информацию. 

				Действия пользователя, которые мы можем отследить через JavaScript, называютс событиями. События могут бытть следующими:
				клик мышкой на элемент страницы, наверление мышкой на элемент страницы или наоборот - уход курсора мыши с элемента 
				и так далее. Кроме того, есть событияЮ не зависящие от действий пользователя, например событие по загрузке HTML страницы в 
				браузер.

				Давайте для примера сделаем кнопку, по нажатию неа которую на экран алертом выведется какой-то текст. 
				Для начала сделаем HTML код кнопки:
					<input id="button" type="submit">

				Получим теперь ссылку на кнопку в переменную:
					let button = document.querySelector('#button');

				Теперь нам необходимо задать реакцию нашей кнопки при клике по ней. Для этого в JavaScript существует специальный метод 
				addEventListener, первым параметром принимающий название события (клик на кропку имеет название 'click'), а вторым параметром
				функцию-коллбэк, выполняющуюся при возникновении этого события. 

				Давайте, например по клику на кнопку выведем какой-нибудь текст:
					button.addEventListener('click', function() {
						console.log('!!!');
					});

			Именованные обработчики событий в JavaScript:

				В предыдущих уроках мы с вами использовали в качестве обработчиков событий анонимные функции. Это на самом деле не 
				обязательно - функия может быть и обычной, с именем. Пусть для примера у нас есть такая функция:
					function func() {
						console.log('!!!');
					}

				Пусть также есть кнопка:
					<input id="button" type="submit">
				
				Давайте сделаем так, чтобы по клику на кнопку выполнилась наша функция func. Для этого параметром addEventListener
				передаим имя нашей функции, вот так:
					let button = document.querySelector('#button');
					button.addEventListener('click', func);

					function func() {
						console.log('!!!');
					}

			Один обработчик ко многим элементам в JavaScript:

				Одну функцию можно привзять сразу к нескольким элементам. Пусть для примера у нас есть следующая функция:
					function func() {
						console.log('!!!');
					}	

				Есть также кнопки:
					<input id="button1" type="submit" value="button1">
					<input id="button2" type="submit" value="button2">	

				Получим ссылки на эти кнопки в переменные:
					let button1 = document.querySelector('#button1');
					let button2 = document.querySelector('#button2');

				А теперь давайте привяжем нашу функцию func и к первой, и ко второй кнопке:
					button1.addEventListener('click', func);
					button2.addEventListener('click', func);

			Несколько обработчиков одного события в JavaScript:

				К одному элементу можно привязать сразу несколько функций. Давайт посмотрим на примере. Пусть у нас есть кнопка:
					<input id="button" type="submit">

				Пусть у нас есть две функции:
					function func1() {
						console.log('1');
					}

					function func2() {
						console.log('2');
					}

				Получим ссылку на нашу кнопку в переменную:
					let button = document.querySelector('#button');

				А теперь давайте привяжем к нашей кнопке в качестве обработчиков клика и первую, и вторую функции:
					button.addEventListener('click', func1);
					button.addEventListener('click', func2);

			Обработчики разных событий в JavaScript:

				Кроме клика по элементу, существуют и другие события. Например, с помощью события dblclick можно отловить двойной 
				клик по элементу, с помощью события mouseover - наведение курсора на элемент, а с помощью события mouseout - уход
				курсора от элемента.

				При этом к одному элементу можно привязывать обработчики разных событий. Давайте, например, привяжем к одному 
				элементу реакцию на наведение курсора и реакцию на уход:
					button.addEventListener('mouseover', function() {
						console.log('1');
					});
					button.addEventListener('mouseout', function() {
						console.log('2');
					});

			Работа с текстом элементов на JavaScript:

				У DOM элементов есть свойство textContent, позволяющее прочитываит текст этих элементов. Давайте посмотрим 
				на примерею Пусть у нас есть следующий тег:
					<p id="elem">text</p>

				Проучим ссылку на этот тег в переменную:
					let elem = document.querySelector('#elem');

				Прочитаем текст тега:
					console.log(elem.textContent);

				Поменяем текст тега:
					elem.textContent = '!!!';
					
			Работа с HTML кодом элементов в JavaScript:

				У DOM элементов есть свойство innerHTML, позволяющее просчитывать HTML код этих элементов. Давайте 
				посмотрим на примере. Пусть у нас есть следующий тег:
					<p id="elem"><b>text</b></p>

				Получим ссылку на этот тег в переменную:
					let elem = document.querySelector('#elem');
				
				Прочитаем HTML код тега:
					console.log(elem.innerHTML); // выведет <b>text</b>

				Поменяем текст тега:
					elem.innerHTML = '<i>!!!</i>';

			Атрибуты тегов как свойства в JavaScript:
			
				Давайте теперь научимся получать атрибуты тегов. Здесь действует следующее правило: каждому атрибуту
				тега соотвутствует одноименное свойство DOM элемента.

				Давайте посмотрим на примере. Пусть у нас есть вот такой тег:
					<input id="elem" type="text">

				Получим ссылку на наш элемент в переменную:
					let elem = document.querySelector('#elem');

				Выведем значения нужных нам атрибутов:
					console.log(elem.id);   // выведет 'elem'
					console.log(elem.type); // выведет 'text'  

				А теперь для примера поменяем значение атрибута:
					elem.type = 'submit';

			Работа с текстовыми полями в JavaScript:

				Сейчас мы с вами научимся получать текст от пользователей нашего сайта. Для этого в HTML
				предусмотрен специальный тег inputЮ представляющий собой поле для ввода данных.
					<input>

				У данного тега есть атрибут value, задающий начальный текст, который будет написан в инпуте по заходу на страницу:
					<input value="text">

				Пользователь нашего сайта после захода на страницу может поменять текст инпута. При этом, если у нас есть переменная,
				содержащая ссылку на этот инпут, то свойство value этой переменной всегда будет содержать текущее значение текста 
				инпута.

				Попробуем на практикею Пусть у нас инпут с атрибутом value:
					<input id="elem" value="text">

				Получим ссылку на этот инпут через перменную:
					let elem = document.querySelector('#elem');

				А теперь выведем на экран текущий текст инпута:
					console.log(elem.value);		

				А теперь поменяем текст инпута на другой:
					elem.value = 'new text';

			Фокус текстовых полей в JavaScript:

				Пусть у нас есть инпут. Вы можете нажать на этот инпут и после этого в нем заморгает 
				курсор-палочка и можно будет вводить в него текст.

				Про такое состояние говорят, что инпут сейчас имеет фокус ввода. На практике это означает,
				что если начать вводить текст с клавиатуры, то этот текст будет попадать в тот инпут, который 
				сейчас имеет фокус ввода. Если затем кликнуть куда-нибудь вне инпута, тот этот инпут потеряет фокус 
				ввода и в него нельзя будет вводить текст. 

				Для того, чтобы поймать момент  получения или потери фокуса инпутом, в JavaScript предусмотрены
				специальные события: событие focus позволяет отловить получение фокуса инпутом, а событие blur - потерю.
				Попробуем на парктике. Пусть у нас есть инпут:
					<input id="elem" value="text">

				Получим сслыку на него в переменную:
					let elem = document.querySelector('#elem');

				А теперь сделаем так, чтобы по получению фокуса в консоль вывелся текущий текст инпута:
					elem.addEventListener('focus', function() {
						console.log(elem.value);
					});

			Исключения при работе с атрибутами в JavaScript:

				При работе с атрибутами существует исключение - это атрибут class. Это слово является специальным
				в JavaScript и поэтому мы не можем просто написать elem.class, чтобы считать значение атрибута class.
				Вместо этого следует писать elem.className. 

				Давайте посмотрим на примере. Пусть у нас дан вот такой инпут:
					<input id="elem" class="aaa bbb">

				Давайте выведем значение атрибута class для нашего инпута:
					let elem = document.querySelector('#elem');
					console.log(elem.className); // выведет 'aaa bbb'

				Существуют и другие исключения, например, атрибут for. К нему следует обращаться через 
				htmlFor.

			Цепочки методов и свойств в JavaScript:

				Пусть у нас есть инпут:
					<input id="elem" value="text">

				Давайте выведем на экран текст инпута:
					let elem = document.querySelector('#elem');
					console.log(elem.value); // выведет 'text'

				Как вы видите, мы сначала получаем элемент по его id, записываем этот элемент в переменную elem,
				а затем выводим на экран свойство value из этой переменной.

				На самом деле можно не вводить переменую elem, а строить цепочку из точек таким образом:
					console.log( document.querySelector('#elem').value ); // выведет 'text'

				Таким же способом - цепочкой - можно производить и перезапись атрибутов:
					document.querySelector('#elem').value = 'www';

			Преимущества и недостатки цепочек в JavaScript:

				Не смотря на то, что цепочки сокращают код, в большинстве случаев введение переменной все-таки 
				удобнее. Сравните два примера - сейчас я ввел перемееую elem и могу записывать любое количество 
				атрибутов, при этом querySelector вызывается только один раз:
					let elem = document.querySelector('#elem');
					elem.value = 'www';
					elem.type  = 'submit';

				А сейчас я не ввожу новую переменную и поэтому мне приходится вызывать querySelector два раза:
					document.querySelector('#elem').value = 'www';
					document.querySelector('#elem').type  = 'submit';

				На мой взгяд, этот код стал сложнее, хотя и занимает на одну строчку меньше. Кроме того, еслир я
				захочу сменить значение id с 'elem' на какое-то другое, мне придется делать это во многих местах,
				что очень неудобно.

				Есть и еще проблема - нагрузка на браузер. Поиск элементов по странице, который делает метод 
				querySelector, является довольно медленной операцией (и вообще любая работа с элементами страницы
				- это медленная операция - запомните это).

				В нашем случае, если мы каждый раз используем querySelector, то браузер каждый раз будет обрабатывать
				HTML страницу и искать элемент с заданным id несколько раз (неважно, что id одинаковые - браузер 
				проделает все действия несколько раз), совершая бесполезные операции, которые могут замедлить работу 
				браузера.

				Если же мы используем переменную elem - никакого поиска по странице не происходит (элемент уже найден
				и ссылка на него лежит в переменной).

			Объект this в JavaScript:

				Сейчас мы с вами будем работать со специальным объектом this, доступным в функции-обработчике
				события. Этот объект указывает на элемент, в котором произошло событие.

				Объект this удобен, когда элемент в котором произошло событие, и элемент с которым совершаются 
				действия в результате события, - это один и тот же элемент. 

				Например, если у нас есть инпут, мы можем привязать к нему обработчик потери фокуса и по наступлению
				этого события что-то сделать с текстом инпута. Давайте сделаем описанное. Пусть у нас дан инпут:
					<input id="elem" value="text">

				Давайте получим ссылку на него в переменую elem:
					let elem = document.querySelector('#elem');

				Привяжем к нему функцию-обработчик события blur:
					elem.addEventListener('blur', func);		

				Внутри этой функции func будет доступен объект this, указывающий на наш инпут:
					function func() {
						console.log(this); // содержит 
							ссылку на наш элемент 
					}

				Выведем содержимое атрибута value нашего инпута:
					function func() {
						console.log(this.value); // выведем 
							содержимое атрибута 
					}

				Ну, а теперь запишем в инпут какой-нибудь текст:
					function func() {
						this.value = '!!!';
					}

				Можно использовать и анонимную функцию:
					elem.addEventListener('blur', function() {
						this.value = '!!!';
					});

			Преимущество this в JavaScript:

				Из сказанного ранее пока не очевидно особое преимущество this. Ведь внутри функции-обработчика
				и так будет доступен наш элемент - ведь переменная elem будет глобальной для нашей функции func:
					let elem = document.querySelector('#elem');
					elem.addEventListener('click', func);

					function func() {
						// здесь доступна переменная elem с нашим элементом
					}

				И, несложно сообразить, что содержимое this и содержимое переменной elem в нашем случае равны:
					let elem = document.querySelector('#elem');
					elem.addEventListener('click', func);

					function func() {
						console.log(elem === this); // выведет true
					}

				В чем же особенное преимущество this? Оно проявляется, когда у нас несколько элементов, и к каждому
				привязана одна и та же функция.

				Посмотрим на примере. Пусть у нас есть 3 кнопки:
					<input id="button1" type="submit" value="text1">
					<input id="button2" type="submit" value="text2">
					<input id="button3" type="submit" value="text3">		

				Получим ссылки на них в переменные:
					let button1 = document.querySelector('#button1');
					let button2 = document.querySelector('#button2');
					let button3 = document.querySelector('#button3');

				Привяжем к этим кнопкам одну и ту же функцию:
					button1.addEventListener('click', func);
					button2.addEventListener('click', func);
					button3.addEventListener('click', func);

				А внутри функции будем выводить this.value:
					function func() {
						console.log(this.value);
					}

				Получится, что у нас есть три кнопки. Нажатие на каждую кнопку буджет приводить к вызову 
				функции func. При этом при кажом клике this будет содержать ссылку на ту кнопку, в которой 
				произошло событие. 

				То есть каждое нажатие будет выводить в консоль value той кнопки, на которой произошло нажатие,
				нр делать это будет одна и та же функция func! Вот в чем преимущество использования this.  

			Получение группы элементов в JavaScript:

				В предыдущих уроках мы с помощью метода querySelector получали один элемент страницы. Теперь 
				пришло время научиться получать группу элементов и проделывать какие-нибудь операции сразу со 
				многими элементами. 

				Для этого существует метод querySelectorAll, получающий все теги, подпадающие под CSS селектор,
				в виде массива элементов. Чтобы сделать что-нибудь см найденными элементами, нужно поработать 
				с полученным массивом, например, перебрать его циклом и в цикле выполнить какую-либо операцию 
				с каждым элементом по отдельности. 

				Пусть, к примеру, у нас даны абзацы с классом www:
					<p class="www">text1</p>
					<p class="www">text2</p>
					<p class="www">text3</p>

				Давайте получим массив этих абзацев, переберем их циклом и в цикле выведем тексты найденных 
				абзацев в консоль:
					let elems = document.querySelectorAll('.www');

					for (let elem of elems) {
						console.log(elem.textContent);
					}

				А теперь давайте в конец текста каждого абзаца добавим восклицательный знак:
					let elems = document.querySelectorAll('.www');

					for (let elem of elems) {
						elem.textContent = elem.textContent + '!';
					}

			Добавление обработчиков в цикле JavaScript:

				Давайте теперь научимся массово добавлять обработчики событий элементам. Пусть, к примеру, у нас есть абзацы:
					<p>text1</p>
					<p>text2</p>
					<p>text3</p>

				Пусть также есть функция:
					function func() {
						console.log('!');
					}

				Давайте переберем наши абзацы в цикле и каждому абзацу добавим в качестве обработчика кила функцию func:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', func);
					}

				Давайте пойдем дальше и сделаем так, чтобы по клику на любой абзац выводился текст этого абзаца. Есть, однако, проблема: абзацев много, а функция 
				обработчик одна. Как же нам отчислить наши абзацы внутри функции обработчика? 

				В этом нам поможет объект this - при вызове функции в момент события этот объект будет указывать на тот элемент, где 
				это событие случилось. Переделаем наш код функции func в соответствии со сказанным:
					function func() {
						console.log(this.textContent); // выводим текст абзаца
					}

			Добавление анонимных обработчиков в цикле в JavaScript:

				В качестве обработчиков, навешиваемых в цикле, можно использовать и анонимные функции. Это делает код более компактным 
				и избавляет нам от придумывания имени для функции, которая используется только в одном месте.

				Давайте навесим на элементы анонимные обработчики:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', function() {
							console.log(this.textContent);
						});
					}

			Отвязывание событий в JavaScript:

				В данном уроке мы с вами научимся отвязывать обработчики события, которые ранее были привязаны нами к элементам.
				Пусть для примера дана следующая кнопка:
					<input id="button" type="submit">

				Привяжем к этой кнопку функцию func:
					let button = document.querySelector('#button');
					button.addEventListener('click', func);

					function func() {
						console.log('!!!');
					}

				Давайте теперь сделаем так, чтобы обработчик события срабатывал на первый клик, а потом отвязывался от кнопки.
				Для этого существует специальный метод removeEventListener. Этот метод первым параметром принимает тип события, 
				а вторым - ссылку на функцию, которую нужно отвязать.

				Как правило, это значит, что обработчик события отвязывается так же, как и привязывался. То есть, если мы привязали
				его вот так: addEventListener('click', func), то и отвяжем с теми же параметрами, вот так: removeEventListener('click', func).

				Итак, решим поставленную нам задачу:
					let button = document.querySelector('#button');
					button.addEventListener('click', func);

					function func() {
						console.log('!!!');
						this.removeEventListener('click', func);
					}

			Отвязывание обработчиков событий в цикле в JavaScript:

				Пусть тепер у нас есть не один элемент, а несколько. Например, несколько абзацев:
					<p>text1</p>
					<p>text2</p>
					<p>text3</p>

				Давайте к каждому из этих абзацев обработчиком клика привяжем функцию func:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', func);
					}

					function func() {
						console.log(this.textContent);
					}

				Давайте теперь переделаем код так, чтобы каждый абзац реагировал только на первое нажатие на него. 
				Для этого при клике на абзац будем отвязывать от него привязанный обработчик. При этом отвязываение будет 
				конктретно от этого абзаца, никак не затрагивая остальных.

				Как вы уже знаете, элемент, в котором произошло событие, можно получить в функции-обработчике через this. Это значит,
				что нужно выполнять отвязывание обработчика от this, вот так:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', func);
					}

					function func() {
						console.log(this.textContent);
						this.removeEventListener('click', func); // отвязываем обработчик
					};

			Отвязывание анонимных функций в JavaScript:

				Пусть теперь к нашим абзацам привязана анонимная функция:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', function() {
							console.log(this.textContent);
						});
					}

				Пусть мы хотим отвязвать эту функцию от абзаца после клика по этому абзацу. Нас, однако, ждет проблема:
				у функции нет имени, чтобы отвязать ее.

				Для решения проблемы нужно дать имя функции, сделав из нее именованное функционально выражение. Сделаем это:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', function func() 
							{ // дали 
							имя функции 
							console.log(this.textContent);
						});
					}

				Теперь эту функцию можно отвязать внутри нее самой:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', function func() {
							console.log(this.textContent);
							this.removeEventListener('click', func); // отвязываем функцию
						});
					}

			Советы по написанию кода на примере DOM в JavaScript:

				Пусть перед вами стоит задача достаточной сложности, для релизации которой нужно написать некоторое количество строк кода.

				Неправильным подходом будет пытаться написать весь код решения целиком, а потом начать его проверять. В этом случае высока вероятность,
				что у вас ничего не заработает, а ошибку придется искать в большом количестве кода.

				Правильным подходом является разбиение задачи на маленькие элементарные шаги, которые вы будете реализовывать и сразу проверять их 
				правильность. В этом случае, даже если вы где-то ошибетесь, вы сразу заметите проблему и исправите ее. 

				Давайте попробуем на практике. Пусть у вас есть абзацы:
					<p>1</p>
					<p>2</p>
					<p>3</p>
					<p>4</p>
					<p>5</p>
					<p>6</p>

				Пусть перед вами стоит задача найти абзацы с числами, кратными 3, и найти сумму их чисел.

				Первым маленьким шагом я бы предложил получить наши абзацы в виде массива и вывести этот массив
				в консоль, чтобы посмотреть, что мы все правильно получили. Сдеалем это:
					let elems = document.querySelectorAll('p');
					console.log(elems);

				Следующим маленьким шагом нужно перебрать наши абзацы циклом и вывести кадждый из них в консоль по 
				отдельности:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						console.log(elem);
					}

				
				А теперь в цикле выведем тексты наших абзацев:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						console.log(elem.textContent);
					}

				Теперь давайте выведем тексты тех абзацев, чье число делится на 3:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						let text = +elem.textContent;
						
						if (text % 3 === 0) {
							console.log(text);
						}
					}

				Убедившись, что мы получаем правильные абзацы, можно приступать к суммированию их чисел:
					let elems = document.querySelectorAll('p');
					let sum = 0;

					for (let elem of elems) {
						let text = +elem.textContent;
						
						if (text % 3 === 0) {
							sum += text;
						}
					}

					console.log(sum);

		АТРИБУТЫ:

			Пользовательские атрибуты в JavaScript:

				В HTML разрешено добавлять свои, пользовательские атрибуты тегам. Такие атрибуты должны начинаться с data- , а затем 
				должно идти любое название атрибута, которое вам удобно.

				Пользовательские атрибуты могут быть использованы огромным количеством различных способов. Многие из этих способов мы
				изучим далее в учебнике, а еще больше вы сможете в дальнейшем изобрести самостоятельно. 

				Обращение к таким атрибутам устроено нестандартным образом. Нельзя просто обратиться к одноименному свойству элемента,
				как мы делали это раньше, а следует использовать специальное свойство dataset, после которого через точку пишется имя 
				атрибута без data-. Например, если наш атрибут назвается data-test, то для обращения к нему мы будет писать elem.dataset.test,
				где elem - переменная с нашим элементом. 

				Давайте посмотрим на примере. Пусть у нас дан вот такой элемент:
					<div id="elem" data-num="1000"></div>

				Выведем на экран значение его атрибута data-num:
					let elem = document.querySelector('#elem');
					console.log(elem.dataset.num); // выведет 1000		

				А теперь присвоим этому атрибуту другое значение:
					let elem = document.querySelector('#elem');
					elem.dataset.num = 123;

			Имена атрибутов с дефисами в JavaScript:

				Пользовательские атрибуты могут содержать дефисы в своем названии, например, вот так:
					<div id="elem" data-my-test="1000"></div>

				Для обращения к таким атрибутам следует использовать camelCase:
					let elem = document.querySelector('#elem');
					console.log(elem.dataset.myTest);

			Обращения к атрибутам через методы в JavaScript:

				К ползовательским атрибутам можно также обращаться с помощью методов типа getAttribute,
				в этом случае следует писать полное название атрибута:
					<div id="elem" data-num="1000" data-my-num="2000"></div>

					let elem = document.querySelector('#elem');

					console.log(elem.getAttribute('data-num'));    // выведет 1000
					console.log(elem.getAttribute('data-my-num')); // выведет 2000
	
		СТИЛИЗАЦИЯ:

			Стилизация элементов через атрибут style в JavaScript:

				Давайте теперь научимся добавлять CSS стили элементам. Это делается путем изменения атрибута style. К примеру, чтобы поменять цвет, нужно построить следующую цепочку:
				elem.style.color, и присвоить ей нужное значение цвета. 

				Посмотрим на примере. Пусть у нас есть вот такой элемент:
					<p id="elem">text</p>

				Сделаем этот элемент красного цвета:
					let elem = document.querySelector('#elem');
					elem.style.color = 'red';

			Стилизация свойств с дефисом в JavaScript:

				Свойства, которые записываются через дефис, например font-size, преобразуются в camelCase. То есть font-size станет fontSize:
					elem.style.fontSize = '20px';

			Исключение при стилизации элементов в JavaScript:

				Свойство float является исключением, так как оно является специальным в JavaScript. Для него следует писать cssFloat:
					elem.style.cssFloat = 'right';

			Стилизация с помощью CSS Классов на JavaScript:

				В предыдущем уроке мы с вами научились менять CSS стили элементов через изменения атрибута style.
				Чаще всего это не очень хорошая идея. Дело в том, что, если раскидать стили по JavaScript коду,
				в дальнейшем будет проблематично изменить дизайн сайта, так как придется ковырять JavaScript код в 
				поисках зашитых туда стилей. 

				Более удобно для дальнейшей поддержки будет добавлять или убирать элементу CSS классы, тем самым стилизуя их
				нужным образом. 

				Давайте посмотрим на примере. Пусть у нас есть несколько абзацев:
					<p>text1</p>
					<p>text2</p>
					<p>text3</p>

				Давайте сделаем так, чтобы по клику на любой абзац, этот абзац красился в какой-нибудь цвет, например в зеленый.
				Для этого в CSS файле сделаем специальный класс для окрашивания абзацев:
					.colored {
						color: green;
					}

				Преимущество использование класса в том, что теперь легко будет поменять желаемый цвет - для этого нкжно будет просто внести
				изменение в CSS файл, не ковыряя JavaScript код. Особенно удобно это будет в том случае, если JavaScript код пишете вы, а в дальнейшем стилизовать его будет кто-то другой
				(возможно менее квалифицированный человек, умеющий работать только с CSS)

				Итак, теперь, после введения класса, по клику на любой абзац можно изменить его цвет, просто добавив ему наш класс:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', function() {
							this.classList.add('colored'); // добавляем абзацу класс
						});
					}

			Преимущество стилизации с помощью CSS классов в JavaScript:

				Использование классов вмето изменения стелй напрямую имеет еще одно преимущество. Легким движением руки можно сделать так,
				что стили элементом будут чередоваться. 

				Например, можно сделать так, что при первом клике на абзац он будет краситься в определенный цвет, а при повторном клике - 
				возвращать себе исходный цвет. Для этого нужно просто метод add поменять на метод toggle:
					let elems = document.querySelectorAll('p');

					for (let elem of elems) {
						elem.addEventListener('click', function() {
							this.classList.toggle('colored');
						});
					}

			Применение стилизации в JavaScript:

				Давайте сделаем кнопку, по нажатию на которую элемент будет то показываться, то скрываться.
				Пусть по умолчанию элемент скрыт (это реализуем с помощью display:none), а покажется он с помощью добавления класса active.
				Этот класс будем то добавлять, то убирать с помощью classList.toggle:
					<button id="button">click me</button>
					<div id="elem"></div>


					#elem {
						display: none;
						width: 200px;
						height: 200px;
						border: 1px solid green;
					}
					#elem.active {
						display: block;
					}


					let button = document.querySelector('#button');
					let elem = document.querySelector('#elem');

					button.addEventListener('click', function() {
						elem.classList.toggle('active');
					});

		ПОИСК:

			Нахождение потомков элементов в JavaScript:

				Свойство fitstElementChild:

					Свойство firstElementChild содержит первый дочерний элемент. Дочерними элементами считаются все теги, которые непосредственно расположены внутри
					блока. Если у элемента нет дочерних элементов - возвращается null. 

					Синтаксис:
						элемент.firstElementChild;

					Пример 1:

						Получим содержимое первого потомка элемента:
							html:
								<div id="parent">
									<p>1</p>
									<p>2</p>
								</div>

							JavaScript
								let parent = document.querySelector('#parent');
								let text = parent.firstElementChild.textContent;

								console.log(text);

						Результат выполнения кода:
							'1'

					Пример 2:

						А теперь у элемента нет дочерних элементов и поэтому выведется null:
							Html:
								<div id="parent"></div>

							JavaScript:
								let parent = document.querySelector('#parent');
								console.log(parent.firstElementChild);

						Результат выполнения кода:
							null

				Свойство lastElementChild:

					Свойство lastElementChild хранит в себе последний дочерний элемент. Дочерними элементами считаются все теги, которые 
					непосредственно расположены внутри блока. Если у элемента нет дочерних элементов - возвращается null.

					Синтаксис:
						элемент.lastElementChild;
					
					Пример 1:

						Получим содержимое последнего потомка элемента:
							html:
								<div id="parent">
									<p>1</p>
									<p>2</p>
								</div>

							JavaScript:
								let parent = document.querySelector('#parent');
								let text = parent.lastElementChild.textContent;

								console.log(text);

						Результат выполнения кода:
							'2'

					Пример 2:

						А теперь у элемента нет дочерних элементов и поэтому выведется null:
							html:
								<div id="parent"></div>

							JavaScript:
								let parent = document.querySelector('#parent');
								console.log(parent.lastElementChild);

						Результат выполнения кода:
							null

				Свойство children:

					Свойство children хранит в себе псевдомассив дочерних элементов. Дочерними элементами считают все теги, которые непосредственно 
					расположены внутри блока.

					Синтаксис:
						элемент.children;

					Пример 1:

						Давайте переберем в цикле всех потомков элемента и выведем их содержимое:
							html:
								<div id="parent">
									<p>1</p>
									<p>2</p>
									<p>3</p>
									<p>4</p>
									<p>5</p>
								</div>

							JavaScript:
								let parent = document.querySelector('#parent');
								let elems = parent.children;

								for (let elem of elems) {
									console.log(elem.textContent);
								}

			Нахождение родителей элементов в JavaScript:

				Свойство parentElement:

					Свойство parentElement содержит родительский элемент.

					Синтаксис:
						элемент.parentElement;

					Пример 1:

						Давайте получим родителя элемента #elem и выведем на экран его id:
							html:
								<div id="parent">
									<p id="elem"></p>
								</div>

							JavaScript:
								let elem = document.querySelector('#elem');
								let id = elem.parentElement.id;

								console.log(id);

						Результат выполнения кода:
							'parent'

			Поиск всех родителей элементов в JavaScript:

				Метод closest:

					Метод closest ищет ближайший родительский элемент, подхожящий под указанный CSS селектор, при этом сам элемент тоже 
					включается в поиск.

					Синаксис:
						элемент.closest('селектор');

					Пример 1:

						Давайте найдем среди родителей элемента элемент с классом www:
							html:
								<div class="www" id="parent2">
									<div class="ggg" id="parent1">
										<p class="zzz" id="child"></p>
									</div>
								</div>

							JavaScript:
								let elem = document.querySelector('#child');
								let parent = elem.closest('.www');

								console.log(parent.id);

						Результат выполнения кода:
							'parent2'

					Пример 2:

						Давайте найдем среди родителей элемента элемент с классом www. В результате мы получим ссылку на сам элемент, так как он 
						сам имеет этот класс:
							html:
								<div class="www" id="parent2">
									<div class="www" id="parent1">
										<p class="www" id="child"></p>
									</div>
								</div>

							JavaScript:
								let elem = document.querySelector('#child');
								let parent = elem.closest('.www');
								console.log(parent.id);

						Результат выполнения кода:
							'child'

			Поиск соседей элементов в JavaScript:

				Свойство previousElementSibling:

					Свойство previousElementSibling содержит предыдущий элемент, находящийся в этом же родителе.
					Если такого элемента нет - возвращается null.

					Синаксис:
						элемент.previousElementSibling;

					Пример 1:

						Дан элемент #elem. Давайте выведем текст его соседа сверху:
							html:
								<p>sibling</p>
								<p id="elem">elem</p>

							JavaScript:
								let elem = document.querySelector('#elem');
								let text = elem.previousElementSibling.textContent;

								console.log(text);

						Результат выполнения кода:
							'sibling'

					Пример 2:

						Если соседа сверху нет или он расположен не в родителе нашего элемента, также возвращается null:
							html:
								<p>sibling</p>
								<div>
									<p id="elem">elem</p>
								</div>

							JavaScript:
								let elem = document.querySelector('#elem');
								console.log(elem.previousElementSibling);

						Результат выполнения кода:
							null
			
				Свойство nextElementSibling:

					Свойство nextElementSibling содержит следующий элемент, находящийся в этом же родителе. 
					Если такого элемента нет - возвращается null.

					Синтаксис:
						элемент.nextElementSibling;

					Пример 1:

						Дан элемент #elem. Давайте выведем текст его соседа снизу:
							html:
								<p id="elem">elem</p>
								<p>sibling</p>

							JavaScript:
								let elem = document.querySelector('#elem');
								let text = elem.nextElementSibling.textContent;

								console.log(text);

						Результат выполнения кода:
							'sibling'					

					Пример 2:

						Если соседа снизу нет или он расположен не в родителе нашего элемента, также возвращается null:
							html:
								<div>
									<p id="elem">elem</p>
								</div>
								<p>sibling</p>

							JavaScript:
								let elem = document.querySelector('#elem');
								console.log(elem.nextElementSibling);

						Результат выполнения кода:
							null

			Поиск элемента по id в JavaScript:

					Метод getElementById:

						Метод getElementById позволяет получить элемент страницы по его атрибуту id. С полученным эдементом 
						можно будет производить различные манипуляции: менять его текст, атрибуты, CSS стили и так далее.

						Синтаксис:
							document.getElementById(id элемента);

						Пример 1:

							Давайте получим инпут по его id и поменяем ему содержимое атрибута value:
								html:
									<input id="elem" value="???">

								JavaScript:
									let elem = document.getElementById('elem');
									elem.value = '!!!';

							Результат выполнения кода:
								<input id="elem" value="!!!">

			Поиск элемента по имени тега в JavaScript:

					Метод getElementsByTagName:

						Метод getElementsByTagName позволяет получить элементы страницы по имени тега. С полученными элементами можно
						производить различные манипуляции: менять их текст, атрибуты, CSS стили и так далее.

						Синтаксис:
							document.getElementsByTagName(имя тега);

						Пример 1: 

							Давайте получим все абзацы и изменим им текст с помощью свойства innerHTML:
								html:
									<p>elem 1</p>
									<p>elem 2</p>
									<p>elem 3</p>

								JavaScript:
									let elems = document.getElementsByTagName('p');

									for (let elem of elems) {
										elem.innerHTML = '!!!';
									}

						Результат выполнения кода:
							<p>!!!</p>
							<p>!!!</p>
							<p>!!!</p>

			Поиск элемента по имени класса в JavaScript:

				Метод getElementsByClassName:

					Метод getElementsByClassName позволяет получить элементы страницы по их классу, заданному в атрибуте class.
					С полученными элементами можно будет производить различные манипуляции: менять их текст, атрибуты, CSS свойства и так далее.

					Синаксис:
						document.getElementsByClassName(имя класса);

					Пример 1:

						Давайте получим все элементы с классом www и изменим им текст с помощью свойства innerHTML:
							html:
								<p class="www">elem 1</p>
								<p class="www">elem 2</p>
								<p class="www">elem 3</p>

							JavaScript:
								let elems = document.getElementsByClassName('www');

								for (let elem of elems) {
									elem.innerHTML = '!!!';
								}

						Результат выполнения кода:
							<p class="www">!!!</p>
							<p class="www">!!!</p>
							<p class="www">!!!</p>

			Поиск элементов внутри другого элемента в JavaScript:

				Пусть у нас есть некоторый родитель, а внутри него другие элементы:
					<div id="parent">
						<div class="child">text</div>
						<div class="child">text</div>
						<div class="child">text</div>
					</div>

				Пусть ссылка на родитель уже получена в переменную:
					let parent = document.querySelector('#parent');

				В таком случае, при необходимости мы можем выполнить поиск по селектору внтури этого родителя, а не по всему документу. Для этого метод 
				для поиска нужно применить не к document, а к переменной, содержащей нашего родителя. 

				Давайте для примера найдем внутри нашего родителя элементы с классом child:
					let elems = parent.querySelectorAll('.child');

		УЗЛЫ:

			Работа с узлами в JavaScript:

				Как вы знаете, теги могут содержить другие теги или, говоря в терминах JavaScript, DOM элементы могут содержать другие DOM элементы.
				Кроме этого, однако, в них могут быть комментарии и обычный текст. Комметарии, тексты и DOM элементы объединяют одним названием - узлы.

				Вам уже знакомы свойства firstElementChild, lastElementChild, nextElementSibling, previousElementSibling.
				Эти свойства работают именно с DOM элементами игнорирую остальные узлы. Как правило, именно это нам и требуется.

				Однако, существуют также свойства firstChild, lastChild, nextSibling, previousSibling. Эти свойства работают 
				аналогичным образом, однако, учитывая все узлы. Давайте посмотрим разницу между этими свойствами на примере. Пусть у нас дан див, содержащий в себе три узла:
					<div id="elem">
						<!--сomm-->text
						<span>tag</span>
					</div> 

				Получим ссылку на этот див в переменную:
					let elem = document.querySelector('#elem');

				А теперь давайте посмотримЮ что содержится в свойствах firstChild и firstElementChild:
					console.log(elem.firstChild);        // комментарий
					console.log(elem.firstElementChild); // тег span

			Перебор узлов циклом в JavaScript:

				Как вы уже должны знать, в свойстве children содержатся все дом элементы, являющиеся непосредственными потомками данного элемента.
				Существует аналогичное свойства childNodes, которое содержит в себе все потомки-узлы элемента.

				Давайте, например, с помощью этого свойства выведем различные узлы из нашего элемента:
					console.log(elem.childNodes[0]);
					console.log(elem.childNodes[1]);
					console.log(elem.childNodes[2]);

				А теперь давайте переберем узлы элемента циклом:
					for (let node of elem.childNodes) {
						console.log(node);
					}

			Название узлов в JavaScript:

				Все узлы имеют свойство nodeName. Для комментаря оно содержит значение 'comment', для текстового узла - значение 'text',
				а для узла-элемента - имя тега в верхнем регистре. Получается, что nodeName для элементов аналогичен свойству tagName, но работает 
				также и для других типов узлов. 

			Тип узлов в JavaScript:

				Все узлы имеют свойство nodeType. Его значение числовое: 1 для элементов, 3 для текстовых элементов, 
				8 для комментариев. Остальные значения в настоящее время или малоиспользованы, или устарели. 

			Текст узлов в JavaScript:

				Давайте теперь разберемся, как прочитать или изменить текст узлов. Для всех узлов работает свойство textContent. Для
				текстовых узлов и комментариев есть свойства nodeValue и data (они практически одинаковы, второе - короче, лучше пользоваться 
				им). Для элементов есть свойство innerHTML, прочитывающее текст вместе с тегами.

		ФОРМЫ:

			Работа с textarea в JavaScript:

				В данном разделе учебника мы с вами изучим работу с более сложными возможностями форм. Начнем изучение с тега textarea, 
				представляющего собой многострочное поле ввода. 

				При работе с даным тегом есть некоторый нюанс. Суть в следующем: текст, который будет сгонять в теге по умолчанию,
				располагается с между открывающим и закрывающим тегом textarea:
					<textarea id="elem">text</textarea>

				Однако не смотря на это, прочитывать и записывать текст тега следует не через свойство innerHTML, а через value. 
				Для примера выведем текст приведенного выше textarea:
					let elem = document.querySelector('#elem');
					console.log(elem.value); // выведет 'text'

			Атрибут disabled в JavaScript:

				В HTML существуют специальные атрибуты без значений, например атрибут disabled, используеый для блокировки элементов.
				Для того, чтобы установить такой атрибут, соответствующему свойству требуется присвоить значение true, а чтобы убрать -
				значение false.

				Давайте посмотрим на практике. Пусть у нас есть заблокированный инпут:
					<input id="elem" disabled>

				Давайте выведем значение атрибута disabled этого инпута:
					let elem = document.querySelector('#elem');
					console.log(elem.disabled); // выведет true

				А теперь давайте разблокируем его:
					let elem = document.querySelector('#elem');
					elem.disabled = false;

			Работа с чекбоксами в JavaScript:

				Сейчас мы с вами научимся работать с чекбоксами. Чекбокс представляет собой специальную галочку, которая может 
				находиться в двух состояниях: отчено и нет.

				Чекбокс создается следующим образом:
					<input type="checkbox" id="elem">

				Чтобы сделать чекбокс отмеченным - ему нужно написать атрибут checked:
					<input type="checkbox" checked id="elem">

				Давайте для примера узнаем состояние нашего чекбокса:
					let elem = document.querySelector('#elem');
					console.log(elem.checked);

			Чередование атрибутов без значений:

				Пусть дан заблокированный инпут и кнопка:
					<input id="elem" disabled>
					<input id="button" type="submit">

				Давайте сделаем так, чтобы каждое нажание на кнопку приводило к смене состояния инпута - с заблокированного 
				на разблокированное и наоборот. Для начала получим ссылки на наши элементы в переменные:
					let elem   = document.querySelector('#elem');
					let button = document.querySelector('#button');

				А теперь реализуем задуманное:
					button.addEventListener('click', function() {
						if (elem.disabled) {
							elem.disabled = false;
						} else {
							elem.disabled = true;
						}
					});

				Задачу, однако, можно решить меньшим количеством кода:
					button.addEventListener('click', function() {
						elem.disabled = !elem.disabled;
					});

			Работа с радиокнопками в JavaScript:

				Давайте теперь поработаем с радиокнопками. Они представляют собой группу переключателей, из которых может быть выбран 
				только один. Чтобы несколько радиокнопок были группой, они должны иметь одинаковое значение атрибута name:
					<input type="radio" name="elem">
					<input type="radio" name="elem">
					<input type="radio" name="elem">

				А чтобы отличить на JavaScript, какая именно кнопка была выбрана, каждой радиокнопке в группе добавляют атрибуты value 
				с различным значением:
					<input type="radio" name="elem" value="1">
					<input type="radio" name="elem" value="2">
					<input type="radio" name="elem" value="3">

				Чтобы сделать какую-нибудь радиокнопку отмеченной по умолчанию, ей необходимо задать атрибут checked:
					<input type="radio" name="elem" value="1" checked> 
					<input type="radio" name="elem" value="2">
					<input type="radio" name="elem" value="3">

				Давайте посмотрим на практике, как работать с такими кнопками на JavaScript. Пусть у нас есть представленная выше группа 
				радиокнопок, а также обычная кнопка:
					<input type="submit" id="button">

				Давайте сделаем так, чтобы по нажатию кнопки вывелось value той радиокнопочки, которая отмечена на данный момент.

				Для решения задачи необходимо перебрать все наши радиокнопочки циклом и определить, какая из них выбрана. Для этого 
				нужно прочитывать значение свойства checked каждой из перебираемых радиокнопок. У которой это свойство равно true - та радиокнопка
				и выбрана.

				Реализуем написанное:
					let radios = document.querySelectorAll('input[type="radio"]');
						let button = document.querySelector('#button');

						button.addEventListener('click', function() {
							for (let radio of radios) {
								if (radio.checked) {
									console.log(radio.value);
								}
							}
						});

			Событие change в JavaScript:

				В данном уроке мы с вами разберем событие change, возникащее в полях ввода при их изменениях.
				Что это значит? Пусть, к примеру, у вас есть инпут и в нем есть какой-то текст. Если вы измените этот текст, 
				то в этом случае и возникнет это событие.

				Давайте посмотрим на примере:
					<input id="elem" value="text">

				Давайте по его изменению выведем в консоль новое значение:
					let elem = document.querySelector('#elem');

					elem.addEventListener('change', function() {
						console.log(this.value);
					});

			Событие input в JavaScript:

				Следующее событие, которое мы с вами изучим, называется input. Оно возникает каждый раз при вводе нового символа в input
				или textarea. Посмотрим на примере. Пусть у нас есть инпут:
					<input id="elem">

				Давайте при каждом нажатии кнопки на клавиатуре будет выводить в консоль текущее содержимое инпута:
					let elem = document.querySelector('#elem');

					elem.addEventListener('input', function() {
						console.log(this.value);
					});

			Метод focus и blur в JavaScript:

				Вы уже знаете, что такое фокус ввода. Вы также знаете, как установить или потерять фокус: для установки нужно нажать 
				в поле ввода, а для потери - в какое-то другое место.

				В JavaScript, однако, существуют специальные методы, которые позволяют принудительно устанавливать фокус в инпут или 
				убрать его оттуда. Это методы focus и blur.

				Давайте посмотрим их работу на примере. Пусть у нас есть вот инпут и кнопка:
					<input id="elem" value="text">
					<input type="submit" id="button">

				Давайте по нажатию на кнопку установим фокус ввода на наш инпут:
					let elem   = document.querySelector('#elem');
					let button = document.querySelector('#button');

					button.addEventListener('click', function() {
						elem.focus();
					});

		ВЫПАДАЮЩИЕ СПИСКИ:

			Работа с выпадающими списками в JavaScript:

				В данном уроке мы с вами изучим работу с тегом select, представляющим собой выпадающий список. Если вы не умеете 
				работать с этим тегом на HTML, то для начало изучите его устройство. 

				Давайте посмотрим, как работать с этим тегом через JavaScript. Пусть у нас дан вот такой выпадающий список:
					<select id="select">
						<option>one</option>
						<option selected>two</option>
						<option>three</option>
					</select>

				Получим ссылку на select в переменную:
					let select = document.querySelector('#select');

				Давайте теперь при изменении select выведем на экран текст выбранного пункта списка. Для этого нужно 
				прочитать свойство value нашего селекта:
					select.addEventListener('change', function(){
						console.log(this.value);
					});

				Есть также альтернативный пример решения этой задачи:
					select.addEventListener('change', function(){
						console.log(this.options[this.selectedIndex].textContent);
					});
							
			Атрибут value в выпадающих списках в JavaScript:

				Как правило, пунктам списка добаляют атрибут value. В этом случае свойство value селета будет содержать не текст option, 
				а значение его атрибута value. 

				Давайте переделам наш селект:
					<select id="select">
						<option value="1">one</option>
						<option value="2" selected>two</option>
						<option value="3">three</option>
					</select>

				Проверим, чему теперь равно выбранное значение:
					select.addEventListener('change', function(){
						console.log(this.value);
					});

			Изменение выбранного пункта списка на JavaScript:

				В предыдущем уроке мы с вами научились получать выбранный пункт списка. Давайте теперь будет изменять его выбранный пункт
				с помощью JavaScript.

				Для этого в свойство value селекта запишем значение атрибута value того option, который мы хотим выбрать.

				Пусть у нас есть следующий селект:
					<select id="select">
						<option value="one">один</option>
						<option value="two" selected>два</option>
						<option value="three">три</option>
					</select>

				Пусть дана также кнопка:
					<input type="submit" id="button">

				Получим ссылки на селект и кнопку в переменные:
					let select = document.querySelector('#select');
					let button = document.querySelector('#button');

				А теперь давайте сделаем так, чтобы при нажатии на кнопку наш селект сменил выбор:
					button.addEventListener('click', function() {
						select.value = 'one';
					});

				Если у нашего списка нет атрибутов value, то в свойство value селекта нужно записывать текст тега option, который мы хотим
				выбрать.

			Номер выбранного пункта выпадающего списка:

				В селектах существует специальное свойство selectedIndex, хранящее в себе номер того пункта списка, который сейчас выбран.
				Нумерация при этом начинается с нуля. При этом данное свойство можно как прочитывать, так и записывать, меняя выбранный
				пункт списка.

				Посмотрим на работу с данным свойством на примерею Пусть у нас дан следующий выпадающий список:
					<select id="select">
						<option value="one">один</option>
						<option value="two" selected>два</option>
						<option value="three">три</option>
					</select>

				Давайте выведем номер выбранного пункта списка:
					let select = document.querySelector('#select');
					console.log(select.selectedIndex); // выведет 1

				А теперь выберем какой-нибудь другой пункт:
					let select = document.querySelector('#select');
					select.selectedIndex = 2; // выберет 'три';

			Получение пунктов выпадающего списка на JavaScript:

				Пусть у нас дан некоторый выпадающий список:
					<select id="select">
						<option value="one">один</option>
						<option value="two">два</option>
						<option value="three">три</option>
					</select>

				Вопрос: как нам получить все пункты этого списка? Самый простой способ - это воспользоваться соответствующим 
				селектором:
					let options = document.querySelectorAll('#select option');
					console.log(options);

				Можно вести не по всему документу, а конкретно в нашем селекте:
					let select  = document.querySelector('#select');
					let options = select.querySelectorAll('option');
					console.log(options);

			Массив пунктов выпадающего списка на JavaScript:

				При работе с селектами есть следующая особенность: переменная, в которой хранится ссылка на селект является массивом,
				элементами которого являются теги option. Это значит, что эту переменную можно перебрать циклом:
					let select = document.querySelector('#select');

					for (let option of select) {
						console.log(option);
					}
					
				Ну или просто обратиться к пункту с нужным номером:
					let select = document.querySelector('#select');
					console.log(select[0]);

			Работа с пунктами выпадающего списка на JavaScript:

				Пусть у нас в переменной есть ссылка на тег option. Например, полученная следующим образом:
					let option = document.querySelector('#option');
					let option = select[0];

				В этом случае в свойстве text будет храниться текст option, в свойстве value - значение одноименного атрибута, а в свойстве selected - 
				значение true или false в зависимости от того, выбранный пункт списка или нет:
					console.log(option.text);
					console.log(option.value);
					console.log(option.selected);

			Выбор пункта списка в JavaScript:

				В предыдущих уроках мы обращались к тегу select, получая или меняя выбранный пункт списка. Это на самом деле не обязательно.
				Ведь можно взять и непосредственно какому-нибудь тегу option установить свойство selected в значении true.

				К примеру, сделаем выбранным пункт списка с номером два:
					let select = document.querySelector('#select');
					let option = select[2];
					option.selected = true;

			Получение выбранного оптиона в JavaScript:

				Используя все изученное, можно получить выбранный тег option следующим образом:
					let select = document.querySelector('#select');
					console.log(select[select.selectedIndex]);	

		ОБЪЕКТ EVENT:

			Основы работы с объектом Event в JavaScript:

				В данном уроке мы с вами изучим основы работы с объектом Event. Данный объект содержит в себе информацию о произошедшем событии.
				К примеру, если по элементу был сделан клик, мы сможем узнать координаты клика, была ли нажата клавиша Ctrl, Alt  или Shift в момент
				клика и так далее.

				Давайте посмотрим, как получить объект Event. Пусть у нас есть кнопка:
					<button id="elem">text</button>

				Пусть по клику на эту кнопку выполняется некоторая функция:
					let elem = document.querySelector('#elem');

					elem.addEventListener('click', function() {

					});

				Внутри связанной функции уже есть объект Event - мы просто пока езе не знаем, как его получить. Получается он следующим образом: нужно 
				при объявлении нашей функции передавать в нее параметром любую пеменную (как правило event - но название может быть любым) и в 
				эту переменную браузер автоматически положит объект Event:
					elem.addEventListener('click', function(event) {
						console.log(event); // увидим 
							объект с событием 
					});

			Координаты события в JavaScript:

				Свойство event.clientX:

					Свойство event.clientX содержит в себе координаты курсора мыши по оси X. Для определения координат есть также свойства 
					event.clientY, event.pageX, event.pageY. Давайте посмотрим разницу между clientX/clientY и pageX/pageY.

					Как работают clientX и clientY: если у вас окно 1000 на 1000 пикселей, и мышь находится в центре, то clientX и clientY
					будут оба равны 500. Если вы затем покрутите страницу по горизонтали или вертикали, не двигая курсор, то значения 
					clientX и clientY не изменятся, так как отсчитываются относительно окна, а не документа.

					Как работают pageX и pageY: если у вас есть окно 1000 на 1000 пикселей, и курсор находится в центре, то pageX и pageY 
					будут равны 500. Если вы затем прокрутите страницу на 250 пикселей вниз, то pageY станет равным 750. Таким образом pageX и 
					pageY содержат координаты события с учетом прокрутки.

					Синтаксис:
						event.clientX;

					Пример 1:

						При движении мыши по странице будем выводить ее координаты относительно окна браузера (clientX и clientY):
							html:
								<div id="elem">0 : 0</div>
							
							JavaScript:
								let elem = document.getElementById('elem');

								document.addEventListener('mousemove', function(event) {
									elem.innerHTML = event.clientX + ' : ' + event.clientY;
								});

				Свойство event.clientY:

					Свойство event.clientY содержит в себе координаты курсора мыши по оси Y. 
					Для определения координат есть также свойства event.clientX, event.pageX, event.pageY. 
					Давайте посмотрим разницу между clientX/clientY и pageX/pageY.

					Как работают clientX и clientY: если у вас есть окно 1000 на 1000 пикселей, и мышь находится в центре, 
					то clientX и clientY будут оба равны 500. Если вы затем прокрутите страницу по горизонтали или вертикали, не двигая курсор, 
					то значения clientX и clientY не изменятся, так как отсчитываются относительно окна, а не документа.

					Как работают pageX и pageY: если у вас есть окно 1000 на 1000 пикселей, и курсор находится в центре, то pageX и pageY будут равны 500. 
					Если вы затем прокрутите страницу на 250 пикселей вниз, то pageY станет равным 750. Таким образом pageX и pageY содержат 
					координаты события с учетом прокрутки.

					Синтаксис:
						event.clientY;

					Пример 1:

						При движении мыши по странице будем выводить ее координаты относительно окна браузера (clientX и clientY):
							html:
								<div id="elem">0 : 0</div>

							JavaScript:
								let elem = document.getElementById('elem');

								document.addEventListener('mousemove', function(event) {
									elem.innerHTML = event.clientX + ' : ' + event.clientY;
								});

				Свойство event.pageX:

					Свойство event.pageX содержит в себе коррдинаты курсора мыши по оси X. Для определения координат есть также свойства event.clientX, event.clientY, 
					event.pageY. Давайте рассмотрим разницу между clientX/clientY и pageX/pageY.

					Как работают clientX и clientY: если у вас окно 1000 на 1000 пикселей, и мышь находится в центре, то clientX и clientY
					будут оба равны 500. Если вы затем покрутите страницу по горизонтали или вертикали, не двигая курсор, то значения 
					clientX и clientY не изменятся, так как отсчитываются относительно окна, а не документа.

					Как работают pageX и pageY: если у вас есть окно 1000 на 1000 пикселей, и курсор находится в центре, то pageX и pageY 
					будут равны 500. Если вы затем прокрутите страницу на 250 пикселей вниз, то pageY станет равным 750. Таким образом pageX и 
					pageY содержат координаты события с учетом прокрутки.

					Синтаксис:
						event.pageX;

					Пример 1:

						При движении мыши по странице будем выводить ее координаты относительно окна браузера (pageX и pageY):
							html:
								<div id="elem">0 : 0</div>
							
							JavaScript:
								let elem = document.getElementById('elem');

								document.addEventListener('mousemove', function(event) {
									elem.innerHTML = event.pageX + ' : ' + event.pageY;
								});

				Свойство event.pageY:

					Свойство event.pageY содержит в себе координаты курсора мыши по оси Y. Для определения координат есть также свойства event.clientX, event.clientY, 
					event.pageX. Давайте рассмотрим разницу между clientX/clientY и pageX/pageY.

					Как работают clientX и clientY: если у вас есть окно 1000 на 1000 пикселей, и мышь находится в центре, 
					то clientX и clientY будут оба равны 500. Если вы затем прокрутите страницу по горизонтали или вертикали, не двигая курсор, 
					то значения clientX и clientY не изменятся, так как отсчитываются относительно окна, а не документа.

					Как работают pageX и pageY: если у вас есть окно 1000 на 1000 пикселей, и курсор находится в центре, то pageX и pageY будут равны 500. 
					Если вы затем прокрутите страницу на 250 пикселей вниз, то pageY станет равным 750. Таким образом pageX и pageY содержат 
					координаты события с учетом прокрутки.

					Синтаксис:
						event.pageY;

					Пример 1:

						При движении мыши по странице будем выводить ее координаты относительно окна браузера (pageX и pageY):
							html:
								<div id="elem">0 : 0</div>
							
							JavaScript:
								let elem = document.getElementById('elem');

								document.addEventListener('mousemove', function(event) {
									elem.innerHTML = event.pageX + ' : ' + event.pageY;
								});

			Тип события в объекте Event в JavaScript:

				Объект Event также содержит в себе тип прошедшего события. Под типом понимается название click, mouseover и так далее.
				Тип события содержит свойство type:
					elem.addEventListener('click', function(event) {
						console.log(event.type); // выведет 'click'
					});

			Элемент события в объекте Event в JavaScript:

				Объект Event также позводяет получить элемент, в котором произошло событие. Этот элемент содежится в свойстве target. Зачем это нужно,
				если этот элемент содержится в this?

				Дело в том, что на сама деле this всегда содержит элемент, к которому было привязано событие, а свойство target - элемент, по которому реально 
				был клик. Этот реальный элемент может совпадать с this, а может не совпадать.

				Давайте посмотрим на примере. Пусть у нас есть див, а внутри него абзац:
					<div id="elem">
						<p>text</p>
					</div>

				Привяжем событие к диву, но кликнем по абзацу. Очевидно, что клик по абзацу представляет собой одновременно и клик по диву, так как абзац содержится в 
				нашем диве.

				В описанном случае получится, что свойство target будет содержать конечный тег, в котором случилось событие - то есть абзац, а не див. Убедимся в этом:
					let elem = document.querySelector('#elem');

					elem.addEventListener('click', function(event) {
						console.log(event.target); // выведет наш абзац
						console.log(this);         // выведет наш див
					});

			Получение нажатых клваиш в JavaScript:

				С помощью объекта Event можно получать нажатые клавиши. Давайте посмотрим, как этом делается.
				Пусть у нас есть инпут:
					<input>

				Получим ссылку на него:
					let elem = document.querySelector('input');

				Навесим на наш инпут событие, срабатывающее по каждому нажатию клавиши:
					elem.addEventListener('keypress', function(event) {
	
					});			

				В свойстве key объекта с событием будет лежать нажатый символ:
					elem.addEventListener('keypress', function(event) {
						console.log(event.key);
					});

				А в свойстве code будет лежать код нажатой клавиши:
					elem.addEventListener('keypress', function(event) {
						console.log(event.code);
					});

			Отслеживание клавиш-модификаторов в JavaScript:

				С помощью объекта Event можно узнать, были ли нажаты в момент события клавиши Ctrl, Alt и Shift. Это делается с помощью свойств 
				ctrlKey, altKey и shiftKey - они имеют значение true или false в зависимости от того, была ли нажата эта клвиша в момент события или нет.

				Давайте посмотрим на примере. Пусть у нас дана следующая кнопка:
					<button id="elem">text</button>

				По клику на кнопку будем выводить сообщение о том, была ли нажата одна из клавиш Ctrl, Alt и Shift:
					let elem = document.querySelector('#elem');

					elem.addEventListener('click', function(event) {
						if (event.ctrlKey) {
							console.log('нажат Ctrl');
						}
						
						if (event.altKey) {
							console.log('нажат Alt');
						}
						
						if (event.shiftKey) {
							console.log('нажат Shift');
						}
					});

			Отмена действия по умолчанию в JavaScript:

				Иногда с помощью JavaScript требуется отменить действие тега по умолчанию. К примеру, по нажатию на ссылку отменить переход 
				по этой ссылке. Как правило такое требуется в том случае, если эту ссылку мы используем просто для запуска какого-либо кода. 
				В этом случае то, что при клике на ссылку произойдет переход по ней, нам совсем не нужно.

				Отмена действия по умолчанию производится с помощью объекта Event. Для этого у него есть специальный метод preventDefault(), 
				который следует вызвать в любом месте обработчика события.

				Попробуем на практике. Пусть у нас дана вот такая ссылка:
					<a href="/" id="elem">ссылка</a>

				Давайте сделаем так, чтобы по клику на ссылку не происходило перехода на другую страницу:
					let elem = document.querySelector('#elem');

					elem.addEventListener('click', function(event) {
						event.preventDefault();
						console.log('Вы не можете перейти 
							по этой ссылке!'); 
					});

			Всплытие событий в JavaScript:

				Представьте себе, что у вас есть несколько вложенных друг в друга блоков:
					<div id="elem1">
						<div id="elem2">
							<div id="elem3"></div>
						</div>
					</div>

				Получим ссылки на наши дивы в переменные:
					let elem1 = document.querySelector('#elem1');
					let elem2 = document.querySelector('#elem2');
					let elem3 = document.querySelector('#elem3');

				А теперь навесим на них обработчики кликов:
					elem1.addEventListener('click', function() {
						alert('зеленый');
					});
					elem2.addEventListener('click', function() {
						alert('голубой');
					});
					elem3.addEventListener('click', function() {
						alert('красный');
					});

				Нажмите теперь на самый внутренний красный блок - и вы увидите, как событие сначала сработает в красном блоке, потом в 
				голубом, потом в зеленом. И это логично, ведь кликая на внутренний блок, вы одновременно кликаете на все внешние.

				То есть получается, что когда вы кликаете на самый внутренний блок, событие клика  возникает сначала в нем, затем срабатывает 
				в его родителе, в родителе его родителя и так далее, пока не дойдет до самого верха. 

				Такое поведение называется всплытием событий - по аналогии со сплытием пузырька воздуха со дна. Также, как и пузырек, наше событие 
				как будто всплывает наверх, каждый раз срабатывая на более высоких блоках. 

			Получение целевого элемента при всплытии событий в JavaScript:

				Пусть у нас два элемента: div и абзац p, лежащий внутри этого дива:
					<div>
						<p></p>
					</div>

				Получим ссылку на наш див в переменную:
					let div = document.querySelector('div');

				Добавим нашим тегам некоторые стили:
					div {
						padding: 20px;
						border: 1px solid red;
					}

					p {
						width: 200px;
						height: 200px;
						border: 1px solid green;
					}

				Пусть теперь на див навешен обработчик клика:
					div.addEventListener('click', function() {
						console.log('click');
					});

				Из-за того, что див имеет padding, то, когда мы кликаем на див, мы можем попать по абзацу а может попасть в место, где 
				этого абзаца нет, то есть непосредственно по диву.

				При этом в обработчике клика this всегда будет указывать на тот элемент, на который навешан обработчикю В нашем случае это наш див:
					div.addEventListener('click', function() {
						console.log(this); // див
					});

				Однако, мы можем получить именно тот тег, в котором случилось событие. Для этого мы можем посмотреть, что лежит в event.target:
					div.addEventListener('click', function(event) {
						console.log(event.target); // или див, или абзац
					});

				Можно различить эти два варианта с помощью условий:
					let div = document.querySelector('div');

					div.addEventListener('click', function(event) {
						if (event.target.tagName === 'DIV') {
							console.log('клик именно по диву');
						}
						if (event.target.tagName === 'P') {
							console.log('клик именно по абзацу');
						}
					});

				Можно вместо tagName использовать matches:
					let div = document.querySelector('div');

					div.addEventListener('click', function(event) {
						if (event.target.matches('div')) {
							console.log('клик именно по диву');
						}
						if (event.target.matches('p')) {
							console.log('клик именно по абзацу');
						}
					});

			Прекращение всплытия событий в JavaScript:

				Всплытие события можно остановить на любой элемент, через который всплывает событие. Для этого в коде элемента следует вызвать метод
				stopPropagation объекта Event.

				В следующем примере клик по красному блоку сработает на нем самом, затем на голубом блоке и все - голубой блок прекращает дальнейшее 
				всплытие и зеленый блок уже никак не реагирует:
					elem1.addEventListener('click', function() {
						console.log('зеленый');
					});
					elem2.addEventListener('click', function(event) {
						console.log('голубой');
						event.stopPropagation(); // остановим всплытие
					});
					elem3.addEventListener('click', function() {
						console.log('красный');
					})

			Несколько обработчиков на элементе в JavaScript:

				Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены. 
				То есть, stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики отработают.  
				Смотрите пример:
					elem1.addEventListener('click', function() {
						console.log('зеленый');
					});
					elem2.addEventListener('click', function(event) {
						console.log('голубой - первый обработчик');
						event.stopPropagation(); // остановим всплытие
					});
					elem2.addEventListener('click', function() {
						console.log('голубой - второй обработчик'); 
							// все равно сработает 
					});
					elem3.addEventListener('click', function() {
						console.log('красный');
					});

			Немедленное прекращение всплытия в JavaScript:

				Для того, чтобы полностью остановить обработку, современные браузеры поддердживают метод stopImmediatePropagation.
				Он не только предотвращает всплытие, но и останавливает обработку событий на текщем элементе. Давайте его применим:
					elem1.addEventListener('click', function() {
						console.log('зеленый');
					});
					elem2.addEventListener('click', function(event) {
						console.log('голубой - первый обработчик');
						event.stopImmediatePropagation();     // остановим всплытие
					});
					elem2.addEventListener('click', function() {
						console.log('голубой - второй обработчик'); 
							// уже не сработает 
					});
					elem3.addEventListener('click', function() {
						console.log('красный');
					});

			Применение прекращения всплытия в JavaScript:

				Пусть внутри одного родителя у нас есть кнопка и некоторый блок:
					<div id="parent">
						<button>click me</button>
						<div id="block">
							text
						</div>
					</div>

				Получим ссылки на наши элементы в переменные:
					let parent = document.querySelector('#parent');
					let button = document.querySelector('button');
					let block  = document.querySelector('#block');

				Пусть наш блок изначально скрыт:
					#block:not(.active) {
						display: none;
					}

				Сделаем так, чтобы по клику на кнопку наш блок показался:
					button.addEventListener('click', function() {
						block.classList.add('active');
					});

				А теперь сделаем так, чтобы по клику на любое место родителя наш блок скрывался:
					parent.addEventListener('click', function() {
						block.classList.remove('active');
					});

				Нас, однако ждет неожиданный сюрприз: так как кнопка находится внутри родителя, то клик по кнопке одновременно дает означает 
				и клик по родителю. Это значит, что сначала наш блок покажется, а затем из-за всплытия события сработает обработчик в родителе и наш
				блок скроется.

				Вот тут-то нам и пригодится воможность отменить всплытие: мы можем сделать так, чтобы при клике на кнопку отменялость всплытие, родитель
				не реагировал на этот клик.

			Погружение событий в JavaScript:

				Кроме всплытия событий есть еще и погружение. На самом деле событие сначала идет сверху вниз (стадия перехвата), доходит до 
				вашего элемента (стадия цели) и только потом начинает всплывать (стадия всплытия).

				Для того, чтобы повесить обработчик события с учетом стадии перехвата в addEventListener есть третий необязательный параметр. Если он 
				равен true - событие сработает на стадии перехвата, а если false - на стадии всплытия (это по умолчанию).
				Давайте посмотрим на примере:
					elem1.addEventListener('click', function() {
						console.log('зеленый - погружение');
					}, true);
					elem1.addEventListener('click', function() {
						console.log('зеленый - всплытие');
					}, false);

					elem2.addEventListener('click', function() {
						console.log('голубой - погружение');
					}, true);
					elem2.addEventListener('click', function() {
						console.log('голубой - всплытие');
					}, false);

					elem3.addEventListener('click', function() {
						console.log('красный - погружение');
					}, true);
					elem3.addEventListener('click', function() {
						console.log('красный- всплытие');
					}, false);

			Навешивание обработчиков на новые элементы в JavaScript:

				Пусть у нас есть список ul и кнопка:
					<ul>
						<li>item</li>
						<li>item</li>
						<li>item</li>
						<li>item</li>
						<li>item</li>
					</ul>

					<button>add</button>

				Получим наши элементы в соответствующие переменые:
					let button = document.querySelector('button');
					let list   = document.querySelector('ul');
					let items  = list.querySelectorAll('li');

				Сделаем так, чтобы по клику на любую li ей в конец добавлялся восклицательный знак:
					for (let item of items) {
						item.addEventListener('click', function() {
							this.textContent = this.textContent + '!';
						});
					}

				Давайте теперь сделаем так, чтобы по нажатию на кнопку в конец списка добавлялся новая li:
					button.addEventListener('click', function() {
						let item = document.createElement('li');
						item.textContent = 'item';
						list.appendChild(item);
					});

				Мы, однако, получим проблему: клик на новую добавленную li не будет приводить к добавлению 
				восклицательного знака в конец. Дело в том, что мы добавляем обработчик клика только на те li, 
				которые существовали изначально, но не на новые.

				Исправим проблемуЮ навесив на новую li обработчик клика:
					button.addEventListener('click', function() {
						let item = document.createElement('li');
						item.textContent = 'item';
						
						item.addEventListener('click', function() 
							{ // обработчик клика 
							this.textContent = this.textContent + '!';
						});
						
						list.appendChild(item);
					});

				Однако, теперь код функции-обработчика дублируется в двух местах - для изначально существующих li 
				и для новых. Исправим это, вынеся его в отдельную функцию:
					function handler() {
						this.textContent = this.textContent + '!';
					}

				Используем нашу функцию, чтобы избежать дублирования кода:
					for (let item of items) {
						item.addEventListener('click', handler);
					}

					button.addEventListener('click', function() {
						let item = document.createElement('li');
						item.textContent = 'item';
						
						item.addEventListener('click', handler);
						
						list.appendChild(item);
					});

				Задача в общем-то решена, и мы избежали дублирования кода функции-обработчика. Однако, навешивать обработчики 
				событий нам все равно приходится в двух местах: и в цикле для существующих li, и при клике на кнопку. В следующем уроке 
				мы разберем способ избавиться от этого неудобства. 

			Делегирование событий в JavaScript:

				В предыдущем уроке была описана проблема, возникающая при добавлении новых элементов, и приведено ее решение. В данном уроке мы рассмотрим 
				более удачный способ обойти проблему - делегирование событий. Давайте его разберем.

				Как вы уже знаете, кликая на li, мы одновременно кликаем и на ul. Это возможно благодаря всплытию событий. Мы можем использовать это для решения 
				нашей задачи: навесим событие не на каждую li и на их родителя ul:
					list.addEventListener('click', function() {
	
					});

				Теперь в обработчике события this будет указывать на элемент, к которому привязан обработчик, а event.target - на элемент, в котором случилось
				событие:
					list.addEventListener('click', function(event) {
						console.log(this);         // наш список
						console.log(event.target); // пункт списка
					});

				Сделаем так, чтобы на li, на которой случился клик, в конец добавлялся восклицательный знак:
					list.addEventListener('click', function(event) {
						event.target.textContent = event.target.textContent + '!';
					});

			Универсальное делегирование событий в JavaScript:

				Приведенный в предыдщем уроке код рабочий, однако, не без недостатков.
				Давайте разберем эти недостатки и напишем более универсальное решение.

				Недостаток нашего кода проявится в том случае, когда внутри li будут какие-то вложенные теги. В нашем случае 
				пусть это будут теги i:
					<ul>
						<li>item <i>italic</i> item</li>
						<li>item <i>italic</i> item</li>
						<li>item <i>italic</i> item</li>
						<li>item <i>italic</i> item</li>
						<li>item <i>italic</i> item</li>
					</ul>

				В этом случае нажатие на тег i приведет к добавлению восклицательного знака в конец тега i, а не тега li, как мы хотели бы -
				ведь в event.target попадает именно тот тег, в котором случилось событие.

				Решить проблему можно с помощью метода closest:
					list.addEventListener('click', function(event) {
						let li = event.target.closest('li');
						
						if (li) {
							li.textContent = li.textContent + '!';
						}
					});

		КОНТЕКСТ:

			Основы работы с контекстом в JavaScript:

				Пусть у нас есть какая-нибудь функция func, внутри которой используется this:
					function func() {
						console.log(this.value);
					}

				На что указывает this в этой функции? А мы не знаем. И JavaScript не знает. И сама функция не знает. То есть 
				в момент создания функции то, на что именно указывается this, не определено. И определится это только тогда, 
				когда эта функция будет вызвана.

				Пусть у нас есть какой-то инпут:
					<input id="elem" value="text">

				Привяжем к этому инпуту нащу функцию func так, чтобы она выполнилась по потери фокуса инпутом. Теперь в момент 
				выполнения функции this будет указывать на наш инпут:
					 let elem = document.querySelector('#elem');

						elem.addEventListener('blur', func);
						function func() {
							console.log(this.value); // по потери 
								фокуса выведет 'text' 
						}

				Но ведь у нас может быть не один инпут, а несколько:
					<input id="elem1" value="text1">
					<input id="elem2" value="text2">

				И к каждому из этих инпутов мы можем привязать нашу функцию func. В этом случае для первого элемента this в 
				момент вызова функции будет указывать на него, а для второго - на него.

				На практике это значит, что this внутри функции зависит от того, на каком из инпутов мы потеряли фокус:
					let elem1 = document.querySelector('#elem1');
					elem1.addEventListener('blur', func);

					let elem2 = document.querySelector('#elem2');
					elem2.addEventListener('blur', func);

					function func() {
						console.log(this.value); // выведет 
							или 'text1', или 'text2' 
					}

				В общем-то, такая особенность this очень удобна - мы создаем всего одну функцию и привязываем ее к любому количеству 
				ингпутов. Если бы this не указывал на тот элемент, в котором произошло бы событие, то у нас бы такое не получилось -
				пришлось бы для каждого инпута создавать свою функцию с тем же кодом!

			Контекст непривязанной функции в JavaScript:

				Давайте посмотрим, что будет, если в функции указать this, но не привязать ее ни к какому элементу,
				вот так:
					function func() {
						console.log(this);
					}

					func();	

				В этом случае результат зависит от того, строгий у нас режим или нет. Если режим не строгий, то в this 
				будет храниться ссылка на window:
					function func() {
						console.log(this); // ссылка на окно window
					}

					func();

				А если режим строгий, то в this будет храниться undefined:
					"use strict";

					function func() {
						console.log(this); // undefined
					}

					func();

				Из сказанного выше может показаться, что в строгом режиме this всегда будет indefined. Как бы не так! Если 
				просто вывести this вне функции, то в нем будет ссылка на windiow независимо от режима:
					"use strict";
					console.log(this); // в this ссылка на window

				Выводы:

					В любой функции можно написать this, это не приведет к каким-либо ошибкам JavaScript. Но вот что именно 
					будет лежать в этом this не определено до момента вызова функции. Причем при разных вызовах функции this
					может принимать разное значение. Все зависит от контекста, в котором была вызвана функция.  

			Потеря контекста в JavaScript:

				Пусть у нас есть функция в функции. Давайте внешнюю функцию назовем парент, а внутренню - child:
					function parent() {
						function child() {
							
						}
					}

				Из предыдущих уроков вы знаете, что если задать какую-либо переменную во внешней функции - она 
				будет доступна во внутренней:
					function parent() {
						let str = 'abcde';
						
						function child() {
							console.log(str); // выведет 'abcde'
						}
						child(); // вызываем внутреннюю функцию
					}

					parent(); // вызываем внешнюю функцию 

				Есть однако, нюанс: внутренняя функция имеет доступ ко всем переменным внешней, но не имеет доступа this. 
				То есть: если внешняя функция привязана к какому-то DOM элементу, то this в ней будет указывать на тот элемент, 
				но this внутренней функции - не будет!

				На что же тогда будет указывать this внутренней функции? Ответ: он будет равен undefined (в строгом режиме), так 
				как функция ни к чему не привязана.

				Давайте проверим на пракике. Пусть у нас дан инпут:
					<input id="elem" value="text"> 

				Привяжем к этому инпуту функцию parent, которая будет вызываться по потери фокуса инпутом:
					"use strict";

					let elem = document.querySelector('#elem');
					elem.addEventListener('blur', parent);

					// Вызовется по потери фокуса:
					function parent() {
						// тут будет какой-то код
						
						function child() {
							// тут будет какой-то код
						}
						child(); // вызываем дочернюю функцию
					}

				Давайте теперь выведем содержимое this в консоль в двух местах: внутри функции parent и внутри функции 
				child:
					"use strict";

					let elem = document.querySelector('#elem');
					elem.addEventListener('blur', parent);

					function parent() {
						console.log(this); // выведет 
							ссылку на наш инпут 
						
						function child() {
							console.log(this); // выведет undefined
						}
						child();
					}

				Запустите этот код, потеряйте фокус инпуту и посмотрите в консоль - вы увидите, что первый console.log выведет в 
				консоль ссылку на наш инпут, а второй - просто undefined. Такая ситуация, когда this неожиданным для вас образом 
				указывает не на то, что нам нужно, называется потеря контекста.

			Контекст через переменную в JavaScript:

				Решение проблемы предыдущего урока следующее: во внешней функции запишем this в любую переменную и эта 
				переменная будет доступна во внутренней функции, как и все переменные (обычно эту переменную называют self).
				Таким образом мы передадим this из внешней функции во внутреннюю:
					"use strict";

					let elem = document.querySelector('#elem');
					elem.addEventListener('blur', parent);

					function parent() {
						console.log(this.value); // выведет 'text'
						
						let self = this; // запишем this в любую 
							переменную, например, в self 
						
						function child() {
							console.log(self.value); // выведет 'text'
						}
						child();
					}


 






































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					



					





































































					
					








































































				
























































































